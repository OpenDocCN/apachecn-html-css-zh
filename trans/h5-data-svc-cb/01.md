# 第一章。文本数据的显示

在本章中，我们将涵盖以下主题:

*   显示的舍入数字
*   填充数字
*   显示公制和英制尺寸
*   在用户的时区显示格式化日期
*   显示已经过去的动态时间
*   显示数学
*   创建无休止的滚动列表
*   创建可排序的分页表
*   创建多选过滤器
*   创建范围过滤器
*   创建组合的复杂过滤器
*   用超文本标记语言显示代码
*   渲染降价
*   自动更新字段

# 简介

与 web 应用程序开发相关的最常见任务是显示文本。本章将介绍程序员在浏览器中显示数据时面临的一些问题，并解释如何以简单而有效的方式解决这些问题，为程序员提供几种不同的选择。这些示例将包含标记的呈现或其他数据类型到纯文本的转换。

# 显示的舍入数字

在应用程序中，仅次于文本的第二种最常见的数据类型是数字。处理数字有许多不同的方式，当需要给定精度时，我们将看看其中的一些方式。第一个显而易见的选择是使用 JavaScript `Number`对象包装器来处理数值。

## 做好准备

`Number`对象包含可用于显示数字的`toFixed([digits])`方法；这里`digits`参数的值可以在 0 到 20 之间。如果需要，该数字将自动舍入，或者如果需要，该数字将使用额外的零填充。好吧，让我们看看它是如何运作的。

## 怎么做...

执行以下步骤演示如何使用`Number`对象:

1.  首先，我们将创建一个数字列表；请注意，这些数字是为了说明函数的一些特性而特意挑选的:

    ```html
        var listOfNumbers=
            [1.551, 1.556, 1.5444, 1.5454, 1.5464, 1.615, 1.616, 1.4, 1.446,1.45];
    ```

2.  使用`.toFixed()`方法迭代列表并显示数字，相应地使用`digits`参数的值 0、1 和 2:

    ```html
    for (var i = 0; i < listOfNumbers.length; i++) {
          var number = listOfNumbers[i];
             // iterate over all of the numbers and write to output all the value
          document.write(number + "---"
                       + number.toFixed(2) + "---"
                       + number.toFixed(1) + "---"
                       + number.toFixed() + "<br />");
        };
    ```

## 它是如何工作的…

从执行代码中检索到的结果将打印出数字及其各自的`toFixed`表示，这应该很简单。

让我们来看看一些特征值:

*   `1.616.toFixed(2)`将返回`1.62`
*   `1.4.toFixed(2)`将如预期返回`1.40`，添加一个尾随零
*   `1.5454.toFixed()`将返回`2`，因为`toFixed()`的默认值是`0`；这意味着没有小数点，此外`0.5`段被舍入到`1`，因此这里使用的是上限值
*   `1.615.toFixed(2)`要么返回`1.61`，忽略`0.005`段，要么使用楼层值

`toFixed()`方法的工作原理基本上和预期的一样，只要我们不需要更高的精度，或者只是用它来显示舍入类型不是关键任务的数字。

此外，当我们有 1.446 等属于同一类别的数字时，当我们需要舍入时，我们不能依赖`toFixed()`；调用`1.446.toFixed(1)`会导致不一致和不可预测的结果。

## 还有更多...

有各种方法可以解决这个问题。快速而肮脏的解决方案是重新定义`Number.prototype.toFixed()`功能，但我们鼓励你不要这样做，因为这样做可能会有不明显的副作用。从内置对象对函数的任何重新定义，如果不是绝对必要的，都被认为是反模式的。如果另一个库或一段代码使用相同的函数，就会出现问题。另一个库可能期望我们重新定义的函数以某种方式工作。这些类型的重新定义很难跟踪；即使我们要添加一个函数而不是重新定义它，其他人也可能会做同样的事情。例如，假设我们决定给`Number`对象添加一些功能:

```html
Number.prototype.theFunction = function(arg1,arg2){}
```

不能保证其他人没有将`theFunction`添加到`Number`对象中。我们可以做额外的检查来验证该函数是否已经存在，但是我们不能确定它是否完成了我们想要它做的事情。

相反，使用实用函数来实现一致的数据将是一个更好的选择。

解决问题的一种方法是先将数字与`10 ^ digits`相乘，然后对结果调用`Math.round(number)`方法，也可以调用`Math.ceil(number)`。例如，如果需要将值向上舍入到最接近的整数，请使用以下公式:

```html
    function round(number, digits) {
        if(typeof digits === "undefined" || digits < 0){
          digits = 0;
        }
        var power = Math.pow(10, digits),
         fixed = (Math.round(number * power) / power).toString();
        return fixed;
    };
```

现在，随着数字得到乘以`10 ^ digits`然后四舍五入，我们没有观察到`toFixed()`的问题。请注意，该方法与`toFixed()`的行为不同，不仅在于如何处理舍入，还在于添加尾随零。

如果精度至关重要，另一种选择是使用任意精度库，如 big . js([https://github.com/MikeMcl/big.js](https://github.com/MikeMcl/big.js))。

# 填充数字

我们有时需要将数字填充到一定的范围内。例如，假设我们想用五个可能的数字显示一个数字，如`00042`。一个显而易见的解决方案是使用迭代方法并添加字符，但是有一些更干净的解决方案。

## 做好准备

首先，我们需要看一下我们将要使用的一些功能。让我们来看看`Array.join(separator)`方法，它可以应用于从元素列表中创建连接的文本:

```html
new Array('life','is','life').join('*')
```

这将导致`"life*is*life"`显示与给定分隔符连接的相当简单的元素。另一个有趣的方法是`Array.slice(begin[, end])`，它返回一个数组的一部分的副本。对于我们的使用，我们只对可以有正值和负值的`begin`参数感兴趣。如果我们使用正值，这意味着这将是使用从零开始的索引的切片的起始索引；例如，考虑下面一行代码:

```html
new Array('a','b','c','d','e','f','g').slice(4);
```

前一行代码将返回一个包含元素`'e'`、`'f'`和`'g'`的数组。

另一方面，如果对`begin`元素使用负值表示从数组末尾的偏移，考虑使用负值的相同示例，如下所示:

```html
new Array('a','b','c','d','e','f','g').slice(-3);
```

结果会是`'e','f','g'`，因为我们从最后开始切割。

## 怎么做...

让我们回到我们的问题:我们如何创建一个干净的解决方案，在数字前面加上零？对于迭代解决方案，我们创建了一个方法，该方法接受数字、格式化结果的大小以及将用于填充的字符；我们以`'0'`为例:

```html
function iterativeSolution(number,size,character) {
   var strNumber = number.toString(),
    len = strNumber.length,

    prefix = '';
   for (var i=size-len;i>0;i--) {
      prefix += character;
   }
 return prefix + strNumber;
}
```

在这里，我们将数字转换为字符串，以获得其表示的长度；然后，我们简单地创建`prefix`，它将具有`character`变量的`size–len`字符，并返回结果`prefix + strNumber`，这是该数字的字符串表示。

你可能会注意到，在`size`小于`len`的情况下，会返回原来的数字，为了让该功能在那个角落的情况下工作，这可能需要更改。

另一种方法是使用`Array.slice()`方法来获得类似的结果:

```html
function sliceExample(number,prefix){
   return (prefix+number).slice(-prefix.length);
}
sliceExample(42,"00000");
```

这将只是在一个数字前面加上一个前缀，并从末尾去掉多余的`'0'`计数，使解决方案更加清晰，此外，使我们能够更灵活地处理前缀的一部分。这样做的缺点是，我们正在手动构建前缀，它将成为方法调用`sliceExample(42,"00000")`的一部分。为了使这个过程自动化，我们可以利用`Array.join`:

```html
function padNumber(number,size,character){
  var prefix = new Array(1 + size).join(character);
```

我们创建一个预期`size + 1`的数组，当加入时，我们将得到总数组`size-1 joined elements`。这将构造具有预期大小的前缀，而另一部分将保持不变:

```html
  return (prefix + number).slice(-prefix.length);
 }
```

一个示例方法调用将是`padNumber(42,5,'0')`；这将没有以前方法的灵活性，但在大量使用时会简单得多。

## 它是如何工作的…

配方相当简单，但需要注意的一点是功能方法。如果说从这个食谱中可以带走一件东西，那就是迭代解并不总是最好的。说到 JavaScript，通常还有其他几种方法可以完成你所拥有的任务；它们并不总是像 T2 那样简单，有时甚至不会更快，但它们可以更干净。

## 还有更多...

如果出于某种原因，我们经常填充数字，那么将该函数添加到`Number`对象中并删除带有`this`关键字的`input`参数可能是有意义的:

```html
Number.prototype.pad=function(size,character){
     //same functionality here
}
```

由于函数现在是每个`Number`对象的一部分，我们可以从任何数字直接使用它；让我们举下面的例子:

```html
  3.4.pad(5,'#');
```

此外，如果`'.'`字符不应该包含在填充的计算中，我们可以添加一个额外的检查来减少前缀的大小。

### 注

请注意，在*显示*配方的舍入数字中，我们解释了为什么向标准对象添加函数是一种会适得其反的攻击。

# 显示公制和英制尺寸

处理计算和测量的网站经常需要解决同时使用公制和英制测量单位的问题。该配方将展示一种数据驱动的方法来处理单位转换。由于这是一本 HTML5 书籍，解决方案将在客户端而不是服务器端实现。

我们将在客户端实现一个“理想重量”计算器，支持公制和英制测量。这次我们将创建一个更通用、更优雅的数据驱动解决方案，利用现代 HTML5 的功能，比如数据属性。目标是尽可能抽象出混乱和容易出错的转换。

## 做好准备

体重指数(身体质量指数)的计算公式如下:

身体质量指数=(重量单位为千克/(高度单位为米×高度单位为米))

我们将使用身体质量指数= 22 来计算“理想重量”。

## 怎么做...

1.  Create the following HTML page:

    ```html
    <!DOCTYPE HTML>
    <html>
        <head>
            <title>BMI Units</title>
        </head>
        <body>
            <label>Unit system</label>
            <select id="unit">
                <option selected value="height=m,cm 0;weight=kg 1;distance=km 1">Metric</option>
                <option value="height=ft,inch 0;weight=lbs 0;distance=mi 1">Imperial</option>
            </select><br>

            <label>Height</label>
            <span data-measurement="height" id="height">
                <input data-value-display type="text" id="height" class="calc">
                <span data-unit-display></span>
                <input data-value-display type="text" id="height" class="calc">
                <span data-unit-display></span>
            </span>
            <br>
            <label>Ideal Weight</label>
            <span data-measurement="weight" id="weight">
                <span data-value-display type="text">0</span>
                <span data-unit-display></span>
            </span> <br>

            <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
            <script type="text/javascript" src="unitval.js"></script>
            <script type="text/javascript" src="example.js"></script>
            </script>
        </body>
    </html>
    ```

    这个页面看起来非常像我们为基于身体质量指数的理想体重计算器制作的常规页面。主要区别如下:

    *   我们有英制/公制选择输入
    *   我们还有额外的自定义数据属性来赋予 HTML 字段特殊的含义
    *   我们使用`data-measurement`来表示元素将显示的测量类型(例如，重量或高度)
    *   我们使用`data-display-unit`和`data-display-value`分别表示显示单位字符串和测量值的字段
2.  Create a file named `example.js` with the following code:

    ```html
    (function() {
        // Setup unitval
        $.unitval({
            weight: {
                "lbs": 0.453592, // kg
                "kg" : 1 // kg
            },
            height: {
                "ft"  : 0.3048, // m
                "inch": 0.0254, // m
                "m"   : 1, // m
                "cm"  : 0.01, // m
            }
        });
        $("#unit").change(function() {
            var measurementUnits = $(this).val().split(';').map(function(u) {
                var type_unitround = u.split('='),
                    unitround = type_unitround[1].split(' ');
                return {
                    type: type_unitround[0],
                    units: unitround[0].split(','),
                    round: unitround[1]
                };
            });
            // Setup units for measurements.
            $('body').unitval(measurementUnits);
        });

        $("#unit").trigger("change");

        $('#height').on('keyup change',function() {
            var height = $('#height').unitval(), bmi = 22;
            var idealWeight = bmi * height * height;
            $("#weight").unitval(idealWeight);
        });

    }
    ```

    代码的第一部分配置了一个名为`unitval`的 jQuery 插件，带有我们将要使用的度量和单位(重量和高度)的转换因子。

    第二部分通过从`select`字段读取规格来设置文件的测量单位。它指定了一组测量值，每个测量值具有以下内容:

    *   打字字符串，例如`"height"`
    *   单位列表，例如`["ft", "inch"]`
    *   用于最后一个单位的小数位数

    第三部分是一个普通的计算器，它的书写方式几乎与没有单位转换时的书写方式完全相同。唯一的例外是使用名为`$.unitval`的 jQuery 插件从具有`data-measurement`属性的元素中获取值。

3.  我们要写一个通用的单位转换器。它需要两个功能:一个是将用户显示(输入)的数据转换成标准国际(国际)测量单位，另一个是将其从国际单位制单位转换回用户友好的显示单位。我们的转换器将支持同时使用多个单元。从输入转换时，第一个参数是测量类型(例如距离)，第二个参数是值单位对的数组(例如`[[5, 'km'], [300,'m']]`)，单个对(例如`[5,'km']`)或简单的值(例如`5`)。
4.  If the second parameter is a simple value, we're going to accept a third one containing the unit (for example `'km'`). The output is always a simple SI value.

    当将一个值转换为所需的输出单位时，我们将单位指定为数组，例如`['km', 'm']`或单个单位。我们还为最后一个单位指定了舍入小数。我们的输出是一组转换后的值。

    使用`Factors`对象中的值进行转换。这个对象包含我们将要使用的每个测量名称的属性。每个这样的属性都是一个对象，该测量的可用单位是属性，它们的国际单位制因子是值。请看下面`example.js`中的例子。

5.  jQuery 插件`unitval.js`的源代码如下:

    ```html
    (function() {
        var Factors = {};
        var Convert = window.Convert = {
            fromInput: function(measurement, valunits, unit) {
                valunits = unit ? [[valunits, unit]] // 3 arguments
                    : valunits instanceof Array && valunits[0] instanceof Array ? valunits  
                    : [valunits]; // [val, unit] array

                var sivalues = valunits.map(function(valunit) { // convert each to SI
                    return valunit[0] * Factors[measurement][valunit[1]];
                });
                // sivalues.sum():
                return sivalues.reduce(function(a, e) { return a + e; });
            },
            toOutput: function(measurement, val, units, round) {
                units = units instanceof Array ? units : [units];
                var reduced = val;
                return units.map(function(unit, index) {
                    var isLast = index == units.length - 1,
                        factor = Factors[measurement][unit];
                    var showValue = reduced / factor;
                    if (isLast && (typeof(round) != 'undefined'))
                        showValue = showValue.toFixed(round) - 0;
                    else if (!isLast) showValue = Math.floor(showValue);
                    reduced -= showValue * factor;
                    return showValue;
                });
            }
        };
        $.unitval = function(fac) {
            Factors = fac;
        }
        // Uses .val() in input/textarea and .text() in other fields.
        var uval = function() {
            return ['input','textarea'].indexOf(this[0].tagName.toLowerCase()) < 0 ?
                    this.text.apply(this, arguments) : this.val.apply(this, arguments);
        }
    ```

6.  我们的通用转换器是有用的，但不是很方便或用户友好；我们仍然需要手动完成所有的转换。为了避免这种情况，我们将把数据属性放在元素上，表示它们显示的度量。在它们里面，我们将放置单独的元素来显示值和单位。当我们设置测量单位时，函数`setMeasurementUnits`会将它们设置在具有该数据属性的每个元素上。此外，还会相应调整内值和单位要素:

    ```html
    // Sets the measurement units within a specific element.
    // @param measurements An array in the format [{type:"measurement", units: ["unit", ...], round:N}]
    // for example [{type:"height", units:["ft","inch"], round:0}]
        var setMeasurementUnits = function(measurements) {
            var $this = this;
            measurements.forEach(function(measurement) {
                var holders = $this.find('[data-measurement="'+measurement.type+'"]');
                var unconverted = holders.map(function() { return $(this).unitval(); })
                holders.attr('data-round', measurement.round);
                holders.find('[data-value-display]').each(function(index) {
                    if (index < measurement.units.length)    
                        $(this).show().attr('data-unit', measurement.units[index]);
                    else $(this).hide();
                });
                holders.find('[data-unit-display]').each(function(index) {
                    if (index < measurement.units.length)    
                        $(this).show().html(measurement.units[index]);
                    else $(this).hide();
                });

                holders.each(function(index) { $(this).unitval(unconverted[index]); });
            });
        };
    ```

7.  由于每个元素都知道自己的度量和单位，我们现在可以简单地将 SI 值放入其中，并让它们显示转换后的值。为此，我们将写`unitval`。它允许我们设置和获取“统一”值，或者在具有`data-measurement`属性 :

    ```html
        $.fn.unitval = function(value) {
            if (value instanceof Array) {
                setMeasurementUnits.apply(this, arguments);
            }
            else if (typeof(value) == 'undefined') {
                // Read value from element
                var first       = this.eq(0),
                    measurement = first.attr('data-measurement'),
                    displays    = first.find('[data-value-display]:visible'),
                    // Get units of visible holders.
                    valunits = displays.toArray().map(function(el) {
                        return [uval.call($(el)), $(el).attr('data-unit')] });
                // Convert them from input
                return Convert.fromInput(measurement, valunits);
            }
            else if (!isNaN(value)) {
                // Write value to elements
                this.each(function() {
                    var measurement   = $(this).attr('data-measurement'),
                        round         = $(this).attr('data-round'),
                        displays      = $(this).find('[data-value-display]:visible'),
                        units         = displays.map(function() {
                            return $(this).attr('data-unit'); }).toArray();
      var values = Convert.toOutput(measurement, value, units, round);
                    displays.each(function(index) { uval.call($(this), values[index]); });
                });
            }
        }
    }());
    ```

    的元素上设置单位选项

这个插件将在下一节解释。

## 它是如何工作的...

HTML 元素没有度量单位的概念。为了支持单位转换，我们添加了自己的数据属性。这些允许我们给某些元素赋予特殊的意义——这些元素的细节由我们自己的代码决定。

我们的惯例是，具有`data-measurement`属性的元素将用于显示指定测量的值和单位。例如，带有`data-measurement="weight"`属性的字段将用于显示重量。

这个元素包含两种类型的子元素。第一种类型的具有`data-display-value`属性，并显示测量值(始终为数字)。第二种类型具有`data-display-unit`属性，并显示测量单位(例如，`"kg"`)。对于用多个单位表示的测量值(例如，高度可以用“5 英尺 3 英寸”的形式表示)，我们可以使用两种类型的多个字段。

当我们改变单位系统时，`setMeasurementUnits`向以下元素添加额外的数据属性:

*   `data-round`属性附加到`data-measurement`元素
*   包含适当单位的`data-unit attributes`被添加到`data-display-value`元素中
*   `data-display-unit`元素用适当的单位填充

因此，`$.unitval()`知道我们页面上每个测量元素上显示的值和单位。该函数读取测量值并将其转换为国际单位制，然后返回。我们用国际单位制进行所有的计算。最后，在调用`$.unitval(si_value)`时，我们的值会在显示前自动转换为合适的单位。

该系统通过识别只有在读取用户输入和显示输出时才真正需要转换，最大限度地减少了容易出错的单元转换代码量。此外，数据驱动方法允许我们从代码中完全省略转换，专注于我们的应用程序逻辑。

# 显示用户时区的格式化日期

在这个食谱中，我们将学习如何在用户的本地时区中格式化用户的日期并显示它；另外，我们将看到日期是如何在 JavaScript 中使用和表示的。最好的方法是让用户选择他们希望显示日期的时区，但不幸的是，这很少是一个选项。

## 做好准备

就像大多数编程语言一样，JavaScript 使用 Unix 时间。这实际上是一个系统，用于表示给定的时间实例，从 1970 年 1 月 1 日午夜开始，在世界协调时(通常称为 UTC)已经过去了多少秒，或者在 JavaScript 的情况下，几毫秒。

### 注

关于世界协调时的一些有趣的琐事:缩写是法语版本的 Temps Universel Coordonné和英语版本的 Coordinated Universal Time 之间的妥协，前者将是 TUC，后者将是 CUT([http://en . Wikipedia . org/wiki/Coordinated _ Universal _ Time #缩写](http://en.wikipedia.org/wiki/Coordinated_Universal_Time#Abbreviation))。

这个数字实际上并不完全符合 UTC，也不能说明闰秒等各种非典型情况，但这在大多数情况下是可以接受的。

在 JavaScript 中，我们有`Date`对象，可以用不同的方式构建:

```html
new Date() // uses local time
new Date(someNumber) //create date with milliseconds since epoch
new Date(dateString) // create date from input string representation
new Date(year, month, day [, hour, minute, second, millisecond])
```

### 注

请注意，从字符串表示创建日期在不同的浏览器中可能有不同的行为，同样的事情也适用于将字符串解析为日期的`Date.parse`方法。

在构建过程中，如果您提供了一些参数，而忽略了可选参数，那么它们将默认为零。还有一点需要注意的是，JavaScript 中的月份是以零为基础的，而天数不是。

### 注

使用 JavaScript `Date`对象作为函数而不是构造函数，使用`new Date(...)`，将导致您得到该日期的字符串表示，而不会得到`Date`对象，就像您在大多数其他 JavaScript 对象中所期望的那样。

## 怎么做...

1.  首先需要做的是创建`Date`对象:

    ```html
      var endOfTheWorld= new Date(1355270400000);
    ```

2.  然后，只需使用本地化的日期和时间表示:

    ```html
        document.writeln(endOfTheWorld.toLocaleDateString());
        document.writeln(endOfTheWorld.toLocaleTimeString());
    ```

3.  如果需要知道用户时区相对于世界协调时的小时偏移，可以使用以下代码:

    ```html
    var offset = - new Date().getTimezoneOffset()/60;
    ```

4.  该偏移变量表示从本地用户时区到世界协调时的小时数。这里的减号还原了日期的逻辑；这意味着差异将从日期到 UTC，而不是最初的从 UTC 到日期。

## 它是如何工作的…

我们通常可以做的是从服务器端返回毫秒表示，并将数字格式化为本地时区。假设我们的应用编程接口返回给我们的毫秒`1355270400000`实际上是 12.12.2012，也就是世界末日。

日期的创建如下:

```html
var endOfTheWorld= new Date(1355270400000);
```

在本地字符串中打印时，可用选项很少；其中之一是`toLocaleDateString`:

```html
   endOfTheWorld.toLocaleDateString()
```

此方法使用基础操作系统来获取格式约定。例如，在美国，格式是月/日/年，而在其他国家是日/月/年。对我们来说，世界末日是在“2012 年 12 月 12 日星期三”。您也可以使用适当的`getX`方法手动构建打印日期。

还有一种打印当地时间的方法叫做`toLocaleTimeString`，可以用在我们的世界末日日期上。因为这个方法也为我们使用操作系统的本地时间，它是 01:00:00，因为我们在 UTC+1 时区。对我们来说，这意味着我们多活一个小时；或者不是？

为了获取本地用户的偏移量，在`Date`对象中有一个名为`getTimezoneOffset()`的方法，它以分钟为单位返回从日期到 UTC 的时区偏移量。问题是，对于小时数没有这样的方法，此外，这是违背直觉的，因为我们通常想知道从世界协调时到给定日期的差异。

## 还有更多...

如果处理日期是您的应用程序需要的常见的事情，那么使用库是有意义的，例如**矩量法**T4([http://momentjs.com/](http://momentjs.com/))。

Moment.js 为国际化和更高级的日期操作提供了支持。例如，从当前日期中删除 10 天只需使用以下代码即可完成:

```html
moment().subtract('days', 10).calendar();
```

要获取今天开始的时间，请使用以下代码:

```html
moment().startOf('day').fromNow();
```

# 显示已经过去的动态时间

在每个主要网站上，在页面上的各种元素上显示时间戳的计数器非常常见。例如，这可能是“您 3 小时前打开了此页面”或“2 分钟前发表了评论”。这就是为什么，这个特征，除了名字“动态时间流逝”之外，也被称为“时间之前”。

## 做好准备

我们将使用一个名为**的 jQuery 插件，它是专门为此目的设计的，可以从[http://timeago.yarp.com/](http://timeago.yarp.com/)中检索。**

 **## 怎么做...

我们将创建一个简单的页面，通过执行以下步骤显示过去的时间:

1.  因为`timeago`是一个 jQuery 插件，我们首先需要包含 jQuery，然后添加`timeago`插件:

    ```html
     <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js">
     </script>
     <script src="jquery.timeago.js" type="text/javascript"></script>
    ```

2.  举个例子，添加以下 HTML:

    ```html
            <p> Debian was first announced <abbr class='timeago' title="1993-08-16T00:00:00Z">16 August 1993</abbr>
              </p>
              <p> You opened this page <span class='page-opened' /> </p>
               <p> This is done use the time element
                  <time datetime="2012-12-12 20:09-0700">8:09pm on December 12th, 2012</time>
              </p>
    ```

3.  这将使能够让我们对`timeago`插件提供的基本特性有一个大致的了解。之后，让我们添加以下 JavaScript:

    ```html
     $(document).ready(function() {
              jQuery.timeago.settings.allowFuture = true;
              var now= new Date();
              $(".timeago").timeago();
              $(".page-opened").text( $.timeago(now));
              $("time").timeago();
              //$("some-future-date") $.timeago(new Date(999999999999));
          });
    ```

就是这样。现在，您有了一个完整的工作时间示例，该示例将计算自给定日期以来的时间并对其进行更新，此外，随着用户在页面上花费更多时间，用`page-opened`选择的第二部分将自动更新。

## 它是如何工作的…

你可能想知道的第一件事是`abbr`和`time`标签。第一个，实际上，是一个“缩写”的表示，并可选地提供了它的完整描述。如果存在完整描述，`title`属性必须包含完整描述，而不包含其他内容。完整的描述通常作为工具提示出现在浏览器中，但这是一个值得注意的标准。为什么我们选择了`abbr`标签来显示时间？嗯，有一个名为`time`的新的 HTML5 时间元素，围绕它有一些争议，因为它被从规范中删除了，但后来又回来了。这个元素在语义上更加正确，另外，它以机器可读的格式表示日期，浏览器可以使用这种格式来启用类似“添加到日历”的功能。使用`abbr`元素的基本原理只支持旧版本的浏览器，但是这在久而久之变得越来越无关紧要了。目前，大多数现代桌面和手机浏览器都支持语义正确的`time`元素——甚至 IE 9+也支持它。

HTML 的其余部分由标准的、众所周知的标签和一些标记组成，例如为了以后选择那些元素而添加的不同的 CSS 类。

让我们来看看 JavaScript 首先，我们使用标准的 jQuery 文档就绪函数:

```html
$(document).ready(function() {
```

之后，我们将`allowFuture`的设置设置为`true`，以使`timeago`插件能够处理未来的日期，因为默认情况下没有设置:

```html
jQuery.timeago.settings.allowFuture = true;
```

如果`timeago`直接应用于所选的`abbr`或`time`元素，我们就不需要做其他任何事情，因为计算是自动完成的:

```html
 $(".timeago").timeago();
 $("time").timeago();
```

您还可以注意到，我们可以直接从 JavaScript 中获取给定日期的文本，并以我们认为合适的任何方式使用它:

```html
$(".page-opened").text( $.timeago(now));
```

## 还有更多...

在处理国际化和本地化的应用程序时，会想到一些问题。其中之一就是`timeago`自动处理的时区支持。我们唯一需要确定的是，我们的时间戳遵循**ISO 8601**T3([http://en.wikipedia.org/wiki/ISO_8601](http://en.wikipedia.org/wiki/ISO_8601))时间格式，并且具有完整的时区指示符([http://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators](http://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators))。另一个经常出现的问题是语言支持，但是我们主要涉及这个领域，因为有许多语言的插件本地化版本，您甚至可以创建自己的版本并将其贡献给社区。为此，您可以使用托管在[https://github.com/rmm5t/jquery-timeago/tree/master/locales](https://github.com/rmm5t/jquery-timeago/tree/master/locales)上的代码。

还有一些其他的实现执行类似的工作，例如，约翰·瑞西格在他的博客“T4”http://ejohn.org/blog/javascript-pretty-date/“T5”中提供的“T0”美好日期“T1”。

# 显示数学

说到技术写作，我们经常要在页面内部显示数学公式。过去，这是通过某种标记在服务器上创建一个图像来完成的，或者甚至通过外部程序手动创建一个图像。自从引入 MathML 后，这就不再需要了；因此，这为我们节省了时间，否则会花费在整理布局问题上，并且支持浏览器对公式显示的本地支持。在撰写本书时，并非所有主要浏览器都支持 MathML，尽管大多数功能的规范已经存在了几年。

![Displaying Math](img/9282OT_01_01.jpg)

## 做好准备

**数学标记语言** ( **MathML** ) 是应用程序描述公式的一种标准化方式，其目的不仅是为了实现对 Web 的集成，还用于其他应用程序。

有一个使用由 W3C 维护的 MathML 的软件列表；可以在[http://www.w3.org/Math/Software/](http://www.w3.org/Math/Software/)找到。工作组对规范的修订很少([http://www.w3.org/Math/](http://www.w3.org/Math/)，最新的是第 3 名([http://www.w3.org/TR/MathML3/](http://www.w3.org/TR/MathML3/))。

HTML5 增加了对在 HTML 中嵌入 MathML 文档的支持。

在这个食谱中，我们要做的是用 MathML 描述一个公式，如前面的圆周率所示，这里我们有一个数字 *π* 的不同表示的例子。

## 怎么做...

1.  我们将使用一个名为`MathJax`的库，它可以从作者的 CDN 中检索，也可以单独下载并包含在项目中。

    ```html
    <script type="text/javascript"
          src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
     </script>
    ```

2.  We can proceed by adding the MathML example as follows:

    ```html
    <math >
           <mrow>
               <mi>π</mi>
             <mo>=</mo>
             <mfrac>
                <mstyle scriptlevel="0">
                  <mn>3</mn>
                </mstyle>
                <mstyle scriptlevel="0">
                   <mrow>
                     <mn>7</mn>
                     <mo>+</mo>
                     <mfrac numalign="left">
                       <mstyle scriptlevel="0">
                         <msup><mn>1</mn></msup>
                       </mstyle>
                     </mfrac>
                   </mrow>
                </mstyle>
             </mfrac>
          </mrow>
        </math>
    ```

    元素含义的基础将在后面解释，但是你可以注意到这个例子在很少的嵌套层次之后变得非常大，并且很难阅读。这是因为 MathML 从来不打算手动创建，而是被一些应用程序用作格式。

3.  So what are the real simple options for us if we want to enable human-editable markup? Well, the simplest possible option is something called `ASCIIMath`; in order to enable it, we need to change the `config` parameter in the request:

    ```html
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"> </script>
    ```

    我们通常将该版本与所有可能的输入格式和呈现选项一起使用，但这样一来，我们会对 JavaScript 文件的大小产生问题。

    那么`ASCIIMath`的使用要简单多少呢？我们之前解释的表达式可以用一行来显示:

    ```html
     <p>
            `π = 3+1/(7+1/(15+1/(1+1/...)))`
     </p>
    ```

    ### 注

    请注意，表达式包含在```html字符中，该字符也称为庄重口音。

## 它是如何工作的…

没有`MathJax`库的原始 MathML 的使用在大多数浏览器上不起作用，但是有了库，输出会自动呈现为一个 SVG 或一个标准图像。在 MathML 示例中，我们使用 XML 嵌套来指定元素将被包含的位置，像`mrow`和`mfrac`这样的元素都是在 MathML 命名空间([http://www.w3.org/1998/Math/MathML](http://www.w3.org/1998/Math/MathML))中定义的，根元素叫做`math`。虽然概念很简单，但在实践中，如果没有外部软件的帮助，很难创建像这样的表达式。

MathML 的另一个缺点是，并非所有浏览器都完全支持它。

`ASCIIMath`则相反，使用起来非常简单，非常直观；基本上，任何包含在“```”或 Grave 强调字符中的内容都将被渲染为 HTML 和 CSS 或任何其他已配置的渲染方法。

## 还有更多...

`ASCIIMath`方法非常简单，在汗学院([【https://www.khanacademy.org/】](https://www.khanacademy.org/))和数学 StackExchange([【http://math.stackexchange.com/】](http://math.stackexchange.com/))等各大网站非常受欢迎。如果您有兴趣了解更多关于如何使用`ASCIIMath`的详细信息，您可以在[http://www1.chapman.edu/~jipsen/mathml/asciimath.html](http://www1.chapman.edu/~jipsen/mathml/asciimath.html)的官方网页上获得更多信息。使用`MathJax`还可以渲染其他标记格式语言，如 Tex 和 Latex。

### 注

Tex 是唐纳德·克努特(Donald Knuth)为了帮助他写他的名著而制作的排版格式。另一方面，Latex 是一种使用 tex 作为排版格式的文档标记。更多关于它们的信息可以在[http://en.wikipedia.org/wiki/TeX](http://en.wikipedia.org/wiki/TeX)和[http://www.latex-project.org/](http://www.latex-project.org/)找到。

# 创建无休止的滚动列表

没完没了的滚动列表被脸书和推特等社交网站所普及。他们的目标是制造整个可用内容已经被加载的假象。此外，利用这种技术，避免了由于用户试图找到下一页的按钮而导致的正常滚动的中断。

同时，我们也要避免不必要的带宽浪费；这意味着一次性加载整个数据集是不可行的。

解决方案是监控用户的滚动，并检测页面底部的方法。当用户足够接近底部时，我们可以通过将其附加到当前显示内容的末尾来自动加载下一页内容。

## 做好准备

您必须已经有一个逐页提供内容的服务。默认情况下，这个例子在没有这种服务的情况下工作，但是为了使它完全正常工作，需要一个实际的 HTTP 服务器，以便下一页的 Ajax 请求能够工作。

## 怎么做...

让我们编写 HTML 页面、CSS 样式和 JavaScript 代码。

1.  Create a file named `index.html` that will contain the full HTML, CSS, and JavaScript code of our example. We need to insert a DOCTYPE into our HTML document; otherwise, the browser will operate in "quirks mode" and the height measurement function `$(window).height()` will not work.

    ```html
    <!DOCTYPE HTML>
    ```

    我们将在页面中添加一个内容占位符元素:

    ```html
    <div id="content"></div>
    ```

2.  出于演示目的，我们将添加以下 CSS 代码来使页面可见。请随意跳过这个 CSS:

    ```html
    div.page {
       min-height: 1200px;
       width: 800px;
       background-color:#f1f1f1;
       margin:0.3em;
       font-size: 3em;
    }
    div.error {
       color:#f00;
    }
    ```

3.  Finally, we add the JavaScript code. First we load jQuery:

    ```html
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js">
    </script>
    ```

    然后我们可以添加我们的脚本:

    ```html
    <script type="text/javascript">
    (function() {
    ```

    我们的页面 getter 用一个空错误参数和一个包含页码作为内容的简单字符串(例如，`Page 1`)调用回调，但是它也可以执行一个 Ajax 请求。有关如何修改它以发出 Ajax 请求的更多信息，请参见下面的代码。

    这个功能被人为限制在 10 页的内容。在第十页之后，回调函数被调用，并出现一个错误，表明没有更多可用的页面:

    ```html
    var page = 1;
    function getPage(callback) {
       if (page <= 10)
           callback(null, 'Page ' + page);
       else
           callback("No more pages");
       page += 1;
    };
    ```

4.  我们使用`triggerPxFromBottom`来指定何时开始加载下一页。当只剩下`triggerPxFromBottom`像素需要滚动时，下一页的加载将开始。其值设置为`0`；这意味着用户必须到达当前可见页面的末尾才能触发加载过程:

    ```html
    var currentlyLoading = false;
    var triggerPxFromBottom = 0;
    ```

5.  `loadNext`将下一页追加到`#content` div 中。但是，如果回调函数被错误调用，它将在页面的最后一部分显示`No more content`。发生错误事件后，将不再加载页面。这意味着当`getPage`返回错误时，我们的代码将停止加载新页面。这是期望的行为:

    ```html
    function loadNext() {
       currentlyLoading = true;
       getPage(function(err, html) {
            if (err) {
                $("<div />")
                    .addClass('error')
                    .html("No more content")
                    .appendTo("#content");
            } else {
                $("<div />")
                    .addClass('page')
                    .html(html).appendTo("#content");
                currentlyLoading = false;
            }
          });
    }
    ```

6.  当页面以任何方式滚动时，都会调用此事件处理程序。它计算滚动的剩余像素数量。如果像素数足够小，并且代码当前没有加载页面，则调用页面加载函数:

    ```html
    $(window).on('scroll', function() {
        var remainingPx = $(document).height()
            - $(window).scrollTop()
            - $(window).height();
        if (remainingPx <= triggerPxFromBottom
            && !currentlyLoading)
            loadNext();
    });
    ```

7.  最后我们第一次调用`loadNext()`加载第一页:

    ```html
    loadNext();
    }());
    </script>
    ```

## 它是如何工作的...

浏览器的可见区域(也称为视口)有自己的尺寸，可以通过在`$(window)`对象上调用 jQuery 的`$.fn.height()`函数来获取。另一方面，`$(document).height()`为我们提供了整个页面内容的高度。最后`$(window).scrollTop()`给我们滚动偏移量。

使用这些函数，我们可以计算出要滚动的剩余像素。然后我们重新计算并在用户每次滚动页面时检查这个值。如果这个值足够小，我们称之为加载函数。同时，我们确保在当前加载过程完成之前停止加载新页面。(否则，用户的滚动操作可能会在等待内容加载时再加载几页。)

## 还有更多...

这里有一个可能的`getPage`函数的 Ajax 实现。该函数将 Ajax 请求发送到位于路径`/pages/<number>`的同一个域中的请求处理程序，以检索下一页的 HTML 内容:

```html
function getPage(cb) {
    $.get('/pages/' + page)
        .success(function(html) { cb(null, html); })
        .error(function() { cb("Error"); }
    page += 1;
}
```

要使这个版本工作，您需要在服务器端代码中实现请求处理程序。

您的服务器端代码可能会返回一个错误，如 404，以指示没有更多内容可用。因此，jQuery 永远不会调用我们的成功回调，我们的代码将停止加载新页面。

无休止的滚动列表食谱提供了很好的用户体验，但它有一个明显的缺点。我们必须确保在`contents`元素下面没有任何重要的页面内容。这意味着放置在底部的页面元素(通常是页脚链接和版权信息)可能变得不可访问。

# 创建可排序的分页表

我们在创建网站时遇到的最常见的任务之一是显示列表和表格。大多数技术集中于服务器端的排序、分页和数据呈现。我们的解决方案将完全在客户端，适合中小数据量。客户端解决方案的主要好处是速度；排序和切换页面几乎是瞬间完成的。

在这个配方中，我们将创建一个客户端的、可排序的分页表。

## 做好准备

我们假设服务在 JSON 对象中提供数据，该对象包含一个`data`属性，该属性是数组的数组:

```html
{data:[["object1col1", "object1col2"], ["object2col1", "object2col2"],  …]}
```

在我们的示例中，我们将显示我们附近的人员列表。表格中的每个人都会有自己的身份证号码、姓名、年龄、离我们的距离和交通方式。

我们将以公里为单位显示距离，并希望能够按姓氏对人员列表进行排序。

随着表格显示问题迅速超越最初的简单问题，我们不会构建自己的解决方案。相反，我们将使用 http://datatables.net/提供的优秀的 jQuery 数据表插件。

### 类型

**下载示例代码**

您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有 Packt 书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。

## 怎么做...

让我们编写 HTML 页面、CSS 样式和 JavaScript 代码。

1.  First, we're going to create an HTML page containing an empty table. We're also going to add some CSS to import a basic DataTables style for the table. The stylesheets are normally available with the DataTables distribution. Our `index.html` file is as follows:

    ```html
    <!DOCTYPE HTML>
    <html>
        <head>
            <title>Sortable paged table</title>
            <style type="text/css">
                @import "http://live.datatables.net/media/css/demo_page.css";
                @import "http://live.datatables.net/media/css/demo_table.css";
                #demo, #container {
                    width:700px;
                }
                #demo td {
                    padding: 0.2em 2em;
                }
                #demo_info {
                    width:690px;
                    height:auto;
                }
            </style>
        </head>
        <body>
            <div id="container">
                <table id="demo">
                    <thead>
                        <tr>
                            <th>Id</th><th>Name</th><th>Age</th><th>Distance</th><th>Transportation</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
            <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
            <script type="text/javascript" src="http://datatables.net/download/build/jquery.dataTables.min.js"></script>
            <script type="text/javascript" src="example.js"></script>
        </body>
    </html>
    ```

    该示例包括一个指向官方网站上托管的小型数据表的链接。

    数据表插件将`pager`和`info`元素追加到表格下方。因此，我们需要将我们的桌子包裹在一个`container`元素中。

2.  And the `example.js` file is as follows:

    ```html
    (function() {
        $.extend($.fn.dataTableExt.oSort, {
            "lastname-sort-pre": function (a) {
                return a.split(' ').reverse().join(' ');
            },
            "lastname-sort-asc": function(a, b) { return a < b ? -1 : a > b ? 1 : 0; },
            "lastname-sort-desc": function(a, b) { return a > b ? -1 : a < b ? 1 : 0; },
            "unitnumber-pre": function(a) { return new Number(a.split(' ')[0]); },
            "unitnumber-asc": function(a, b) { return a - b; },
            "unitnumber-desc": function(a, b) { return b - a; }
        } )
        var fetchData = function(callback) {
            var data = [
                [1,'Louis Garland', 12, 32, 'Walking'],
                [2,'Misty Lamar',32, 42, 'Bus'],
                [3,'Steve Ernest',32, 12, 'Cycling'],
                [4,'Marcia Reinhart',42, 180, 'Bus'],
                [5,'Lydia Rouse',35, 31, 'Driving'],
                [6,'Sean Kasten',80,42, 'Driving'],
                [7,'Patrick Sharkey',65,43, 'Cycling'],
                [8,'Becky Rashid',63, 51, 'Bus'],
                [9,'Michael Fort',34, 23, 'Walking'],
                [10,'Genevieve Blaine',55, 11, 'Walking'],
                [11,'Victoria Fry',58, 14, 'Walking'],
                [12,'Donald Mcgary',34, 15, 'Cycling'],
                [13,'Daniel Dreher',16, 23, 'Walking'],
                [14,'Valerie Santacruz',43, 35, 'Driving'],
                [15,'Jodi Bee',23, 13, 'Walking'],
                [16,'Jo Montana',14, 31, 'Cycling'],
                [17,'Stephanie Keegan',53, 24, 'Driving'],
                [18,'Philip Dewey',12, 29, 'Cycling'],
                [19,'Jack Clemons',11, 44, 'Walking'],
                [20,'Steve Serna',14, 60, 'Cycling']
            ];
            callback({data:data});
        };
        window.myTable = {};
        var table = window.myTable.table = $("#demo").dataTable({
            'bLengthChange': false, 'bFilter': false,
            'iDisplayLength': 10,
            'aoColumnDefs':[{
                aTargets: [3], // distance
                mRender: function(data) { return data + ' km'; },
                sType: 'unitnumber'
            }, {
                aTargets: [1],
                sType: 'lastname-sort'
            }]
        });
        var setData = window.myTable.setData = function(data) {
            table.fnClearTable();
            table.fnAddData(data);
            table.fnDraw();
        };

        fetchData(function(result) {
            window.myTable.data = result.data;
            setData(result.data);
        });

    }());
    ```

    示例中`fetchData`的实现提供了硬编码的示例数据。您可以很容易地用对您的服务的请求来替换它。`setData`函数是一个更改表格数据的方便函数——我们将使用同一个脚本，该脚本将调用该函数来为多个食谱设置自己的数据。最后，剩下的代码是特定于数据表的，将在下一节中解释。

## 它是如何工作的...

下图显示了结果表:

![How it works...](img/9282OT_01_02.jpg)

要初始化表格，我们使用`dataTable`初始化函数。我们可以向函数传递多个选项。例如，我们可以通过将`iDisplayLength`属性的值设置为`10`来指定每页需要 10 个项目。

因为我们将渲染**距离**列(第 3 列)而不仅仅是显示它，所以我们为目标列 3 的`aoColumnDefs`选项添加了一个项目，为该列设置自定义渲染功能。这是一个简单地将`km`字符串附加到我们的数字上的函数；但是我们也可以使用更复杂的函数(包括自定义日期格式、单位转换等)。

分页自动处理数据表——插件附加一个分页控件，提供对上一页/下一页的访问。排序也大多是自动进行的。然而，在我们的特定示例中，我们需要对**名称**列(按姓氏)进行特殊排序，即使它以“名字姓氏”的格式显示。为此，我们为该列指定了一个名为`lastname-sort`的自定义排序类型。我们还为名为`unitnumber`的**距离**列指定了一种特殊的排序类型。

数据表允许我们将自定义排序类型定义为插件。自定义排序器具有以下属性:

*   一种预处理函数，在将列值传递给分类器之前对其进行预处理
*   一个升序排序函数，根据传递的两个参数的值返回一个值:-1 表示第一个值较小，0 表示它们相等，1 表示第一个值较大
*   与升序排序功能类似的降序排序功能

这些属性允许我们按姓氏对**名称**列进行排序，以及按数字对**距离**列进行排序。

## 还有更多...

这里是对`fetchData`函数的简单 Ajax 替换，发送一个 Ajax 请求到位于路径`/people`的同一个域上的请求处理程序，以检索数组数据:

```html
function fetchData(cb) {
    $.get('/people/').success(cb);
}
```

请注意，这种解决方案对于大型数据集不是很有效。虽然现代客户端具有处理大量数据的性能，但带宽也是一个考虑因素。在使用此解决方案之前，应仔细考虑带宽要求和目标客户端(桌面或移动)。

# 创建多选过滤器

显示表格时，一个常见的任务是将表格中的数据过滤到满足特定标准的子集。多选表筛选器适用于具有有限数量值的列。例如，如果我们有一个包含某些人的数据的表，其中一列是此人使用的运输方法，则此列上使用的筛选器将是多选筛选器。用户应该能够选择一种或多种运输方法，表格视图将显示使用所选方法的所有人员。

## 做好准备

我们将假设我们使用的是之前配方中的代码和数据。我们使用 DataTables jQuery 插件在一个可排序、分页的表格中显示了一个人员列表及其交通方式。我们将从以前的配方中复制文件，然后添加到其中。

我们需要过滤的数据在`tableData`全局变量中已经有了；我们可以过滤这些数据，然后使用全局`tableSetData`功能显示过滤后的表格。

过滤器将在**运输**场工作。

## 怎么做...

让我们修改前面的代码，向表中添加多选过滤器:

1.  在上一个食谱的`index.html`文件中，在打开`<body>`标签后添加一个多选选择列表:

    ```html
    <select id="list" style="width:100px;"  multiple>
    </select>
    ```

2.  在结束`</body>`标记前添加`filter.js`的脚本元素:

    ```html
    <script type="text/javascript" src="filter.js"></script>
    ```

3.  We're also going to modify the `fetchData` call at the end of `example.js` to trigger a custom event notifying any observers that the data has been fetched and set:

    ```html
    $(function() {
        fetchData(function(result) {
            window.myTable.data = result.data;
            setData(result.data);
            $("#demo").trigger("table:data");
        });
    });
    ```

    代码被包装成在页面加载后执行，以便事件触发工作。在页面加载之前，不能触发任何事件。

4.  创建一个名为`filter.js`的文件，并添加以下代码:

    ```html
    (function() {
        function getUnique(data, column) {
            var unique = [];
            data.forEach(function(row) {
                if (unique.indexOf(row[column]) < 0) unique.push(row[column]); });
            return unique;
        }

        function choiceFilter(valueList, col) {
            return function filter(el) {
                return valueList.indexOf(el[col]) >= 0;
            }
        }
        $("#demo").on('table:data', function() {
            getUnique(window.myTable.data, 4).forEach(function(item) {
                $("<option />").attr('value', item).html(item).appendTo("#list");
            });
        })
        $("#list").change(function() {
            var filtered = window.myTable.data.filter(
                    choiceFilter($("#list").val(), 4));
            window.myTable.setData(filtered);
        });
    }());
    ```

## 它是如何工作的...

实现多选过滤器用户界面最简单的方法是使用多选选择元素。

当数据可用时，我们还需要填充元素。为此，我们在获取数据(无论是从我们的服务器还是其他地方)后触发新的自定义事件`table:data`。监听器从数据的**运输**列中提取唯一的值，并用这些值的选项填充选择列表。

当选择改变时，我们提取选定的值(作为一个数组)，并使用高阶函数`choiceFilter`创建一个新的过滤函数。高阶函数返回一个新的过滤函数。如果该行的第四列的值包含在指定的列表中，则该筛选函数接受一个表行参数并返回`true`。

过滤功能传递到`Array.filter`；它将此函数应用于每一行，并返回一个数组，该数组只包含过滤函数返回`true`的行。然后显示过滤后的数据，而不是原始数据。

# 创建范围过滤器

表也可以通过它们的数字列进行筛选。例如，给定一个表，其中每一行都是一个人，其中一列包含有关此人年龄的数据，我们可能需要通过指定年龄范围来筛选此表。为此，我们使用范围过滤器。

## 做好准备

我们将假设我们正在使用来自*的代码和数据创建一个可排序的分页表*配方。我们使用 DataTables jQuery 插件在一个可排序、分页的表格中显示了一个人的年龄列表。我们将从配方中复制文件，然后添加一些额外的过滤代码。

我们需要过滤的数据已经存在于`tableData`全局变量中；我们可以过滤这些数据，然后使用`tableSetData`全局功能显示过滤后的表格。

过滤器将在**年龄**字段工作。

## 怎么做...

让我们修改前面的代码，向表中添加范围过滤器:

1.  在上一个食谱的`index.html`文件中，在打开`<body>`标签后添加两个输入元素:

    ```html
     Age: <input id="range1" type="text">
     to <input id="range2" type="text"> <br>       
    ```

2.  在结束`</body>`标记前添加`filter.js`的脚本元素:

    ```html
    <script type="text/javascript" src="filter.js"></script>
    ```

3.  最后，我们创建我们的`filter.js`脚本:

    ```html
    (function() {
        function number(n, def) {
            if (n == '') return def;
            n = new Number(n);
            if (isNaN(n)) return def;
            return n;
        }
        function rangeFilter(start, end, col) {
            var start = number(start, -Infinity),
                end = number(end, Infinity);
            return function filter(el) {
                return start < el[col] && el[col] < end;
            }
        }
        $("#range1,#range2").on('change keyup', function() {
            var filtered = window.myTable.data.filter(
                rangeFilter($("#range1").val(), $("#range2").val(), 2));
            window.myTable.setData(filtered);
        });
    }());
    ```

## 它是如何工作的...

过滤数组数据最简单的方法就是使用 JavaScript 内置的`Array.filter`函数。这是一个高阶函数；它的第一个参数是一个函数，该函数接受一个行参数，如果要将该行添加到筛选数组中，则返回`true`，如果要将该行删除，则返回`false`。

为了提供这样的函数，我们创建了自己的高阶函数。它采用开始和结束范围以及指定的列。返回结果是一个过滤每一行的函数。

为了忽略输入中的空值或无效值，我们使用了 number 函数。如果输入字段为空或包含非数字数据，则提供默认值(`-Infinity`表示范围的开始，`+Infinity`表示范围的结束)。这也使我们能够进行单侧范围过滤。

`Array.filter`函数返回通过过滤器的所有元素的数组。我们在表中显示这个数组。

# 创建组合复杂过滤器

在显示表时，我们有时希望使用涉及多列的多个条件来过滤表元素。例如，给定一个包含姓名、年龄和交通方式等信息的人员表方法，我们可能只想查看使用公共汽车进行交通的 30 岁以上的人员。我们可能还想按姓名过滤人们。为此，我们必须同时对数据应用多个过滤器，例如年龄范围过滤器、多选过滤器和文本过滤器。最简单的方法是创建一个过滤器组合函数。

## 做好准备

我们将假设我们正在使用来自*的代码创建一个可排序的分页表*配方，并且我们将按照前面两个配方中描述的那样添加我们的过滤器。这一次我们将考虑过滤器的组合。

## 怎么做...

让我们修改前面的代码，向表中添加多个过滤器:

1.  我们将在打开`<body>`标签后向页面添加与过滤器相关的输入:

    ```html
    <select id="list" style="width:100px;"  multiple>
    </select>
    Age: <input id="range1" type="text">
    to <input id="range2" type="text">,
    Name: <input type="text" id="name"> <br>
    ```

2.  在结束`</body>`标记前添加`filter.js`脚本:

    ```html
    <script type="text/javascript" src="filter.js"></script>
    ```

3.  我们将修改`example.js`在页面加载后获取数据，并在显示数据后触发`table:data`事件:

    ```html
        $(function() {
            fetchData(function(data) {
                window.myTable.data = data;
                setData(data);
                $("#demo").trigger("table:data");
            });
        });
    ```

4.  然后我们可以通过组合前面两个食谱的代码来创建【T0:

    ```html
    (function() {
        function getUnique(data, column) {
            var unique = [];
            data.forEach(function(row) {
                if (unique.indexOf(row[column]) < 0)
                    unique.push(row[column]);
            });
            return unique;
        }
        function choiceFilter(valueList, col) {
            return function filter(el) {
                return valueList.indexOf(el[col]) >= 0;
            }
        }
        function number(n, def) {
            if (n == '') return def;
            n = new Number(n);
            if (isNaN(n)) return def;
            return n;
        }
        function rangeFilter(start, end, col) {
            var start = number(start, -Infinity),
                end = number(end, Infinity);
            return function filter(el) {
                return start < el[col] && el[col] < end;
            };
        }
        function textFilter(txt, col) {
            return function filter(el) {
                return el[col].indexOf(txt) >= 0;
            };
        }
        $("#demo").on('table:data', function() {
            getUnique(window.myTable.data, 4)
            .forEach(function(item) {
                $("<option />").attr('value', item)
                    .html(item).appendTo("#list");
            });
        });
        var filters = [null, null, null];
        $("#list").change(function() {
            filters[0] = choiceFilter($("#list").val(), 4);
            filterAndShow();
        });
        $("#range1,#range2").on('change keyup', function() {
            filters[1] = rangeFilter($("#range1").val(),
                $("#range2").val(), 2);
            filterAndShow();
        });
        $("#name").on('change keyup', function() {
            filters[2] = textFilter($("#name").val(), 1); filterAndShow();
        });
        function filterAndShow() {
            var filtered = window.myTable.data;
            filters.forEach(function(filter) {
                if (filter) filtered = filtered.filter(filter);
            });
            window.myTable.setData(filtered);
        };
    }());
    ```

## 它是如何工作的...

就像在之前的食谱中，我们使用`Array.filter`功能来过滤表格。这次我们连续应用多个过滤器。我们将所有的过滤函数存储在一个数组中。

只要输入有变化，我们就更新适当的过滤功能，并重新运行`filterAndShow()`来显示过滤后的数据。

## 还有更多...

数据表是一个高度灵活的表库，有许多选项和丰富的应用编程接口。更多信息和例子可以在官方网站[http://www.datatables.net/](http://www.datatables.net/)找到。

# 用 HTML 显示代码

有一种常见的需求是用 HTML 显示代码，甚至在 HTML 内部显示 HTML 代码，尤其是在技术文档或博客中。通过从一段格式化的代码中获取一个图像并将其作为页面的一部分，这种方式已经被做了太多次了。图片中的代码可能不会被搜索引擎发现。此外，它可以将我们限制在特定的页面布局甚至屏幕大小上，在当今的移动革命中，这不是一个选项。

## 做好准备

该配方的唯一要求是需要正确转义将要显示的数据；这意味着`<p>awesome </p>`需要翻译成`&lt;p&gt;awesome &lt;/p&gt;`。这可以在服务器端完成，也可以在保存之前进行转义。

## 怎么做...

1.  我们将使用 **谷歌代码修饰**，因为在发言的时候，这个库在任何 CDN 上都不完全可用；你可以从[http://code.google.com/p/google-code-prettify/](http://code.google.com/p/google-code-prettify/)买到。
2.  之后，我们可以在`<pre /> <code />`块中添加转义码:

    ```html
    <body onload="prettyPrint()">
         <div>
              <pre class="prettyprint">
                <code>
                  SELECT *
                  FROM Book
                  WHERE price &lt; 100.00
                  ORDER BY name;
                </code>
              </pre>
            </div>
    </body>
    ```

3.  这两个标签中的任何一个都必须包含`prettyprint` CSS 类。除此之外，我们还需要包含`onload="prettyPrint()"`属性。
4.  还可以从 JavaScript 中添加的其他事件侦听器中调用`prettyPrint`函数:

    ```html
    <script>
           window.addEventListener('load', function (e){
              prettyPrint();
           }, false);
           </script>
    ```

## 它是如何工作的…

`prettyprint`类自动选择所有用合适的 CSS 类标记的块，并自动检测使用的编程语言，然后进行高亮显示。

lexer 应该适用于大多数语言；在通用语言中，有针对特定语言的自定义脚本，例如，基于 lisp 的脚本。

## 还有更多…

因为`prettyprint`会自动检测源语言，如果想要得到更好的结果，我们还可以自己指定。例如，如果我们想要显示 XML，代码如下:

```html
<pre class="prettyprint"><code class="language-xml">...</code></pre>
```

大多数通用语言都有 CSS 类。

`prettyprint`是可用的较旧的脚本之一，很少有替代方案可以提供更多的定制选项和更好的 JavaScript APIs。

其中一些，如**SyntaxHighliger**([http://alexgorbatchev.com/SyntaxHighlighter/](http://alexgorbatchev.com/SyntaxHighlighter/))**彩虹**([http://craig.is/making/rainbows](http://craig.is/making/rainbows))和**highlight . js**([http://softwaremaniacs.org/soft/highlight/en/](http://softwaremaniacs.org/soft/highlight/en/))等，在大部分遗址上普遍存在。

# 渲染降价

Markdown 是一种流行的轻量级标记语言。这种语言类似于维基标记(在维基百科上使用)，强调简单。它的主要目的是使用户能够编写纯文本，并获得风格化、格式化的 HTML 输出。因此，它被热门网站使用，如 Reddit、Stack Overflow、GitHub 以及各种论坛，作为不太直观的 BBCode 格式的替代。

Markdown 是为我们的用户启用格式化文本输入的最快方法，而无需在页面中嵌入一个成熟的 HTML 编辑器。有多个库可以呈现减价；在这个食谱中，我们将使用简单的`markdown-js`脚本来实时渲染 markdown。

## 怎么做...

渲染降价很简单。一个最小的例子如下:

```html
<!DOCTYPE HTML>
<html>
    <head>
        <title>Render markdown</title>
        <style type="text/css">
            #markdown, #render { width: 48%; min-height:320px; }
            #markdown { float: left; }
            #render { float: right; }
        </style>
    </head>
    <body>
        <textarea id="markdown">
# Markdown example.
This is an example of markdown text. We can link to [Google](http://www.google.com)
or insert Google's logo:
![Google Logo](https://www.google.cimg/srpr/logo3w.png)

## Text formatting
We can use *emphasis* or **strong** text,
> insert a quote
etc.</textarea>
        <div id="render"></div>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script src="https://raw.github.com/spion/markdown-js/master/lib/markdown.js"></script>
        <script type="text/javascript">
            function rendermd(val) { $("#render").html(markdown.toHTML($("#markdown").val())); }
            $("#markdown").on('keyup', rendermd); $(rendermd);
        </script>
    </body>
</html>
```

## 它是如何工作的...

加载页面时，将`textarea`元素中的标记文本渲染到右侧的# `render`元素中。每次按键也会导致脚本更新呈现的元素。

## 还有更多...

从其官方网站[http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)了解更多关于降价形式的信息。

# 自动更新字段

如今，在一个部分或者是给定选择的结果或者显示给定图像或文本块的字段上自动更新是很常见的。这方面的一个例子是计算密码强度；例如，在谷歌上搜索“货币转换器”会出现一个框，您可以在其中进行美元和欧元之间的货币转换。当我们有两个或更多逻辑链接的字段时，或者当一个是另一个的结果形式时，以这种方式链接字段是有意义的。

为了演示这一点，我们将创建一个温度转换器，其中更新一个字段将导致另一个字段发生变化，因为这些值是相互关联的。

## 做好准备

对于这个食谱，我们只需要 jQuery 的基本知识和一个简单的公式来将温度在摄氏和华氏之间转换，反之亦然:

```html
Celsius = (Fahrenheit -32) x (5/9)
```

或者:

```html
Fahrenheit = Celsius  x(9/5) +32
```

## 怎么做...

1.  首先，我们将创建 HTML 部分，并创建两个自动更新的输入字段，并添加适当的标签:

    ```html
    <div>
    <label for='celsius'>C&deg;</label>
    <input id='celsius' type='text' /> =
    <label for='fahrenheit'>F&deg;</label>
    <input id='fahrenheit' type='text' />
    </div>
    ```

2.  之后，我们必须确保已经包含 jQuery:

    ```html
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"> </script>
    ```

3.  接下来，我们可以添加处理字段间绑定的脚本:

    ```html
    $(document).ready(function() {
      $('#celsius').keyup(function(data) {
      var celsius = new Number(data.currentTarget.value);
      var farenheit =celsius *(9/5) + 32;
        $('#farenheit').val(farenheit);
        });
       $('#farenheit').keyup(function(data) {
           var farenheit = new Number(data.currentTarget.value);
        var celsius =(farenheit-32)*(5/9);
         $('#celsius').val(celsius);
         });
            });
    ```

这将连接并自动向前和向后计算温度。

## 它是如何工作的…

我们先来看一下显示部分，没有什么具体的；这里我们使用简单的输入类型文本，并为每个字段添加适当的标签。此外，我们可以使用转义字符`&deg;`来显示程度字符。

如果我们看一下 jQuery `keyup`事件，我们可以看到它是在用户释放键盘上给定元素的一个键时执行的。此事件可以附加在任何 HTML 元素上，但它只有在元素处于焦点时才会起作用；所以在输入元素上使用它很有意义。由于`keyup`事件可以选择执行一个接受事件对象的函数，所以对于我们的情况，如下所示:

```html
$('#celsius').keyup(function(event) {
```

在`event`对象中，我们可以访问触发事件的元素并访问其值:

```html
event.currentTarget.value
```

之后，我们可以进行计算(*摄氏度*(9/5) + 32* )并将结果设置为以华氏度显示的另一个元素的值:

```html
$('#fahrenheit').val(fahrenheit);
```

因为我们希望绑定能够双向工作，所以我们可以对华氏温度的输入字段执行相同的操作:

```html
$('#farenheit').keyup(function(event) {
```

当然，你需要使用适当的公式(*华氏-32 度)*(5/9)* )来返回摄氏。

## 还有更多...

虽然这个食谱显示了简单使用 jQuery `event`对输入文本进行即时更新，但它也可以用于创建自动完成框或功能，例如谷歌的即时搜索。这里的想法是，我们可以也应该对各种 HTML 元素使用单向或双向绑定，尤其是当我们谈论派生数据或表示同一来源的数据时。**