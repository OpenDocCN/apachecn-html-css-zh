# 第十章。数据绑定框架

在本章中，我们将涵盖以下主题:

*   使用数据绑定创建基本角度视图
*   渲染列表和使用角度控制器
*   Angular 中的路由、过滤器和后端服务
*   使用 Angular 的客户端验证
*   使用角度指令制作图表组件
*   为 Meteor.js 构建应用程序
*   Meteor.js 中的反应式编程和数据
*   流星. js 中的实时 HTML 和用户特定数据
*   Meteor.js 中的安全机制

# 简介

在现代 web 应用程序中，大量代码逐渐从服务器转移到浏览器。因此，新的可能性和挑战正在出现。

一种可能性是即时自动数据绑定。客户端代码使我们能够将模型对象绑定到网页的各个部分。这意味着模型中的更改会自动并立即反映在显示该模型的视图元素中。

此外，代码组织也面临挑战。JavaScript 没有提供大型浏览器应用程序所需的足够的模块设施或代码组织模型。

在本章中，我们将介绍两个完整的框架，试图为这两个挑战提供解决方案。这些框架支持编写 web 应用程序的声明性数据绑定方法。同时，它们提供了模块化和组织工具，允许我们给代码一个清晰的结构——把它分成模型、视图、控制器或者视图模型和组件。

本章的前半部分将介绍 Angular——一个来自谷歌的框架，它提供客户端绑定，可以与任何服务器端堆栈(Rails、Node.js、Django 等)一起工作。它提供数据绑定+和组织设施。我们将在本章中执行以下操作:

*   使用数据绑定创建基本角度视图
*   使用角度控制器编写一个小列表编辑应用程序
*   为我们的应用程序添加验证
*   使用 Angular 路由器和过滤器创建一个简单的减价维基，并定义一个本地存储服务
*   使用指令创建显示图表的组件

后半部分将涵盖 Meteor——一个涵盖客户端和服务器端的完整框架和平台，还提供数据绑定和组织设施。Meteor 更像是构建 web 应用程序的一种真正不同的方式，我们将介绍它的以下一些基础知识:

*   构建您的应用程序流星风格
*   反应式编程的基础，以及如何在 Meteor 中处理数据
*   实时 HTML 和用户数据
*   安全性和认证

# 创建带有数据绑定的基本角度视图

Angular.js 允许我们使用自动数据绑定创建视图。这意味着我们可以指定其属性将绑定到元素属性或内容的模型对象。

自动化数据绑定简化编程。我们可以简单地改变模型对象，元素会自动更新，而不是添加事件监听器来观察我们元素内部的变化，然后通过添加类、改变属性或修改它们的内容来手动更新元素。

在本食谱中，我们将创建一个简单的货币转换器，使用固定的兑换率将美元转换为英镑。

## 做好准备

Angular 可通过 CDN 获得，因此无需下载。我们可以简单地把它加入我们的页面。

## 怎么做...

我们来写角度模板。

创建一个名为`index.html`的文件，该文件包含以下代码:

```
<!doctype html>
<html>
  <head>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.5/angular.min.js"></script>
  </head>
  <body>
    <div ng-app>
      <label>Amount in USD:</label>
      $<input type="text" ng-model="usdValue" placeholder="Enter USD amount">
      <hr>
      <label>Amount in GBP:</label><span ng-show="usdValue"> £ {{usdValue * 0.65}}</span>
    </div>
  </body>
</html>
```

## 它是如何工作的...

我们的网页不是用纯标准的 HTML 编写的。增加了许多新的属性，我们将在下面的段落中解释它们。

`ng-app`属性告诉 Angular 我们页面的哪个部分应该由它来管理。在我们的例子中，它是页面上唯一的`div`元素。我们也可以将这个标签放在 HTML 元素上，在这种情况下，整个页面将由 Angular 控制。

在`div`内部，我们有一个输入元素，其`ng-model`属性的值为`usdValue`。该属性使 Angular 向视图模型中添加一个名为`usdValue`的新属性。当内容更改时，此属性的值将自动更新为输入字段的值。该属性现在在视图中变得全局可用。

我们的`span`元素包含一个值为`usdValue`的`ng-show`属性。只有当`usdValue`具有非虚假值时，该属性才会显示`span`元素。“falsy”值的例子有空、空字符串、未定义和零——对于这些值，`span`元素将被隐藏。

最后，在跨度内，货币和表达式都放在双花括号内。由于该表达式依赖于`usdValue`变量的值，因此只要该值发生变化，`span`元素的内容就会自动更新。

最终的绑定将`span`元素与输入字段连接起来。每当输入字段改变时，模型`usdValue`变量自动更新。这又会导致`span`元素的可见性和内容自动更新。

## 还有更多...

`ng`属性在 Angular 中称为**属性指令** 。Angular 还允许您编写自己的属性指令。

### 注

`ng`属性不规范，遇到 HTML 验证器会投诉。要解决这个问题，您可以在它们前面加上`data`前缀。例如，`data-ng-model`将验证 fine，因为带有`data`前缀的自定义属性符合标准。

# 渲染列表和使用角度控制器

Angular 允许我们通过代码与视图交互，方法是让我们为视图设置一个控制器。控制器可以修改视图范围(模型)和调用其他操作，如后台服务。

在这个食谱中，我们将使用控制器来编写一个简单的待办事项列表。

## 怎么做...

我们开始吧。

1.  创建一个名为`index.html`的文件，该文件将显示任务列表、添加新任务的表单以及隐藏所有任务的按钮:

    ```
    <!doctype html>
    <html ng-app>
    <head>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.5/angular.min.js"></script>
    <script src="example.js"></script>
    </head>
    <body>
    <div ng-controller="TodoListController">
        <ul>
            <li ng-repeat="task in tasks" ng-show="task.shown">
            <input type="checkbox" ng-model="task.complete">  
            {{task.text}}
            </li>
        </ul>
        <form ng-submit="addTask()">
            <input type="text" placeholder="Write a task here..." ng-model="taskToAdd">
            <input type="submit" value="Add">
        </form>
        <button ng-click="hideComplete()">Hide complete</button>
    </div>
    </body>
    </html>
    ```

2.  创建一个名为`example.js`的文件，为我们的待办事项列表定义控制器:

    ```
    function TodoListController($scope) {
        $scope.tasks = [
            {text: "Write a todo list",
                complete: false, shown: true },
            {text: "Save it to the backend",
                complete: false, shown: true },
        ];
        $scope.addTask = function() {
            $scope.tasks.push({
                text: $scope.taskToAdd,
                complete: false,
                shown:true
            });
            $scope.taskToAdd = "";
        };
        $scope.hideComplete = function() {
            $scope.tasks.forEach(function(t) {
                if (t.complete)
                    t.shown = false;
            });
        };
    }
    ```

## 它是如何工作的...

在本例中，我们通过将`ng-app`属性设置为页面的根元素来声明 Angular 应用程序将成为我们的整个页面。

`div`元素代表我们的观点。该元素有一个`ng-controller`属性，指定视图的控制器。控制器是在窗口的全局范围内定义的函数。

在这个视图中，我们使用`ng-repeat`指令在列表元素中显示我们的任务列表。在这个列表中，有一个复选框表示任务完成状态和任务文本。

`tasks`变量属于视图的范围。我们希望该变量包含一系列任务，每个任务都有一个`text`描述、`complete`字段中的完成状态(绑定到任务的复选框)和一个`hidden`标志。

页面底部是用于向列表添加任务的表单。使用`ng-submit`属性，我们声明该表单在提交时应该执行`addTask()`功能。为此，我们希望该范围包含`addTask()`函数。该表单中的`text`字段绑定到`taskToAdd`变量。

最后，为了隐藏已完成的任务，我们在页面上添加了一个按钮。通过将其`ng-click`属性的值设置为`hideCompleted()`，我们告诉按钮在点击按钮时执行`hideCompleted()`功能。为此，我们期望视图的范围包含一个`hideCompleted()`函数。

我们如何将必要的函数和一些数据附加到视图中？

为此，我们可以使用`example.js`中定义的控制器功能。加载视图时会调用控制器函数。

在这个控制器中，没有 DOM 操作代码或 DOM 事件绑定。相反，我们有一个通过角度传递给控制器的`$scope`参数。此参数表示视图的可变范围。控制器只需将变量(如`tasks`数组)附加到该范围，该变量立即可供视图使用。

我们还将`addTask()`和`hideCompleted()`功能附加到范围中。里面的代码相当简单:

*   `addTask`用`taskToAdd`范围变量的内容从列表中推出一个新任务，然后将其值重置为空字符串。这将导致 Angular 更新任务列表，并重置绑定到`taskToAdd`的`input`字段的内容。
*   `hideCompleted`浏览任务列表，并为每个完成的任务设置`hidden`标志。因此，`ng-show`指令会自动将标记为`hidden`的任务隐藏起来。

## 还有更多...

这个例子突出了使用自动数据绑定框架时的主要区别。

如果没有自动数据绑定，我们需要手动将数据传递给模板呈现函数，然后为动作设置事件绑定。这些操作将手动从视图中提取数据，进行实际的模型操作，然后再次调用渲染函数。这是模板化的必要方法。

对于自动化数据绑定框架，在模板内部，我们指定它的部分如何与模型对象连接。然后，为了更新视图，我们只需操纵或更改模型，视图就会自动更新以反映这些更改。这是模板化的声明性方法。

这个方法唯一的缺点是我们的控制器必须在全局变量范围内声明。我们将在下一个食谱中展示如何避免这种情况。

# Angular 中的路由、过滤器和后端服务

为了更好地利用浏览器的后退按钮功能，以及允许用户复制和粘贴链接，Angular 提供了一个路由器模块。该路由器的功能类似于服务器端路由器，路径附加在哈希后的网址中，并带有查询字符串参数。它会将用户重定向到适当的控制器和视图对。

此外，为了在视图和服务器之间共享数据，我们需要为后端存储定义一个模块。我们将使用 HTML5 `localStorage`来代替——结果代码将非常相似。

在这个食谱中，我们将构建一个简单的基于减价的 wiki，将页面存储在本地存储中。Angular 也支持滤波器，所以我们要写一个降价滤波器模块。

## 怎么做...

让我们写下我们的 Angular 应用:

1.  创建一个名为`index.html`的文件，该文件将托管 Angular 应用程序。它包括所有必要的脚本，并设置了`div`元素，该元素将托管视图:

    ```
    <!doctype html>
    <html ng-app="wiki">
    <head>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://raw.github.com/spion/markdown-js/master/lib/markdown.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.5/angular.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.5/angular-sanitize.min.js"></script>
    <script src="edit-controller.js"></script>
    <script src="view-controller.js"></script>
    <script src="storage.js"></script>
    <script src="markdown-filter.js"></script>
    <script src="app.js"></script>
    </head>
    <body>
    <div id="main" ng-view>
    </div>
    </body>
    </html>
    ```

2.  要显示降价，我们需要一个`markdown`过滤器。在名为`markdown-filter.js` :

    ```
    angular.module('markdown', []).filter('markdown', function() {
        return function(input) {
            return input ? markdown.toHTML(input) : ''
        };
    });
    ```

    的角度模块内定义角度过滤器
3.  为了存储维基页面，我们需要一个存储模块。在`storage.js` :

    ```
    angular.module('storage', []).factory('Storage', function() {
        var self = {};
        self.get = function get(id) {
            var page = localStorage["page-"+id];
            if (page) return JSON.parse(page);
            else return {id: id, text: null};
        };
        self.save = function save(page) {
            var stringified = JSON.stringify(page);
            localStorage["page-"+page.id] = stringified;
        };
        return self;
    });
    ```

    中定义一个在名为`storage`的模块内创建`Storage`对象的工厂
4.  现在让我们在`app.js`中定义我们的维基应用。除了`storage`和`markdown`模块，我们还将使用`ngSanitize`来显示不安全的 HTML。我们将定义两条路线，一条用于编辑，另一条用于查看页面:

    ```
    var wwwApp = angular.module('wiki',
        ['storage', 'markdown', 'ngSanitize'])
        .config(['$routeProvider', '$locationProvider',
            function($routeProvider, $locationProvider) {
                $locationProvider
                    .html5Mode(true).hashPrefix('!');
                $routeProvider.when('/edit/:page', {
                    templateUrl: '../edit.html',
                    controller: EditController
                })
                .when('/:page', {
                    templateUrl: 'view.html',
                    controller: ViewController
                })
            }]);
    ```

5.  让我们在`view.html`中定义我们的查看模板。除了显示文章外，还应该提供编辑链接以及返回主页面的链接:

    ```
    <div ng-show="page.text"
        ng-bind-html-unsafe="page.text | markdown">
    </div>
    <br>
    <a href="edit/{{page.id}}">Edit this page</a> -
    <a href="./">Go to the start page</a>
    ```

6.  现在我们来定义`view-controller.js`里面的查看控制器。它应该从存储中加载显示的文章。

    ```
    function ViewController($scope, $routeParams, Storage) {
        $scope.page = Storage.get($routeParams.page || 'index');
    }
    ```

7.  在`edit.html`里面添加编辑模板:

    ```
    <div class="edit">
        <div class="left">        
            <textarea ng-model="page.text"></textarea>
        </div>
        <div class="right"
            ng-bind-html-unsafe="page.text | markdown">
        </div>
    </div>
    <a ng-click="savePage()"
        href="../{{page.id}}">Save</a>
    ```

8.  然后在`edit-controller.js`里面定义编辑控制器；应该是从`storage`加载页面，定义`savePage()`方法保存页面:

    ```
    function EditController($scope, Storage, $routeParams) {
        $scope.page = Storage.get($routeParams.page);
        $scope.savePage = function() {
            Storage.save({id: $scope.page.id, text: $scope.page.text});
        };
    }
    ```

9.  最后，让我们通过在`style.css` :

    ```
    * { box-sizing: border-box; }
    #main { padding: 0em 1em; }
    .edit .left {
        float:left;
        width: 50%;
        padding-right: 1em; }
    .edit .right {
        float: right;
        width: 50%;
        padding-left: 1em; }
    .edit textarea {
        width: 100%;
        min-height: 24em;}
    .edit input {
        width: 70%; }
    .edit {
        float:left;
        width: 100%;
        clear:both; }
    ```

    中添加一些 CSS 来设置样式
10.  要运行该应用程序，请为该目录运行一个 HTTP 服务器。假设你已经安装了 Node.js(见[附录 A](13.html "Appendix A. Installing Node.js and Using npm") ，*安装 Node.js 并使用 npm* ，安装`http-server`，然后在`app`目录下运行:

    ```
    npm install -g http-server
    http-server

    ```

11.  将浏览器指向`http://localhost:8080/`查看结果。

## 它是如何工作的...

之前的配方定义了一个简单的单控制器应用程序，因此，它并不真正需要路由和模块化。另一方面，这个配方实现了一个更复杂的应用程序，具有多个视图和控制器，以及存储和过滤模块。

我们的 Angular 应用程序从`app.js`开始——定义为一个名为`wiki`的模块，与我们的`index.html`文件中的`html`标签的`ng-app`属性相同。它包含加载我们定制的`markdown`和`storage`模块并设置控制器和视图的主粘合代码。

为了配置我们的应用，我们加载了两个对象:`$locationProvider`和`$routeProvider`:

```
['$routeProvider', '$locationProvider',  function($routeProvider, $locationProvider) { … }]
```

前面的加载语法是数组语法，其中我们定义了要作为数组元素加载的模块名称；然后我们定义函数，将这些模块作为数组末尾的参数，并执行使用它们的代码。

我们使用`locationProvider`模块来启用`html5mode`，其中每个网址看起来好像是作为一个单独的页面加载的，不包含哈希。该模式需要 HTML5 浏览器历史 API。作为备用方案，我们定义了一个前缀`!`，在哈希之后和网址之前使用。

为了定义我们的路线，我们使用`routeProvider`。我们声明任何`/edit/:page`网址将由`EditController`处理，并使用`edit.html`模板显示。网址的`:page`部分是一个`URL`参数，匹配任何文本——它将在控制器中被访问。我们还定义了一个用于查看页面的`/:page`路线，由`ViewController`处理，使用的是`view.html`模板。

`view`模板包含一个`div`元素，该元素仅在定义了页面文本时显示。我们这样做的方式是使用`ng-bind-html-unsafe`指令。这个指令允许我们将一个表达式绑定到元素上，这个表达式的计算结果是任意的 HTML，这正是我们需要的`markdown`过滤器。

要使用过滤器，我们使用管道字符:

```
ng-bind-html-unsafe="page.text | markdown"
```

该页面的编辑链接位于链接的底部，将我们带到该页面的编辑视图。同样，在编辑页面上，我们将标记文本和生成的 HTML 绑定到不同的元素。因此，更改文本区域会导致对显示的 HTML 进行即时更新，从而为我们提供生成页面的实时预览。

视图和编辑控制器都相当简单:第一个控制器从存储器中加载文章，而第二个控制器定义一个`save()`函数，将文章保存回存储器。

我们的控制器新增的是它们接收的额外参数:

```
function EditController($scope, Storage, $routeParams) ...
function ViewController($scope, $routeParams, Storage) ...
```

这些参数使 Angular 通过将请求的对象作为参数传递给控制器来注入它们。在这种情况下，请求`Storage`对象(在`storage`模块中定义)，并且请求`$routeParams`内置对象。参数的顺序不重要，重要的是它们的名字。我们可以通过使用数组语法来避免这种行为:

```
var EditController = ['$scope', 'Storage', '$routeParams',  function($scope, Storage, $routeParams) { … }]
```

使用前面的语法，Angular 将按照数组指定的顺序注入对象。

定义过滤器很简单。在`markdown-filter.js`里面，我们定义了一个新的模块，叫做`markdown`。然后我们宣布该模块将提供一个名为`markdown`的过滤器。为了定义过滤器，我们定义了一个构造并返回过滤器的函数。返回的过滤器应该是一个接受单个输入参数并返回过滤后的输出的函数。我们的`markdown`过滤器只是在输入参数上调用`markdown.toHTML`。

`storage`对象在`storage.js`中以类似的方式定义。这里我们定义了一个新的模块，叫做`storage`。在本模块中，我们为`Storage`对象定义了一个构造函数，它提供了`get()`和`save()`功能。然后我们可以通过添加一个名为`Storage`的参数将我们的存储注入到任何控制器中。在 Angular 中，这些由工厂创建的可注射对象通常被称为**服务**。

## 还有更多…

使用`ng-bind-html-unsafe`是不安全的，可能会让攻击者编写一个页面，注入窃取个人信息或代表用户执行其他操作的任意脚本。为了避免这种情况，应该尽可能使用来自`ngSanitize`模块的`$sanitize`服务来处理 HTML。

# 使用 Angular 的客户端验证

Angular 自行扩展了新的 HTML5 验证属性，并允许用户向模板添加错误条件。借助 Angular 的这些功能，我们可以在表单中添加自定义错误消息和样式。

在这个食谱中，我们将在 Angular 中创建一个简单的用户注册表单，然后我们将在表单中添加一些验证规则。

## 怎么做...

让我们执行以下步骤:

创建一个名为`index.html`的文件，其中包含登记表和验证规则:

```
<!doctype html>
<html ng-app>
<head>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.5/angular.min.js"></script>
<style type="text/css">
    form { display: block; width: 550px; margin: auto; }
    input[type="submit"] { margin-left: 215px; }
    span.err { color: #f00; }
    label { width: 120px; display:inline-block; text-align: right; }
</style>
</head>
<body>
<div>
    <form name="register">
        <p>
        <label for="user">User:</label>
        <input type="text" name="name" ng-model="user.name"
            required  ng-minlength="5" ng-maxlength="32">
        <span ng-show="register.name.$error.required" class="err">
            Required</span>
        <span ng-show="register.name.$error.minlength" class="err">
            Minimum 5 characters</span>
        <span ng-show="register.name.$error.maxlength" class="err">
            Maximum 32 characters</span>
        </p>

        <p>
        <label for="pass">Pass:</label>
        <input type="password" name="pass" ng-model="user.pass"
            required  ng-minlength="6" ng-maxlength="32"
            ng-pattern="/^(?=.*[a-zA-Z])(?=.*[0-9])/">
        <span ng-show="register.pass.$error.required" class="err">
            Required</span>
        <span ng-show="register.pass.$error.minlength" class="err">
            Minimum 6 characters</span>
        <span ng-show="register.pass.$error.maxlength" class="err">
            Maximum 32 characters</span>
        <span ng-show="register.pass.$error.pattern" class="err">
            Must have both letters and numbers</span>
        </p>

        <p>
        <label for="age">Age:</label>
        <input type="number" name="age" ng-model="user.age"
            required min="13">
        <span ng-show="register.age.$error.required" class="err">
            Required</span>
        <span ng-show="register.age.$error.min" class="err">
            Must be 13 or older</span>
        </p>

        <p>
        <label for="email">Email:</label>
        <input type="email" name="email" ng-model="user.email"
            required>
        <span ng-show="register.email.$error.required" class="err">
            Required</span>
        <span ng-show="register.email.$error.email" class="err">
            Not a valid email address</span>
        </p>

        <p>
        <label for="url">Website:</label>
        <input type="url" name="website" ng-model="user.website"
            required>
        <span ng-show="register.website.$error.required" class="err">
            Required</span>  
        <span ng-show="register.website.$error.url" class="err">
            Not a valid website URL</span>
        </p>

        <input type="submit" value="Register" ng-disabled="register.$invalid">
    </form>
</div>
</body>
</html>
```

## 它是如何工作的...

Angular 通过用新添加的规则和属性扩展内置的 HTML5 验证规则来增加验证支持。让我们看看我们在表单中使用的那些:

我们的第一个字段是用户的用户名。除了 HTML5 `required`属性，我们还使用了两个验证指令:`ng-minlength`和`ng-maxlength`来指定最小和最大用户名长度。

Angular 增加的另一项功能是能够从其他单独的元素访问模板中的当前验证状态。错误范围显示验证错误。然而，只有当相应的验证错误发生时，才会显示它们。

要访问验证状态，我们可以使用以下格式:

```
<formName>.<fieldName>.$error.<checkName>
```

例如，要检查`register`表单中的`user`字段是否有`minlength`错误，我们可以使用以下属性:

```
register.user.$error.minlength
```

同样，我们可以使用一个`number`输入字段，用`min`和`max`属性检查数字是否在指定范围内。适当的`$error`字段分别有名称`$error.min`和`$error.max`。

对于电子邮件和网址输入，我们可以分别使用`$error.email`和`$error.url`字段。

最后，在表单的末尾，在我们的提交按钮中，如果其中一个字段有错误，我们使用`ng-disable`来禁用表单的提交。为了检查错误，我们可以简单地使用下面的语法:

```
<formName>.$invalid
```

在我们的情况下是这样的:

```
register.$invalid
```

如果任何字段中的任何验证规则产生错误，上述代码将返回`true`。

# 用角度指令制作图表组件

角度指令允许我们以一种非常强大的方式扩展 HTML 语法——通过添加新的属性和元素。这允许我们创建感觉是本地的组件:从日期和时间选择器到数据网格、图表和可视化。

这样的组件就可以被重用，而无需向我们的控制器添加初始化代码。我们只需告诉组件它应该绑定到什么模型，它就会自动更新其外观，以反映模型中的任何变化。

在本食谱中，我们将使用 Flot 绘制图表来制作图表指令。在此过程中，我们将了解 Angular 指令的许多强大功能。

## 做好准备

我们需要从[http://www.flotcharts.org/](http://www.flotcharts.org/)下载 Flot，并将 ZIP 存档提取到我们的食谱目录中，创建一个名为`flot`的子目录。

## 怎么做...

让我们写代码。

1.  创建名为`index.html`的文件。它将包括所有必要的脚本和使用我们的`chart`指令显示图表的视图。

    ```
    <!doctype html>
    <html ng-app="chart">
    <head>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.5/angular.min.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"> </script>
    <script src="flot/jquery.flot.js"></script>
    <script src="random.js"></script>
    <script src="chart.js"></script>
    <script src="controller.js"></script>
    <script src="app.js"></script>
    </head>
    <body>
    <div id="main" ng-controller="Controller">
        <chart style="display:block; width:800px; height:200px;"
            data="chart.data" options="chart.options">
    </div>
    </body>
    </html>
    ```

2.  要实现控制器，创建一个名为`controller.js`的文件——它将设置图表数据和选项。此外，它将每 50 毫秒用随机生成的点更新图表数据:

    ```
    function Controller($scope, $timeout) {
        $scope.chart = {
            data: [getRandomData()],
            options: {lines: {fill:true}}
        };
        setInterval(function updateData(delay) {
            $scope.$apply(function() {
                $scope.chart.data[0] = getRandomData();
            });
        }, 50);
    }
    ```

3.  要创建随机数据生成函数，创建一个名为`random.js`的文件，并添加以下代码:

    ```
    (function() {
        var data = [], maximum = 200;
        window.getRandomData = function getRandomData() {
            if (data.length)
                data = data.slice(1);
            while (data.length < maximum) {
                var previous = data.length ? data[data.length - 1] : 50;
                var y = previous + Math.random() * 10 - 5;
                data.push(y < 0 ? 0 : y > 100 ? 100 : y);
            }
            var res = [];
            for (var i = 0; i < data.length; ++i)
            res.push([i, data[i]])
            return res;
        }
    }());
    ```

4.  最后，将`chart`指令写入名为`chart.js` :

    ```
    angular.module('chart', []).directive('chart', function() {
        var dir = {};
        dir.restrict = 'E';
        dir.scope = {
            data: '&',
            options: '&'
        }
        dir.link = function(scope, el, attrs) {
            console.log(scope)
            var data = scope.data(),
                opts = scope.options(),
                flot = $.plot(el, data, opts);
            function updateOnData(newdata) {
                data = newdata;
                flot.setData(data);
                flot.setupGrid();
                flot.draw();
            };
            function updateOnOptions(options) {
                opts = options;
                flot = $.plot(el, data, opts);
            }

            scope.$watch('data()', updateOnData, {objectEquality: true});
            scope.$watch('options()', updateOnOptions, {objectEquality: true});
        }
        return dir;
    });
    ```

    的文件中

## 它是如何工作的...

这是一个相当普通的 Angular 应用程序，有一个带控制器的`div`元素。控制器在作用域中设置一个新对象。

控制器中的`setInterval`呼叫值得特别一提。我们试图在 Angular 从浏览器事件循环调用的常规函数之外修改一个范围对象。

### 类型

浏览器事件循环是一种等待和调度事件的编程构造。此类事件包括鼠标和键盘事件、`setTimeout`和`setInterval`设置的超时和间隔、脚本加载、图像加载或`xmlhttprequest`完成等。

Angular 在事件循环中注册的所有函数都封装在一个范围应用程序包装器中，该包装器通知范围它应该在执行后检查自己的更新。但是 Angular 之外的功能，比如`setTimeout`、`setInterval`，不做这种包裹，我们必须在 angular `$scope`对象(`$scope.$apply`)上使用`$apply`功能手动完成。

`chart`指令工厂在`chart`模块中定义。工厂创建指令，它是一个对象。让我们解释一下这个对象的属性:

*   `directive.restrict`:这将指令限制在某些类型。`E`表示指令仅限于元素。此外，还有三种可能:属性的`A`，CSS 类的`C`，特殊注释形式的`M`。
*   `directive.scope`:这允许我们配置定义指令的本地(隔离)范围的属性。对于不同类型的进口产品，我们可以使用以下不同的特殊字符:
    *   `&`字符表示将属性解释为表达式。它允许我们设置任意的单向绑定，并观察表达式的更新。要获取表达式值，我们需要调用导入的范围变量作为函数。
    *   `=`字符表示将属性解释为另一个范围的变量。这允许我们设置双向数据绑定。
    *   `@`字符表示将属性解释为字符串值。返回属性的字符串值。
*   `directive.link`:这个被调用来链接指令和新元素。对指令的每个实例(在我们的例子中，每个元素)都执行一次。它允许我们定义为呈现新图表而执行的代码，以及设置范围监视器来更新图表。用`scope`、`element`和`attribute`参数来调用。

在我们的示例中，`chart`指令仅限于元素。因为我们不需要双向数据绑定，所以使用`&`，我们将`data`和`options`属性都解释为表达式。这允许使用过滤器和其他操作，这是非常有用的，并且不是由`=`解释提供的。

在 `link`功能中，我们渲染初始图表。因为我们将这两个属性解释为表达式，所以我们需要调用它们作为函数来获取值。

### 类型

与角度控制器不同，我们的`link`函数的参数顺序很重要，并且总是:`scope`、`element`和`attributes`。这是因为它们没有被角度依赖注入系统处理。

为表达式设置观察器的方式也略有不同——观察器字符串是一个函数调用。

`data`和`options`都是复杂的对象，可以在不改变对象本身的情况下修改其内容。因此，我们需要将第三个参数传递给`watch`函数，该函数指定在比较关注表达式的值时应使用对象相等。默认情况下是检查对象引用，它对我们的图表不起作用。

当`data`或`options`被修改时，我们重新渲染我们的图表。我们的`chart`元素现在是完全动态的，这可以从每 50 毫秒更新一次数据点的例子中看出。这些更新立即反映在图表上。

## 还有更多…

除了 `directive.link`属性，还有`directive.compile`。即使有多个实例，每个指令也只调用一次。它允许我们在元素中转换模板，并将内容包含在指令中。更多的属性也是可用的——详细的文档可以在官方网站[http://angularjs.org/](http://angularjs.org/)的角度指南中找到。

# 为流星. js 构建应用程序

Meteor.js 做出的第一个承诺是它是构建 web 应用程序的更快方式。今天使用的大多数网络框架在同一个机架上有一个网络服务器和一个数据库，并将呈现的 HTML 发送到浏览器。它们都使用基于标准请求和响应的开发。

如今，我们也有很多智能客户端:在浏览器中运行的 JavaScript 驱动的应用，或者安卓或 iOS 中的原生客户端。所有这些都与云相连；它们都以这样或那样的方式与谷歌、脸书、推特或亚马逊结盟。

Meteor 提供了一种围绕 **【智能包】**构建代码的新方法，这些代码模块可以在客户端或服务器端执行，甚至可以同时在客户端和服务器端执行。开发人员可以选择他们将在应用程序中使用的智能包。流星将产生一个束，准备成为云的一部分。在这个食谱中，我们将构建一个非常基本的 Meteor 应用程序，以便了解 Meteor 做几乎所有事情的方式。关于流星，有一点需要注意的是，它还在工作中，应该这样对待。

## 做好准备

在撰写本文时，官方支持的平台是 Mac OS 和 GNU/Linux。在[http://win.meteor.com/](http://win.meteor.com/)有一个作为 MSI 安装包的视窗预览安装，它应该有相同的功能，但是有更多的错误和不舒服的外壳。官方对 Windows 的支持是未来规划的，所以这应该不是什么大问题。

对于 Linux 和 Mac，安装使用命令行完成:

```
curl https://install.meteor.com | /bin/sh

```

该命令将运行并将 Meteor 安装到您的机器上，但它只适用于基于 Debian 和 RedHat 的发行版。如果你的操作系统不在这些类别中，没有必要担心，可能有一个流星软件包已经是你的发行库的一部分，但它可能落后几个版本。

Meteor 建立在 Node.js 之上，使用自己的系统来管理包。默认情况下，它还使用 MongoDB 作为数据库。

## 怎么做...

1.  After having Meteor installed, we can start by creating an application titled `simple`:

    ```
    meteor create simple

    ```

    这将创建一个名为`simple`的文件夹，其中我们应该有名为`simple.html`、`simple.js`、`simple.css`的文件，以及名为`.meteor`的子文件夹。

2.  要启动应用程序，只需在文件夹中键入【T0:

    ```
    meteor
    [[[[[ /the-example-location/simple ]]]]]
    Running on: http://localhost:3000/

    ```

## 它是如何工作的...

在深入挖掘代码之前，我们先来看看 Meteor 背后的一些思路。创作者用他们的七个原则来推广这个框架，这七个原则基本上符合你的期望:

> 流星的七个原则
> 
> 电线上的数据。不要通过网络发送 HTML。发送数据，让客户端决定如何呈现。
> 
> 一种语言。用 JavaScript 编写界面的客户机和服务器部分。
> 
> 数据库无处不在。使用相同的透明应用编程接口从客户端或服务器访问您的数据库。
> 
> 延迟补偿。在客户端，使用预取和模型模拟，让它看起来像是与数据库的零延迟连接。
> 
> 全堆反应性。将实时设为默认值。从数据库到模板的所有层都应该提供事件驱动的接口。
> 
> 拥抱生态系统。Meteor 是开源的，它集成而不是取代了现有的开源工具和框架。
> 
> 简单等于生产力。让事情看起来简单的最好方法就是让它变得简单。通过干净、经典漂亮的 API 实现这一点。

这些原则中的一些被夸大了，但尽管如此，流星无疑是构建网络应用程序的一种新方法。

让我们回到生成的代码，从`simple.js`开始:

```
if (Meteor.isClient) {
  Template.hello.greeting = function () {
    return "Welcome to simple.";
  };

  Template.hello.events({
    'click input' : function () {
      // template data, if any, is available in 'this'
      if (typeof console !== 'undefined'){
        console.log("You pressed the button");
      }
    }
  });
}
if (Meteor.isServer) {
  Meteor.startup(function () {
    // code to run on server at startup
    });
}
```

提供了变量`Meteor.isServer`和`Meteor.isClient`，这样我们就可以根据代码是在客户端还是在服务器上运行来更改行为。

如果我们在`simple.js`的`server`部分添加`console.log("I'm running")`，我们可以注意到服务器控制台正在重新加载服务器:

```
 I'm running

```

这基本上就是我们在 Meteor 中创建服务器代码的方式，在这里我们可以选择是想要一个单独的文件还是一大堆其他文件。Meteor 收集我们项目树中的所有文件，除了`server`和`public`子目录。这缩小了他们，他们得到了每个客户的服务。

与 Node.js 创建异步回调的方式不同，Meteor 在每个请求中使用一个线程，这意味着它应该会产生一些更容易维护的代码。

如果我们看一下`simple.html`，我们有一个简单的模板，它使用的客户端代码是`simple.js`的一部分，其中使用了适当的`Template.hello.events`事件和`Template.hello.greeting`中的数据:

```
<head>
  <title>simple</title>
</head>
<body>
  {{> hello}}
</body>
<template name="hello">
  <h1>Hello World!</h1>
  {{greeting}}
  <input type="button" value="Click" />
</template>
```

我们现在还不会讨论模板背后的细节，但是这个基本的例子应该很简单。如果我们在`http://localhost:3000`打开已经启动的应用程序上的浏览器，我们可以看到数据被加载到模板中。当我们点击按钮时，会调用一个`console.log("You pressed the button")`功能，消息应该会显示在控制台上。请注意，这应该是浏览器的控制台，而不是服务器控制台，因为该部分设置为在客户端运行。

处理敏感数据(如令牌或密码)的代码部分应该只是服务器的一部分，这可以通过将代码放在名为`server`的文件夹中轻松完成。当服务器处于生产模式时，CSS 文件和 JavaScript 被提供给客户端，打包和捆绑。在开发过程中，它们被单独发送，以简化调试。

您可能已经注意到，提供给客户端的 HTML 文件有点不同，比我们应用程序文件夹中的文件大。这是因为 Meteor 会扫描 HTML 文件中的顶级元素`<head>`、 `<body>`和`<template>`。`template`部分被转换成可以从`Template.*`命名空间调用的 JavaScript 函数。至于`<head>`和`<body>`元素，它们单独连接在一起，附加的部分，比如 DOCTYPE 和 CSS，会自动包含在内。

## 还有更多...

如果我们需要 Meteor 来提供一些静态文件，例如`icons`、`images`、`pdf's`，或者例如`robots.txt`，我们会为此使用`public`目录。应用程序的根是`public`文件夹的根；例如，如果我们有一个名为`meme.png`的文件，它将通过`http://localhost:3000/meme.png`访问。

下面是一个简单的目录结构:

```
`-- simple
    |-- public
    |   `-- meme.png
    |-- simple.css
    |-- simple.html
    `-- simple.js
```

# meteor . js 中的反应式编程和数据

Meteor 使用 NoSQL 面向文档的存储，默认情况下，它带有 Mongo DB。这个名字来自“巨大”这个词，意思是非常大。该数据库是 NoSQL 数据库家族的一部分，也就是说，它不像传统的关系数据库那样存储数据。Mongo DB 以类似 JSON 的文档格式保存日期，使得与基于 JavaScript 的框架的集成变得更加容易。在这个食谱中，我们将看到如何使用 Meteor 的数据库，以及如何编排数据访问。

## 做好准备

示例文件中有一个`icon.png`图像；除此之外，只有流星需要安装在你的机器上，并有一个开放的命令行。

## 怎么做...

1.  First we can start by creating the application named `movies` from the command line:

    ```
    >meteor create movies

    ```

    为了简化生成的结构，我们将创建两个文件夹:一个名为`server`，另一个名为`client`。`movies.css`、`movies.js`和`movies.html`文件可以放在`client`目录中，因为我们将在那里放置客户端相关代码。

2.  在`server`目录中，我们创建了一个名为`bootstrap.js`的文件，它将用我们将要定义的几个对象初始化数据库:

    ```
    Meteor.startup(function () {
      if (Movies.find().count() === 0) {
        var data = [
          {
            name: "North by northwest",
            score: "9.9"
          },
          {
            name: "Gone with the wind",
            score:"8.3"
          },
          {
            name: "1984",
            score: "9.9"
          }
        ];

        var timestamp = (new Date()).getTime();
        for (var i = 0; i < data.length; i++) {
          var itemId = Movies.insert({
            name: data[i].name,
            score: data[i].score,
            time: timestamp
          });
        }
      }
    });
    ```

3.  你可能想知道的第一件事是，这个`Movies`对象是什么？这是一个集合，我们将在另一个名为`publish.js`的文件中定义，因为在其中我们将从服务器发布该集合。该文件将包括以下内容:

    ```
    Movies = new Meteor.Collection("movies");
    Meteor.publish('movies', function () {
      return Movies.find();
    });
    ```

4.  As for the client side, we have the generated files, so we start creating a simple HTML and a handlebar template to go with it. Inside the template, we will just iterate over Movies and print out a list of elements with the movie name and score. Additionally, in the template, we place button that will contain reference to an image:

    ```
    <body>
      <div id="main">
          {{> movies}}
      </div>
    </body>

    <template name="movies">
      <h3>List of favorite movies</h3>
      <div id="lists">
        <div>
          <ul>
            {{#each movies}}
              <li><b>{{name}}</b>  {{score}}<li/>
            {{/each}}
          </ul>
          <button>
            <img src="icon.png" width="30px" height="30px" />
          </button>
        </div>
      </div>
    </template>
    ```

    为了使`icon.png`图像作为静态文件可用，我们需要创建一个名为`public`的文件夹，并将图像放在那里。这遵循的是*惯例优先于*配置的原则，你没有真正的必要不遵循它，至少大多数时候是这样。

5.  至于客户端，在之前生成的`movies.js`文件中，我们应该会自动订阅`servers`收藏的电影。此外，我们将添加一个功能来填充`movies`变量，并为触发随机新电影保存的按钮添加一个事件:

    ```
    // Define mongo style collections to match server/publish.js.
    Movies = new Meteor.Collection("movies");

    // Always be subscribed to the movies list.
    Meteor.autorun(function () {
        Meteor.subscribe('movies');
    });

    // fill the movies variable with data from the collection sorted by name
    Template.movies.movies = function () {
      return Movies.find({}, {sort: {name: 1}});
    };

    // on click we insert a random movie
    Template.movies.events({
      'click button': function(){
        Movies.insert({
          name: "random awesome movie",
          score: Math.random() * 10
        });
      }
    });
    ```

6.  现在一切都应该正常了。用`meteor`启动应用后，我们可以在默认端口`http://localhost:3000/`的浏览器中访问。如果我们想要更改运行应用程序的端口，例如端口`3333`，我们可以使用以下命令:

    ```
    meteor --port 3333

    ```

## 它是如何工作的...

我们可以首先从数据开始，如果我们有服务器在运行，我们可以打开另一个控制台，在那里我们可以访问同一个目录。然后，在控制台中打开同一个文件夹后，我们运行以下命令:

```
meteor mongo
MongoDB shell version: 2.2.3
connecting to: 127.0.0.1:3002/meteor

```

这打开了一个简单的控制台，我们可以在上面查询我们的数据库。Mongo 将数据存储为集合，为了获得所有可用电影的名称，我们可以使用以下命令:

```
> db.getCollectionNames()
[ "movies", "system.indexes" ]

```

`movies`集合是我们在`bootstrap.js`初始化中定义的集合；至于`system.indexes`，它是一个包含了所有索引的集合数据库。为了处理这个集合的数据，我们可以使用`ensureIndex()`和`dropIndex()`。

在控制台中，我们可以分配以下变量:

```
> var x = db.getCollection("movies");
> x
meteor.movies

```

收藏可以用`find()`查询；如果我们尝试在没有参数的情况下调用它，它会返回所有元素:

```
> x.find();
{ "name" : "North by northwest", "score" : "9.9", "time" : 1360630048083, "_id" : "bc8f1a7a-71bd-49a9-b6d9-ed0d782db89d" }
{ "name" : "Gone with the wind", "score" : "8.3", "time" : 1360630048083, "_id" : "1d7f1c43-3108-4cc5-8fbf-fc8fa10ef6e2" }
{ "name" : "1984", "score" : "9.9", "time" : 1360630048083, "_id" : "08633d22-aa0b-454f-a6d8-aa2aaad2fbb1" }
...

```

数据是基本的 JSON，很容易用 JavaScript 操作。如果你看一下对象，你会注意到`"_id" : "08633d22-aa0b-454f-a6d8-aa2aaad2fbb1"`键-值对。这是 Mongo 生成的唯一密钥，我们用它来引用和操作该对象，通常称为 **文档**。

如果我们想删除 ID 为`beef20a3-c66d-474b-af32-aa3e6503f0de`的记录，我们可以使用以下命令:

```
> db.movies.remove({"_id":"beef20a3-c66d-474b-af32-aa3e6503f0de"});

```

之后我们可以调用`db.movies.find()`查看，注意现在少了一个。还有很多其他用于数据操作的命令，但大多数都是直观的，你可以很容易地根据它们的名字进行猜测。作为快速提醒和学习工具，有一个`help`功能可以调用:

```
>help
>db.help()

```

这两个命令列出了一个命令列表，并简要解释了每个命令的作用。您不应该被命令的数量淹没，因为我们不会使用其中的大部分，但它仍然是一个很好的参考。

### 注

有关 MongoDB 命令的更详细教程，请访问[http://mongodb.org](http://mongodb.org)并点击**试用**来试用在线外壳。网络上有很多关于 NoSQL 的资源，但是*马丁·弗劳尔*做的一个很棒的介绍可以在[http://www.youtube.com/watch?v=qI_g07C_Q5I](http://www.youtube.com/watch?v=qI_g07C_Q5I)找到。

如果我们打开一个浏览器，我们可能会注意到，每次点击随机按钮，一个新的记录会立即被添加。这看起来非常快，这不仅仅是因为服务器在本地运行。每当客户端向服务器发出写操作时，如果写操作成功，它会立即更新本地缓存，而无需服务器的响应。当服务器收到请求并接受更新时，客户端就不必在屏幕上做任何事情。这种情况应该在大多数情况下都会发生，它节省了往返等待时间，使屏幕更具响应性。另一方面，如果服务器拒绝更新，客户端的缓存将被更新为正确的结果。

在 Meteor 中，客户端和服务器使用相同的应用编程接口来访问数据库。重点是减少框架中每个设计决策往返服务器的时间。请求和响应以及消息失效都是为了实现这一点而编排的。

我们使用`autorun`从我们的`movies.js`中的服务器自动获取更新:

```
Meteor.autorun(function () {
    Meteor.subscribe('movies');
});
```

`autorun`函数中的代码块是所谓的 **反应上下文**，使我们能够以命令式的风格编写代码，但却得到一个反应行为。

**反应式编程** 是面向变化传播的编程范例之一。在命令式编程中，如果我们有像`z = x + y`这样的表达式，这意味着`x + y`的求值结果将如预期的那样分配给`z`。例如，如果我们有`x = 42`和`y = 13`，那么`z = 42 + 13`或`z = 55`。`x`和`y`的值可以稍后更改，例如可以更改为`x=4`和`y=4`，但这不会以任何方式影响`z`，仍然是`55`。

最简单的例子就是现代的电子表格程序，比如微软的 Excel 或者谷歌的 docs 电子表格。电子表格单元格通常包含文字值，例如数字，或者可以包含从其他单元格中派生出值的公式。在我们的单元格`C3`中，我们可以有公式`"=A1+B1"`，意思是当我们更改`A1`或`B1`中的一些值时，`C3`将自动更新。

在 MVC 架构中，可以使用反应式编程进行简化，在这种架构中，我们自动将视图中的更改传播到模型中，然后再传播回来，这对实时系统非常有益。

反应上下文的使用使我们不必编写一整类调用。在我们的示例中，我们首先需要在发生变化时取消订阅，然后再次重新订阅以从服务器上取回数据。这减少了大量的代码，这些代码最终可能容易出错，并增加了维护阶段的复杂性。

### 注

除了`Meteor.autorun`之外，在`Templates`和`Meteor.render`和`Meteor.renderList`功能中应用了反应上下文。

至于可以触发变化的数据源，我们可以使用数据库`collections`和`session`变量，以及其他一些与身份验证和授权相关的功能。你可以在流星的文件中找到更多关于它在[http://docs.meteor.com/#reactivity](http://docs.meteor.com/#reactivity)的反应性的细节。

如果您并排打开两个不同的浏览器，您可能会注意到，即使会话不同，也会显示相同的数据。为了获得特定于用户的数据，我们将在下一个配方中创建一个示例。

您可能希望将整个集合发送给客户，但首先要彻底考虑这是否是客户真正需要的。通常，只发送某些字段而不是整个文档可能更明智。为了降低网络流量，客户端的某些部分可以关闭订阅，这些部分的文档将从本地缓存中删除，除非在其他活动订阅中使用。

## 还有更多...

因为我们使用的数据存储在数据库中，如果我们使用一些外部应用程序在那里更改数据，它也会触发对客户端的更改。在下一个食谱中，我们将看到如何允许多个用户拥有他们自己的喜爱列表，而不是一个全局列表。

# meteor . js 中的实时 HTML 和用户特定数据

您可能已经在之前的食谱中注意到，我们使用的数据是全局的，而不是用户特定的。在本食谱中，我们将了解如何创建会话数据，并深入了解模板以及与之相关的数据。为了演示这一点，我们将创建一个小的图像投票应用程序，用户将被提示输入姓名，然后他们将获得 50 分，可以在图像上投票。

## 做好准备

为了使配方更简单，我们将从`public`目录静态地提供图像，这样您就可以下载示例代码中的示例图像，或者使用您自己的图像。

## 怎么做...

1.  我们从任何其他正常的流星应用程序开始:

    ```
    >meteor create gallery

    ```

2.  因为我们将在这个配方中使用更多一点的代码，所以创建一个结构是有意义的，其中`public`文件夹用于静态文件，而`server`和`client`文件夹分别用于服务器和客户端代码。之后，我们可以将生成的图库文件移动到`client`文件夹，并将图像添加到`public`文件夹。为了简单起见，这些图像将被命名为`1.jpg`、`2.jpg`、`3.jpg`，你猜怎么着，`4.jpg`。然后我们继续在`server`文件夹中创建`bootstrap.js`文件:

    ```
    // if the database is empty fill it with data
    Meteor.startup(function () {
      //has some images
      if (Images.find().count() < 4) {
        var images =[
          {
            name: "Awesome Cat",
            url: "img/1.jpg",
            votes: "0"
          },{
            name:"Cool Cat",
            url: "img/2.jpg",
            votes: "0"
          },{
            name:"Mjauuu",
            url: "img/3.jpg",
            votes: "0"
          },{
            name:"The Cat",
            url: "img/4.jpg",
            votes: "0"
          }
        ];

        for (var i = 0; i < images.length; i++) {
          Images.insert(images[i]);
        }

        Users.insert({
          name: "awesome user",
          pointsLeft: "30"
        });
      }
    });
    ```

3.  This will initialize the database with a simple user and add some data about the images, as well as add a condition that this should happen only when there are less than four images in the database.

    ### 注

    您可能会注意到，我们正在使用`for`循环来插入数据，但是由于 MongoDB 的版本 2.2， `db.collection.insert()`函数可以接受一个元素数组，并将它们批量插入集合中，但是我们没有使用这样的方法，因为它将导致稍微复杂的结构，我们希望使用最简单的情况。你可以在[上阅读更多关于`db.collecton.insert()`的信息。](http://docs.mongodb.org/manual/reference/method/db.collection.insert/)

4.  之后，我们可以继续进行集合的定义和发布，使集合对客户端可用:

    ```
    // DB collection of movies
    Images = new Meteor.Collection("images");

    // DB collection of users
    Users = new Meteor.Collection("users");

    // Publish complete set of lists to all clients.
    Meteor.publish('images', function () {
      return Images.find();
    });

    // Publish for users
    Meteor.publish('users', function () {
      return Users.find();
    });
    ```

5.  现在我们可以继续`gallery.html` :

    ```
    <body>
      <div class="box">
        {{> main}}
      </div>
      {{> footer}}
    </body>

    <template name="footer">
      <footer>
        {{footerText}}
      </footer>
    </template>
    ```

    中的模板代码了
6.  `main`模板将检查当前是否有用户在场。如果存在，它将显示投票，否则，它将显示一个输入名称的简单表单:

    ```
    <template name="main">
      {{#if hasUserEnteredName}}
        {{> votes}}
        {{> gallery}}
      {{else}}
      <label>Please insert your name
        <input name="name">
        </input>
        <button class="name">start</button>
        </label>
      {{/if}}
    </template>
    ```

7.  `votes`模板将显示用户还剩多少票，图库将显示图像以及当前票数信息，并添加一个用于投票的按钮:

    ```
    <template name="votes">
      <h3>You have <i>{{numberOfVotes}}</i> votes left</h3>
    </template>

    <template name="gallery">
      <div>
        {{#each images}}
        <div class="item">
          <p>
            <b>Cat named:</b>{{name}}
            </p>
          <img src="{{url}}" />
          <p>
            Votes:
            <progress value="{{votes}}" max="500" />
            <output>{{votes}}</output>
          </p>
          <button class="vote">Vote for me</button>
        </div>
        {{/each}}
      </div>
    </template>
    ```

8.  We can start up the application and see if everything turned up as expected. If you open up the application on two browser sessions side by side, and enter two different names, you can notice that when we vote on the images, the number of votes gets updated instantly on the other browser session.

    ![How to do it...](graphics/9282OT_10_01.jpg)

## 它是如何工作的...

你可能想看到的第一件事是数据库中的状态是什么。服务器启动时，您可以启动`meteor mongo`控制台，用`db.getCollectionNames()`列出集合，您应该会看到以下结果:

```
[ "images", "system.indexes", "users" ]
```

集合名称是我们在`publish.js`文件中定义的名称。至于数据库中包含的数据，我们决定将图像的网址放在`public`文件夹中进行图像收集，因为这种情况下更简单。

### 注

如果您需要存储或操作二进制数据，如图像，您可以在 MongoDB 中这样做，它在 Meteor 上运行得非常好。在那里我们可以使用 EJSON，其中 E 代表扩展的。基本上，它支持所有的 JSON 类型，同时通过 JavaScript `Date()`对象添加额外的数据，并通过`Uint8Array`添加二进制数据。您还可以定义自己的自定义数据类型，并使用类似于调节器 JSON 的 EJSON 对象。还有一些其他的方法，比如`EJSON.newBinary(size)``EJSON.addType(name,factory)`，你可以在[http://docs.meteor.com/#ejson](http://docs.meteor.com/#ejson)上了解更多。还可以选择配置您自己已经存在的 MongoDB 实例。这是通过在启动流星之前定义一个环境变量来实现的:

```
MONGO_URL=mongodb://localhost:3317 meteor
```

这使得非流星应用程序使用相同的 MongoDB 服务器变得很方便。

在`gallery.js`文件中，为了在客户端有一些数据，我们使用了`Session`变量。这实际上是一个全局对象，可以在客户端用来存储任何键值对。就像你在其他框架和语言中习惯的一样，我们有`Session.set("theKey", someValue)`存储`theKey`的`someValue`，还有`Session.get("theKey")`用来检索数据。至于初始化，有`Session.setDefault("theKey", initalValue)`，方便避免每次加载新版本的应用程序时重新初始化变量。

### 注

您可以在[http://docs.meteor.com/#session](http://docs.meteor.com/#session)阅读更多关于流星规范中会话对象的信息。

到目前为止，您可能已经注意到，我们可以嵌套模板。这是一个标准的车把行为，在我们的例子中，我们使用它来简化视图逻辑。在现实场景中，不仅只分离可以在应用程序的其他部分重用的部分更有意义，同时，您也不希望有巨大的模板使您的代码难以阅读。为了有事件，我们可以使用标准的 CSS 选择器将它们添加到我们的模板中，因此如果我们想要使用`main`模板中的`.name` CSS 类在元素的`click`事件上附加一个回调，我们可以使用以下代码:

```
Template.main.events({
    'click .name' : function () { ... }
});
```

在事件回调中，我们可以访问几个对我们有用的对象。我们在`Template.gallery.events`中使用了其中的一些，其中`onclick`回调接受两个参数；我们可以在这个对象中看到，我们可以访问相关的文档。拥有元素被触发的数据上下文可以轻松操作该部分:

```
Template.gallery.events({
  'click .vote' : function(e,t) {
    //this object can be used to access elements
      }
});
```

回调中传递的两个参数允许访问事件类型以及当前目标的`DOMElement`。

### 注

更多关于如何使用事件映射和选择器以及在事件回调中还可以访问什么的信息可以在[http://docs.meteor.com/#eventmaps](http://docs.meteor.com/#eventmaps)找到。您还可以附加在模板渲染后调用的回调，[http://docs.meteor.com/#template_rendered](http://docs.meteor.com/#template_rendered)。还有一种选择是用其他模板引擎代替车把，比如翡翠，比如[http://docs.meteor.com/#templates](http://docs.meteor.com/#templates)。这是可以做到的，因为模板的反应上下文不依赖于引擎；您甚至可以通过附加字符串来手动构建 HTML，它仍然可以工作。

在除了`Users.insert`之外的`main`模板中，我们使用了`db.collection.findOne`函数来返回找到的第一个对象。这是通过将我们指定的查询与数据库进行匹配来实现的，如果找到了第一个结果，则按照自然顺序进行检索。

### 注

关于`findOne`的更详细的解释可以在[的 MongoDB 文档中找到。](http://docs.mongodb.org/manual/reference/method/db.collection.findOne/)

关于元素的更新，集合接受两个参数，第一个是选择查询，其中例如在`voteForImage`中，我们使用 MongoDB 生成的`_id`来匹配元素，第二个是新的更新，使用`$set`修改器来更新所选文档的`pointsLeft`属性:

```
    Users.update(
        {_id:currentUser._id},
        {$set:{pointsLeft:currentUser.pointsLeft}}
      );
```

### 注

有几种不同的更新修饰符可以使用，您可以在文档中详细阅读它们，但是为了让您了解基础知识，您可以使用 MongoDB 背后的公司 10gen 提供的一些参考卡。更多详情可在[http://www.10gen.com/reference](http://www.10gen.com/reference)找到。

在我们的例子中，我们可以使用`$inc`修改器来增加给定数量的值，但是为了简单起见，我们选择了更通用的`$set`修改器。另外，可以做的另一个改进是将集合声明(如`Images = new Meteor.Collection('images')`)移动到服务器和客户端的公共文件中，该文件不在各自的文件夹中，这样我们就可以减少代码重复。

## 还有更多...

在某个时间点，您可能希望有某种基于标准 JavaScript `setTimeout`或`setInterval`函数的计时器。如果您尝试这样做，您会得到一个错误，但是相同的功能由`Meteor.setTimeout`和`Meteor.setInterval`功能([http://docs.meteor.com/#timers](http://docs.meteor.com/#timers))提供。

说到视图，到目前为止，您可能已经看到它完全是用 JavaScript 处理的。这是 Meteor 的问题之一，因为像这样生成的内容很难被谷歌等搜索引擎索引。为了帮你解决这个问题，有一个名为**([http://docs.meteor.com/#spiderable](http://docs.meteor.com/#spiderable))的包可以作为临时的修复。**

 **# meteor . js 中的安全机制

关于《流星》的安全性，一直有很多争议。数据库处处不尖叫安全。我们对客户端和服务器端代码使用相同的应用编程接口，不需要天才就能知道我们也可以删除集合。在 JavaScript 控制台上玩了一会儿后，我们可以轻松删除前面例子中的所有`Users`。为了安全起见，您可以始终滚动自己的实现；例如，您可以覆盖默认的服务器方法处理程序，使`Users`和`Images`集合可以从客户端访问:

```
Meteor.startup(function () {
  var collection = ['Users', 'Images'];
  var redefine = ['insert', 'update', 'remove'];
  for (var i = 0; i < collection.length; i++) {
    for (var j = 0; j < redefine.length; i++){
      Meteor.default_server.method_handlers['/' + collection[i] + '/' + redefine[j]] = function() {
        console.log('someone is hacking you, oh no !!! Too bad for him...');
      };
    }
  }
});
```

在本食谱中，我们将了解流星保护应用程序的方式，以及一些身份验证和授权机制。为此，我们将创建一个简单的列表输入应用程序。

## 做好准备

这个食谱不需要特殊的准备；您只需要命令行和安装的 Meteor 版本。

## 怎么做...

让我们开始吧。

1.  使用`meteor create secure`创建名为`secure`的应用程序。在生成的`secure.html`文件中，我们将定义一个小模板，它将包含一个输入元素、一个按钮和一个已经可用的列表条目列表:

    ```
    <body>
      {{> list}}
    </body>

    <template name="list">
      <h1>This is my awesome list</h1>
      <input placeholder="enter awesomeness"> </input>
      <button>Add</button>
      <ul>
        {{#each items}}
          <li>{{text}} </li>
        {{/each}}
      </ul>
    </template>
    ```

2.  `secure.js`中的伴随代码将初始化列表中的一个元素，并添加渲染模板的日期:

    ```
    Notes = new Meteor.Collection("Notes");

    if (Meteor.isClient) {
      Template.list.items = function () {
        return Notes.find();
      };

      Template.list.events({
        'click button' : function () {
          Notes.insert({
            text: $('input').val()
          });
        }
      });
    }

    if (Meteor.isServer) {
      Meteor.startup(function () {
        //initialize
        if(Notes.find().count() < 1){
          Notes.insert({
            text: "awesomeness"
          });
        }
      });
    }
    ```

3.  启动应用程序，并摆弄它，检查它是否工作。如果此时打开浏览器的控制台，我们可以直接访问`Notes.remove()`，这也是我们平时想要禁止的事情之一。我们可以使用以下命令删除作为生成的应用程序的一部分的默认智能包:

    ```
    meteor remove insecure

    ```

4.  同样的事情也可以通过手动编辑`.meteor/packages`来实现。这将使我们的应用程序“安全”，甚至过于安全，如果有这样的事情。
5.  Now if we try to toy with the browser's console, we'll get the following message:

    ```
    insert failed: Access denied

    ```

    如果我们只需点击之前有效的**添加**按钮，同样的信息就会出现。这是因为对数据库的所有请求现在都被视为匿名的，我们只获取从服务器发布的内容。

6.  我们总是可以滚动自己的身份验证，但是内置了一个很棒的；要将其添加到我们的项目中，我们可以使用以下代码:

    ```
    > meteor add accounts-base
    accounts-base: A user account system
    > meteor add accounts-password
    accounts-password: Password support for accounts.
    > meteor add email
    email: Send email messages
    >  meteor add accounts-ui
    accounts-ui: Simple templates to add login widgets to an app.

    ```

7.  As previously mentioned, we can add these packages directly in our `packages` file; it is a good idea to check often what you have there in the example applications you try out so that you won't be surprised.

    ### 注

    各种包和第三方库扩展了 Meteor 的核心功能。有 D3、下划线、主干的软件包，每天还会增加很多。这些和一些基本的支持逻辑可以在[http://docs.meteor.com/#packages](http://docs.meteor.com/#packages)找到。还有一种方法可以为应用程序创建自己的扩展和公共逻辑。

8.  我们包含的包是一组助手，使身份验证用户管理逻辑自动化。帐户-用户界面甚至使我们能够有很好的用户界面登录，只需很少的努力。那么，我们需要做哪些努力来实现它呢？首先，我们将在登录界面出现的地方添加一小块代码:

    ```
     <div id="login">
        {{loginButtons align="right"}}
      </div>
    ```

9.  此外，我们需要配置我们想要的登录类型，因此在我们的例子中，我们使用简单的用户名和密码类型，其中可选地可以输入电子邮件。我们在`secure.js`文件中添加了这个配置:

    ```
    Accounts.ui.config({
        passwordSignupFields: 'USERNAME_AND_OPTIONAL_EMAIL'
    });
    ```

10.  One other thing you might want to add is a simple CSS style to position the login box:

    ![How to do it...](graphics/9282OT_10_02.jpg)

简单注册并登录到帐户后，我们会注意到一个带有用户名的用户链接。我们可以用这个来注销。正如你注意到的，这是毫不费力的。

帐户用户界面还有很多其他配置选项，以及连接推特、脸书、谷歌和 GitHub 帐户的扩展。更多信息可在[http://docs.meteor.com/#accounts_ui_config](http://docs.meteor.com/#accounts_ui_config)找到，包装文件可在[http://docs.meteor.com/#accountsui](http://docs.meteor.com/#accountsui)找到。此外，您可以使用发送验证电子邮件或确认等功能。

## 它是如何工作的...

登录后，如果我们尝试使用我们的按钮添加文本，我们会注意到我们仍然没有访问权限，因为我们的用户无权插入。要允许特定用户插入，请使用以下代码:

```
  Notes.allow({
      insert: function (userId, doc) {
        console.log(userId);
        console.log(doc);
        //do the check for the permission and return true if allowed
        return true;
      }
    });
```

在这个插入回调中，我们可以允许或拒绝用户使用`userId`访问给定的文档。对于我们的例子，文档是我们试图插入的`Notes`对象，`userId`是当前登录用户的标识。除了`collection.allow`之外，还有一个对应的`collection.deny`，即使有`allow`规则，我们也可以用它来禁止某些方法的访问。

现在，很容易创建一个高级授权系统，我们可以通过编程指定访问权限。有些程序员认为这会导致大量开销，对于某些应用程序来说可能是这样，但是对于大多数应用程序来说，像这样设置访问权限应该非常简单。

一般来说，我们永远不应该相信来自客户端的数据。应该只允许访问他们必须使用的部分，并且应该过滤输入。将信用卡数据发送给客户是摧毁你的业务的一个简单方法。仅仅因为 Meteor 为我们做了这么多事情，并不意味着我们应该忘记其他常见的实践，比如数据验证。

您可能想知道我们用于注册的用户数据存储在哪里。如果我们用`meteor mongo`访问 Mongo 控制台，有一个`users`集合应该包含如下内容:

```
{
  "createdAt": 1362434550460,
  "services": {
    "password": {
      "srp": {
        "identity": "bE9uYyziWxM2soGem",
        "salt": "FDEduAsvpf5ZJCWea",
        "verifier": "11a2fa4139c8283db1ce61e5f5fa7bf875da27a9b8ec195 baae49cd69c7f3ea48e1c1db471e1bc6aa1a9894a0633f44098717e0c6af367dcd39f 964d63f4fd5346f3b314bd897b76d3f31aa8aeb37030e5fef099b77efb594ad07103 6ec31fb6a3016f0c6cc43605469f798e20fc5b005e982e579014aef7742aac3 bc5792271"
      }
    },
    "resume": {
      "loginTokens": [
        {
          "token": "PDbpT6jtKcdvZMurr",
          "when": 1362434550460
        }
      ]
    }
  },
  "username": "mite",
  "emails": [
    {
      "address": "mitemitereski@gmail.com",
      "verified": false
    }
  ],
  "_id": "QuZEe4uSPK6MfM5PQ"
}
```

正如你所注意到的，它或多或少是一个标准的数据，你可能期望存储在数据库中。密码是用盐散列存储的，以防止一些常见的攻击。

就是这样。我们有一个非常简单但安全的应用程序。列表的数据当然不是特定于用户的，但是可以通过为每个创建的文档添加所有者字段来轻松扩展。

## 还有更多...

你应该接受的一件事是，流星仍然没有完全完成。每个版本都有很多变化，直到它完全稳定。用户请求的大部分内容正在被添加，以及其他重要的架构改进正在被实现，因此您需要用每个版本更新部分代码。

一个很好的信息资源是示例应用程序；您可以通过使用`meteor create –list`命令调用示例应用程序来列出它们；至于重新获取代码，可以使用`meteor create -example nameofexample`。

说到部署，我们可以自由使用我们自己提供的服务器，但是可以选择将其部署在[www.meteor.com](http://www.meteor.com)上。这是一家创业公司在这个有趣的框架背后提供的服务。部署只有一个命令:

```
>meteor deploy myapp.meteor.com

```

更多关于云解决方案的信息可以在[http://docs.meteor.com/#meteordeploy](http://docs.meteor.com/#meteordeploy)找到。

还可以从我们的 Meteor 应用程序生成一个完全包含的 Node.js 应用程序，并使用一些其他的云服务。这可以使用以下命令来完成:

```
>meteor bundle packed.tgz

```

对于未打包文件的运行，请使用以下命令:

```
> PORT=3000 MONGO_URL=mongodb://localhost:2222/myapp node main.js

```

这是可能的作为流星，在幕后，是一个不同种类包装的 Node.js 框架。**