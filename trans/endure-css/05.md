# 第五章。文件组织和命名约定

在最后一章中，我们对 ECSS 的设计考虑进行了概要介绍。在这一章中，我们将开始更深入地了解我们实际上是如何开始使用 ECSS 的。

让 ECSS 为您服务的两个基石是遵守文件组织和类命名约定原则。接下来让我们看看这些方面。

# 项目组织

如果我们想方便地从我们的网站/应用中删除代码，我们需要考虑我们组织构成项目的文件的方式。通常，当构建网站，特别是 web 应用时，从模块或组件的角度考虑是有用的；用户界面的可定义部分。这些模块可能主要由可视区域定义，或者可能是由于生成它们的文件。无论哪种方式，花时间考虑这些模块的组织都是值得的。

通常，按技术类型拆分项目中的文件是一种常见的做法。

考虑一下这个基本的文件夹结构:

```html
my-project/
- html/
- js/
- css/
```

在每个文件夹中，您可以命名相关的文件。例如:

```html
my-project/
- html/
    - v2ShoppingCart.html
- js/
    - v2ShoppingCart.js
- css/
    - v2ShoppingCart.css
```

问题是，超出某一点，即使给出了文件相关的名称，也很难推理出项目中的每个样式表、逻辑文件和模板是如何关联的。`css`文件夹中可能有 80+ CSS 分支，`html`文件夹中可能有 50+模板存根。

### 注

我认识到现实是网站或应用的*视图*部分通常由许多不同的技术生成，比如 Ruby、PHP、。NET 甚至 JavaScript——而不是普通的 HTML。

然后，越来越需要依靠文本编辑器/IDE 中的*查找*来查找某个类正在使用的任何模板。反过来也是如此；需要*查找*来定位包含特定模块模板所需样式的部分。

这种结构并没有让事情变得不可行，只是效率低下，而且它通常需要一点精神定位来记住什么和什么一起发生。

虽然对 ECSS 来说不是必需的，但通常更可取的是，文件不是按技术类型组织的，而是按视觉或逻辑组件组织和分组的。所以，与其这样:

```html
html/
- shopping-cart-template.html
- callouts-template.html
- products-template.html

js/
- shopping-cart-template.js
- callouts-template.js
- products-template.js

css/
- shopping-cart-template.css
- callouts-template.css
- products-template.css
```

我们的目标是这样的:

```html
shopping-cart-template/
    - shopping-cart.html
    - shopping-cart.css
    - shopping-cart.js

callouts-template/
    - callouts.html
    - callouts.js
    - callouts.css

products-template/
    - products.html
    - products.js
    - products.css
```

乍一看，这似乎是一个看似不重要的区别，但它带来了重要的好处。

每个组件的代码在物理上都是自封闭的。然后，在我们持久的项目中，当特性需要更改或被否决时，该模块的所有相关代码(样式、视图逻辑(HTML)和 JS)都可以很容易地更新/删除。

### 注

**到期信用**

*尼古拉斯·加拉格尔*([http://nicolasgallagher.com/](http://nicolasgallagher.com/))在大规模考虑 CSS 实现时总是走在游戏的前面，我从他的作品中采用并改编了这种方法的大元素(特别是按组件组织代码)。一段时间以来，我一直在给组件命名空间(因此我声称是伪多重发现)，但按组件组织代码的方法完全是从*听到他谈论这个问题时(https://www.youtube.com/watch?v=m0oMHG6ZXvo)得到的。*

除了有意的*全局* CSS 之外，所有与组件或模块表示相关的代码都应该包含在该组件的 HTML/JS 旁边的部分中。

### 注

虽然你可能不喜欢，但总需要一定程度的全局 CSS 至少是一组简单的重置或标准化样式。

当一个模块被弃用时，所有与之相关的文件都可以很容易地从代码库中删除；只需删除包含该模块的文件夹。

为了清楚起见，考虑一下我们想象中的`ShoppingCart`组件的文件夹结构:

```html
ShoppingCart/
    - ShoppingCart.js
    - ShoppingCart.css
```

现在假设我们创建了一个新的购物车:

```html
v2ShoppingCart/
    - v2ShoppingCart.js
    - v2ShoppingCart.css
```

我们的`v2`购物车一完成，就很容易从我们的代码库中移除之前版本的代码；我们只是删除了包含我们旧代码的文件夹`ShoppingCart`。

## 当同一文件夹组织不可能时

在同一个文件夹中包含样式表、资产和应用逻辑可能是不可能的，也是不可取的。

在这种情况下，下一个最好的选择是模仿逻辑的结构。举例说明。假设组件的逻辑存储在如下的文件夹结构中:

```html
src/app/v2ShoppingCart/v2ShoppingCart.js
```

我们应该尽可能地模仿这种结构。在任何大型应用中，这将使查找相关文件变得更加容易。因此，我们可以这样做——尽可能匹配逻辑文件的文件夹层次结构:

```html
src/app/css/v2ShoppingCart/v2ShoppingCart.css
```

当使用 ECSS 时，相同的父文件夹肯定应该被认为是*黄金*标准，但是在没有这个标准的情况下，模仿逻辑文件的结构应该会提供一些好处。

有了如何在我们的项目中组织文件的具体想法，让我们转向我们可以向我们的选择器/类传达额外意义和开发人员便利性的主要方式。

# 用 ECSS 命名类和选择器

回到[第 3 章](03.html "Chapter 3. Implementing Received Wisdom")、*实现接收智慧*，我认识到命名 CSS 选择器的边界元方法给我们带来的好处。命名一个块，然后命名与该块相关的任何子元素，就为子元素创建了一个命名空间。

命名模块的 CSS 创建了一种隔离形式。通过防止与其他元素的名称冲突，CSS 块可以更容易地从一个环境移动到另一个环境(例如从原型移动到产品)。一个选择器上的样式改变不经意间影响另一个选择器的可能性也要小得多。

### 注

有许多其他方法可以解决名称冲突问题。例如，如果你正在用流行的*React*([https://facebook.github.io/react/](https://facebook.github.io/react/))框架构建一个应用，考虑一下*镭*([https://github.com/FormidableLabs/radium](https://github.com/FormidableLabs/radium))它将为每个节点内嵌样式，这样你就可以有效地完全不用 CSS 服务。当然，也有一些折衷，比如缺少缓存和没有办法添加重置样式，但是它确实解决了眼前的问题。另外，不使用 React 构建时，考虑 *CSS 模块*([https://github.com/css-modules/css-modules](https://github.com/css-modules/css-modules))。虽然需要比 ECSS 更复杂的工具，但这意味着您可以不必考虑命名事物，因为它为您创建了 CSS 范围。在这里(https://medium . com/seek-ui-engineering/the-end-global-CSS-90d 2a 4a 06284)阅读更多*。*

ECSS 采用选择器名称间距的概念，并将其*变为 11*([https://en.wikipedia.org/wiki/Up_to_eleven](https://en.wikipedia.org/wiki/Up_to_eleven))。选择器实际上有两种命名方式:

*   微命名空间:通常用于指定上下文，但也可以表示父模块
*   模块自己的名称空间:通常是创建所讨论元素的逻辑文件的名称

让我们更详细地看看这些。*微*命名空间是每个模块的简单的 2-3 个字母的命名空间。造购物车？试试`.` `sc-`作为你的微命名空间。建造同一个购物车的下一个版本？那就是`.`T3 了。隔离您的组件样式并允许样式更加自我记录就足够了。让我们考虑一个更复杂的例子。

### 类型

说到命名事物，不同的事物在不同的项目中会有意义。虽然 ECSS 可以很好地适应不同的方法，但我建议每个项目都采用一致的方法。

例如，假设微命名空间被用来传达创建它的逻辑的父级或起源。回到我们的购物车例子。我们可能有一个名为`ShoppingCart.php`的文件，其中包含了与我们想象中的购物车相关的所有逻辑。因此，我们可以使用`sc-`作为该文件名的缩写，这样我们就知道任何以该名称空间开头的元素都与购物车相关，并由该相关文件呈现。

在这种情况下，我们会有选择器，如:

*   `sc-Title`:购物车的标题
*   `sc-RemoveBtn`:从购物车中取出商品的按钮

这里的选择器非常紧凑——如果一个选择器甚至可以用这种方式来描述的话，那么它在美学上是令人愉悦的。然而，假设我们有一个可以生活在多种环境中的购物车。迷你购物车视图和全页面视图。在这种情况下，我们可能决定使用微命名空间来传达上下文。例如:

*   `mc-ShoppingCart_Title`:购物车的标题，在*迷你购物车*视图/上下文中由文件`ShoppingCart`生成。
*   `mc-ShoppingCart_RemoveBtn`:购物车的移除按钮，在*迷你购物车*视图/上下文中由文件`ShoppingCart`生成。

这两种方式都不是唯一的方法。ECSS 理念的一部分是，虽然一些核心原则是必不可少的，但它可以适应不同的需求。一般来说，对于较小规模的用例，前一种方法是可以的。然而，尽管第二种方法中的选择器相对冗长，但它是最有弹性和自我记录的。使用第二种方法，您知道上下文、生成选择器的文件(以及它所属的模块)和它所涉及的元素。

### 注

在[第 7 章](07.html "Chapter 7. Applying ECSS to Your Website or Application")、*将 ECSS 应用于您的网站或应用*中有关于将 ECSS 惯例应用于网络应用和视觉模块的更具体的信息。

## 重申好处

由于命名空间模块和组件几乎保证不会相互泄漏，因此构建和迭代新设计变得非常容易。它提供了迄今为止无法想象的有罪不罚的局面。只需为你正在构建的东西创建一个新的部分文件，分配一个合适的微命名空间和模块名称，并编写你的风格，相信你不会对任何你不想要的东西产生负面影响。如果你正在构建的新东西不工作，你可以删除部分文件，也相信你不会删除其他东西的样式。CSS 创作和维护信心-终于！

### 源顺序变得不重要

由于我们的规则现在是孤立的，这使得样式表中规则的顺序变得不重要。这种好处在从事大规模项目时变得至关重要。在这些场景中，部分文件以任何顺序组装通常是更可取的。规则相互隔离，这很简单。通过我们的*自我隔离*规则，它使部分样式表单的文件整合变得简单且无风险。有了一些基本的工具，您可以一次性编译模块中的所有 CSS 部分，如下所示:

```html
@import "**/*.css";

```

不再为项目中的每个部分编写`@import`语句，也不再担心它们的顺序。

### 类型

我们将在[第 9 章](09.html "Chapter 9. Tooling for an ECSS Approach")、*为 ECSS 方法*准备的工具中讨论更多关于文件全球化的内容。

## 剖析 ECSS 命名约定

由于项目的命名对实现我们的目标非常有用和重要，下一节将更详细地记录 ECSS 的命名约定。把这个想象成你的 CSS 选择器的海恩斯手册。

以下是 ECSS 选择器的细分:

```html
.namespace-ModuleOrComponent_ChildNode-variant {}

```

为了说明各个部分，这里是选择器的解剖结构，各部分用方括号标出:

```html
.[namespace][-ModuleOrComponent][_ChildNode][-variant]
```

### 类型

在一个项目中有超过两个开发人员，我建议不遵循 ECSS 命名模式的代码库提交会被自动拒绝。有关促进这一点的必要工具的一些信息包含在[第 9 章](09.html "Chapter 9. Tooling for an ECSS Approach")、*ECSS 方法的工具*中。

### 选择器部分的说明

让我们回到 ECSS 选择器的各个部分和允许的字符类型:

*   `Namespace`:这是每个选择器都需要的**部分。微命名空间应该全部是小写/train-case。它通常是表示上下文或原始逻辑的缩写。**
***   `Module or Component`:这是上驼格/帕斯卡格。它应该总是以连字符(`-`)开头。*   `ChildNode`:这是选择器的可选部分。它应该是大写的 camel 大小写/pascal 大小写，前面加下划线(`_`)。*   `Variant`:这是选择器的另一个可选部分。应该全部用小写/train-case 书写。**

 **使用这种语法，类名的每个部分都可以从逻辑上区分开来。关于这些部分是什么以及如何使用它们的更多信息如下:

### 命名空间

如上所述，HTML 类/CSS 选择器的第一部分是微命名空间(全小写/train-case)。命名空间用于防止冲突，并提供一些软隔离，以便于规则的维护。

### 模块或组件

这是创建选择器的可视模块或逻辑块。应该用上驼色的大小写。我见过当模块或组件直接引用创建它的文件的名称时，ECSS 应用得非常有效。例如，一个名为`CallOuts.js`的文件可以有一个选择器，如`sw-CallOuts`(这里用来表示它的`sw-`微名称空间将被用于*站点范围*)。这为未来的开发人员消除了关于这个元素原点的任何模糊性。

## 子节点

如果某个大写字母前面有下划线(`_`)，则它是模块或组件的子节点。

例如:

```html
.sc-Item_Header {}

```

这里，`_Header`表示该节点是属于`sc`名称空间的`Item`模块或组件的`Header`子节点(如果它是组件，该名称空间可以表示父模块)。

### 变体

如果某个东西全是小写/train-case，而不是类名的第一部分，那么它就是一个变体标志。变体标志是为需要引用选择器的许多变体的事件保留的。假设我们有一个模块，需要根据分配给它的类别号显示不同的背景图像。我们可以这样使用变体指示器:

```html
.sc-Item_Header-bg1 {} /* Image for category 1 */.
sc-Item_Header-bg2 {} /* Image for category 2 */.
sc-Item_Header-bg3 {} /* Image for category 3 */

```

这里选择器的`-bg3`部分表示这个`.` `sc-Item_Header`是类别 3 版本(因此可以分配适当的样式)。

### 在 ECSS 选择器上加倍

我们前面的例子指出了一个完美的情况，在这个元素上使用两个类是合适的。一个用于指定默认样式，另一个用于设置变体的细节。

请考虑以下标记:

```html
<div class="sc-Item_Header sc-Item_Header-bg1">
    <!-- Stuff -->
</div>

```

这里我们将使用`sc-Item_Header`为元素设置通用样式，然后使用`sc-Item_Header-bg1`为变体设置特定样式。这种方法没有什么革命性的，我只是在这里记录它，以表明 ECSS 方法中没有任何东西排除这种做法。

# 总结

这一章我们已经讨论了很多细节。我们研究的两个主要领域是如何组织我们项目的语言文件，以便它们可以更容易地维护，以及如何在 ECSS 中命名 HTML 类/CSS 选择器，以便 DOM 中元素的类可以告诉我们关于它的来源、目的和预期上下文所需的一切。我们还详细了解了 ECSS 选择器的公认语法:在哪里以及如何应用大小写差异来描述选择器的不同部分。到目前为止，我们只关注静态元素。在下一章中，我们将了解 ECSS 如何处理网站或应用状态的变化。**