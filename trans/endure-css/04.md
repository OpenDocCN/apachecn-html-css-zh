# 第四章。介绍 ECSS 方法

在最后一章中，我们考虑了现有的 CSS 方法，以及对于您卑微的作者的需求，它们的不足之处。

我不会试图让你相信持久 CSS 方法是阿尔法*和欧米茄*。然而，与现有方法相比，它确实有不同的优势和目标。因此，即使批发没有吸引力，我也希望你能借些东西来解决自己的问题。

ECSS 的亮点:

*   它通过隔离每个视觉模式来获得可维护性
*   文件大小在很长一段时间内保持最小，因为您可以不受惩罚地剪切出部分/特征/组件
*   规则是*自我隔离*
*   类名/选择器可以传递上下文、原始逻辑和变体
*   所有的规则、它们的效果和影响范围都是完全可以预测的

当我第一次写《忍受 CSS》时，我以为会有某种反弹。当时(2014 年 8 月)，没有人真正提倡我的建议。扩展 CSS 的公认智慧是抽象视觉模式，尽可能标准化设计，并干燥代码。*持久的 CSS* 在某些方面是这些信念的对立面。

在本章中，我们不会讨论 ECSS 的具体技术细节，例如命名约定、工具、创作和组织。我们将在以后的章节中详细介绍这些主题。相反，我们将着眼于该方法与其他方法相比的广泛目标和好处。

### 注

如果你不知道首字母缩略词，DRY 代表不要重复自己，这是一个流行的编码目标，这样逻辑在一个代码库中只写一次，以提供单一的真理来源。

在我们开始之前，我认为澄清将要使用的术语可能会有所帮助。用于定义页面可视部分的术语以不同的方式被称为不同的名称。我的建议和我使用的术语没有任何启示性，重要的是，在我们进入这个话题之前，我们都在同一个页面上。

# 定义术语

我使用术语*模块*来指定一个功能区域和/或创建它的代码。举例来说，网站的标题可以被认为是一个模块。标题模块又将由其他更小的功能组成。例如，下拉菜单或搜索框。这些嵌套的功能将被定义为组件。最后，我们最小的*项*将是组成组件或模块的子节点。

所以，重申一下:

*   一个**模块**是最宽的、视觉上可识别的、独立的功能部分
*   **组件**是模块中包含的嵌套功能
*   **子节点**是组成组件的各个部分(通常是 DOM 中的节点)

为了简洁，接下来，当我提到模块时，它可以是一个模块或组件。从 ECSS 创作的角度来看，这种差异并不重要。

# 【ECSS 解决的问题

我使用 ECSS 的主要目标是隔离风格，而不是抽象它们。

通常，创建作为公共功能抽象的 CSS 类是有意义的。这样做的好处是，它们可以重复使用，并重新应用于许多不同的元素。原则上这听起来足够了。问题是，在更大、更复杂的用户界面上，不可能对这些抽象进行哪怕是很小的调整和修改，而不会无意中影响到你不想要的东西。

因此，ECSS 的一个指导原则是将样式隔离到预期目标。

根据你的目标，即使以重复为代价，孤立也能给你带来更大的优势；允许可预测的样式和样式的简单解耦。

隔离风格的另一个好处是，可以鼓励设计师带来他们需要制作的任何东西，而不必感觉被现有的视觉模式所阻碍。每个需要编码的新模块都可以是*绿地*。我发现，当从头开始时，我可以比试图从任何数量的模糊抽象中构建设计更快地编写设计。

# 处理特异性

我也想否定围绕特殊性的问题。为此，我采用了广泛使用的方法，坚持所有选择器都使用一个基于类的选择器(或尽可能接近那个理想)。

|   | *如果你有 CSS 问题，我为你感到难过，儿子，我有 99 个问题，但特异性不是一个* |   |
|   | -*[https://twitter.com/benfrain/status/537339394706141184](https://twitter.com/benfrain/status/537339394706141184)T3】* |

此外，结构化的 HTML 元素(伪元素除外)在样式表中永远不会作为类型选择器被引用。此外，在 ECSS 中完全避免了标识选择器。不是因为 ID 选择器本身不好，而是因为我们需要一个选择器实力的公平竞争环境。

*通过简单的覆盖处理对组件的更改*。然而，从创作的角度来看，处理它们的方式使它们易于管理和推理。

假设你有一个元素，如果它在一个特定的容器中，那么它需要有不同的宽度——简单，我们不需要以一种可以发生覆盖的方式严格。我们不需要对特定元素应用修改器。我们可以处理典型的和非常松散的覆盖场景，但是要自信地管理它们。您可以在创作样式表中这样写:

```html
.my-Module_Component {
    width: 100%;
    /* If in the sidebar */
    .sw-Sidebar & {
        width: 50%;
    }
}

```

它会产生这个 CSS:

```html
.my-Module_Component {
  width: 100%;
}

.sw-Sidebar .my-Module_Component {
  width: 50%;
}

```

这似乎是一个微妙的好处。毕竟，通过嵌套覆盖，我们创作的东西可能会有些不同，但是最终的结果是典型的 CSS 基于不同且更具体的选择器获取不同样式的元素。

### 类型

在嵌套上下文中使用&符号来表示父选择器是从*Sass*([http://sass-lang.com/](http://sass-lang.com/))语言中借用的惯例。

然而，通过采用这种方法，从创作的角度来看，我们为每个键选择器创建了一个单一的真实来源。对该键选择器进行更改的所有内容都嵌套在开始的一组大括号中。此外，该键选择器永远不会被定义为整个代码库中的根规则。

### 注

**DRY 的不同解读**

我不相信其他 CSSers 追求并颂扬的 DRY 代码的目标就是我想要的那种 DRY 代码。再解释一下——我不太在乎规则中的重复值和对，这是大多数人关注的焦点。我关心的是键选择器不会在代码库中重复。关键选择器是我唯一的真理来源，这也是我想解决的问题。为此，使用 ECSS，强制执行一个创作约定，防止在项目范围内多次定义键选择器。我们将在[第八章](08.html "Chapter 8. The Ten Commandments of Sane Style Sheets")、*理智样式表的十诫*中更详细地探讨这一点。

## 这是！重要的

如果在特殊情况下，一个超驰装置的存在还不够，我们可以利用`!important`。

你可能会意识到在 CSS 中使用`!important`通常是不被允许的。以下是 MDN 对`!important`的评价:

|   | *当俺！重要的规则用在样式声明上，这个声明覆盖了 CSS 中的任何其他声明，无论它在声明列表中的什么位置。虽然，！重要的与特异性无关，利用！重要的是不好的实践，因为它使调试变得困难，因为你破坏了样式表中的自然级联* |   |
|   | -*[https://developer . Mozilla . org/en-US/docs/Web/CSS/specification](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity)* |

然而，当我们无法控制的事件扰乱了我们的风格(例如，页面上加载了第三方 CSS 文件)并且我们需要一些影响力时，我欣然接受！很重要。这里有一个状态改变的例子，它从接收到一些额外的能量！重要信息:

```html
[aria-expanded="true"] & {
    transform: translate3d(0, -$super-height,
    0)!important;
}

```

老实说，需要的时候使用`!important`真的不会失眠。由于在创作样式表中所有的覆盖都被本地化为它们的父选择器，偶尔使用`!important`在 ECSS 中不会出现问题。

# 拥抱重复

在我们走得更远之前，我认为在房间里对付一只可能的大象很重要。我需要试着让你相信，从维护的角度来看，消除跨文件的属性和值的重复可能买不到像一组可靠且包含的模块那样多的东西，这些模块很容易根据需要从代码库中移除。

ECSS 方法包含 CSS 中属性和值的重复。

使用 ECSS，每个单独的可视模块或组件都用一个微名称空间来编写，以提供与其他模块和组件的隔离。下面是一个创作的 ECSS 规则的典型示例(创作语法与 Sass 非常相似，但通常由 PostCSS 提供便利):

```html
.ip-SubHeader_Wrapper {
    @mixin Headline;
    align-items: center;
    /* We want the subheader hidden by default at the
    smallest sizes */
    display: none;
    font-size: $text12;
    background-color: $color-grey-54;
    border-bottom: 1px solid color($color-grey-54 a(.5));
    min-height: $size-fine-quadruple;
    @media (min-width: $SM) {
        display: inline-block;
    }
    @media (min-width: $M) {
        display: flex;
        background-color: $color-grey-a7;
        color: $color-grey-54;
        font-size: $text13;
        min-height: 1.5rem;
        border-bottom: 1px solid $color-grey-54;
        border-top: 1px solid $color-grey-33;
    }
    /* However, even on mobile, if the SubHeader Wrapper
    is in section 1, we want to see it */
    .ip-Classification_Header-1 & {
        display: flex;
    }
}

```

那些倾向于 OOCSS 和原子 CSS 方法的人可能会看到这一点而不寒而栗。像`color`和`font-size`这样的东西在大多数组件中都有声明。`@mixin Headline` mixin 生成了大量的 CSS 来指定特定的字体堆栈。所以，是的，有重复的属性和值。

然而，积极的一面是:

*   它冗长，但不依赖于风格的继承。
*   它通常是上下文无关的(除了放置它的大小上下文)，任何影响这个组件的媒体查询都在这一组花括号中定义。
*   像这样的键选择器只写一次。当这个键选择器需要改变时，你只需要看这一个地方。
*   编写嵌套了所有覆盖的规则会产生一种微级联。通常覆盖可以在 CSS 中的任何地方，遵循这个方法将它们限制在一个非常特定的区域。当它与规则相关时，对特殊性进行推理就变得容易得多

# 零组件抽象

使用 ECSS，如果需要制造一个与现有组件相似但又有细微差别的组件，我们不会从这个现有组件中抽象或扩展。相反，会写一个新的。

是的，我是认真的。

即使 95%都一样。

这样做的好处是每个组件都是独立和隔离的。一个可以没有另一个而存在。一个人可以独立于另一个人，根据自己的需要改变。尽管它们在一开始就有明显的美学相似性，但它们可以根据需要变异，而不用担心感染或污染任何其他相似外观的组件。为了扩展生物学隐喻，我们已经获得了通过其独特的名称空间进行自我隔离的组件。

### 注

再打个比方:宝马 3 系和宝马 5 系有很多共同点。但是他们不一样。它们可能共享一些/许多部分(相当于 CSS 属性和值的组合)，但这并不能使它们相同。他们的不同定义了他们。它们不可能由完全相同的部分组成，因为它们本身有一些不同之处。我认为用 ECSS 定义的模块和组件也是如此。CSS 语言是抽象的。CSS 的属性/值对已经意味着我们可以从单个部分构建我们想要的东西。

# 复读的成本？

为了充分获得 ECSS 的好处，您需要对它所创造的属性和价值重复感到舒适。在这一点上，你可能会相信我被欺骗了。有了所有这些重复，ECSS 方法怎么可能是一个可行的选择？我将用一个词来解决这个问题:gzip。

好吧，我撒谎了。我想进一步证明这一点。

## gzip 在压缩重复字符串方面非常高效

我很好奇像 ECSS 这样的方法中重复的属性/值对在真实世界中有什么不同？一个实验:

我正在处理的一个基于 ECSS 的项目的最终 CSS 文件是 42.9 KB。这是一个很大的 CSS 文件。

可以从这个样式表抽象到一个 OOCSS 类的最常见和最冗长的模式是一对基于 Flex 的规则，它们被大量使用来将内容垂直地集中在它们的容器中。由于*Autoprefixer*([https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer))添加了大量代码来支持旧设备，它们甚至更加冗长。例如，定义灵活布局的结果 CSS 是:

```html
.flex {
    display: -webkit-box;
    display: -webkit-flex;
    display: -ms-flexbox;
    display: flex;
}

```

在测试样式表中，这四行 CSS 被重复 **193** 次。

那只是一半。其中许多项目也需要调整。这在 CSS 中也需要:

```html
.flex-center {
    -webkit-box-align: center;
    -webkit-align-items: center;
    -ms-flex-align: center;
    align-items: center;
}

```

该模块重复 **117 次**。似乎没有比抽象到 OOCSS 类更好的理由了，对吗？那一定会引起严重的腹胀吧？

别这么快，蝙蝠侠！

如果删除这些代码块并压缩文件，CSS 文件的大小将降至 41.9 KB。

将最常见和最冗长的视觉模式提取到一个 OOCSS 类中，通过网络只节省了 1 KB 的 CSS。尽管在 CSS 中只节省了 1 KB，但考虑到如果将这些样式抽象为单一责任类(例如`.flex`和`.flex-center`，也有必要将 HTML 与相关的 OOCSS 类放在一起以获得视觉效果。

这使得单一责任类值得吗？

从文件大小的角度来看，没有任何其他属性组合有这样的冗长和重复，在我的书中肯定没有。为了稍微节省 CSS 文件的大小，这将花费大量的开发灵活性(记住抽象会使创作和迭代变慢，因为这是更改模板和 CSS 所必需的)和响应灵活性(如果我想让这个东西在不同的视口中做一些不同的事情，该怎么办)。这就相当于*拆东墙补西墙*的 CSS。

让我说清楚。尽管 gzip 很有效，但如果您的优先考虑是尽可能减小 CSS 文件的大小，那么 e CSS 并不是您的最佳选择。

相反，去看看*原子 CSS*([http://acss.io/](http://acss.io/))。它的创造者都是聪明人，事实上，*蒂埃里·科布伦茨*([http://www.cssmojo.com/](http://www.cssmojo.com/))是我所知道的最聪明的 CSSers 之一。我相信 ACSS 会很好地满足您的需求。

另一方面，ECSS 的优先考虑是开发人员人机工程学(可理解的类命名约定)、易维护性(按组件组织的样式和易于删除的样式)和样式封装(名称间距防止抽象泄漏)。

不同的问题，不同的解决方案。

# 总结

我希望我已经给了您足够的时间来考虑，如果您试图创建可维护的样式表，那么纠结于重复的属性值和属性对可能不是对您时间的最好利用。在下一章中，除了查看 ECSS 命名约定的好处之外，我还将讨论一种健全的项目维护组织方法，从长远来看，它将产生比类抽象和重用更精简的样式表。