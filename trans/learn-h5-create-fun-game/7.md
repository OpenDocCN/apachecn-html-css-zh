# 第七章。HTML5 与手机游戏开发

在这最后一章中，我们将了解一个非常重要的概念，它不仅是为多种浏览器和平台开发，而且是在考虑多种设备的情况下开发应用程序。过去，网络开发主要是支持多种浏览器。然后，它就变成了利用现有的最新技术，创建类似于本机桌面应用程序的应用程序。今天，我们不仅要记住那些允许我们让尽可能多的人使用我们的应用程序的相同概念，而且我们还必须记住，标准台式计算机不是访问我们的网络应用程序的唯一机器。

在创建基于 HTML5 的游戏或应用程序时，我们必须能够想象我们的用户通过台式计算机、电子书、HTML5 就绪的视频游戏系统、智能手机、桌子、电视机，以及很快他们的智能手表、智能眼镜，可能还有他们的智能烤面包机、鱼缸等进行连接。不用说，除了尺寸、形状和建议零售价之外，这些设备之间还有很多不同之处。

在我们开发本书的最后一款游戏时，让我们来看看与 HTML5 开发移动游戏相关的一些最重要的概念。我们将首先看看台式机和移动设备(具体来说，智能手机和平板电脑)之间的根本区别。本章中讨论的两个与 HTML5 相关的 API 是媒体查询(允许我们根据查看应用程序的设备的当前状态来调整 CSS 属性)和 JavaScript 触摸事件，以及它们对应的事件处理程序。最后，我们将在这一章的最后讨论如何使用单一代码库为桌面浏览器和移动设备开发和优化游戏。

# 桌面与移动

乍一看，粗心的网络开发人员可能会相信，因为今天的许多智能手机实际上比大多数五年级学生聪明得多，所以他们花哨的网络应用程序和游戏在移动设备上运行良好。不要被欺骗！虽然你的智能手机确实比你五年级时更聪明(事实上，今天大多数不那么智能的手机拥有的计算机能力超过了美国宇航局在 1969 年将尼尔·阿姆斯特朗、迈克尔·柯林斯和埃德温·奥尔德林带到月球的硬件)，但在许多情况下，它与大多数人上网和玩在线游戏的普通台式计算机不匹配。

桌面浏览器和移动浏览器之间有几个显著的区别。为此，我们需要在开发应用程序时考虑这些差异。毕竟，无论有多少人严格地通过移动设备或桌面浏览器使用互联网，我们都没有理由将我们的覆盖范围仅限于其中一个群体。

我们必须记住的移动友好开发的一个关键方面并不总是适用于游戏，那就是一个人的移动策略通常与桌面策略有着内在的不同，原因超出了硬件限制和差异。例如，移动设备上的用例与桌面版日志应用程序上的用例有很大不同。由于在小设备上打字要困难得多，速度也慢得多，用户不太可能花几个小时在手机应用程序上键入日记条目，而在桌面应用程序上，则可以使用全尺寸键盘。因此，必须从不同的角度来考虑整个移动体验。

最后，因为移动设备中的人机交互不同，所以应用程序的呈现必须考虑这些特征。例如，在浏览网站时，大多数人会慷慨地在屏幕上移动鼠标光标，试图发现哪些内容可以点击，哪些内容可以交互。每当一个动作元素被悬停时，鼠标指针改变(通常从箭头图标变为指向的食指)，提示用户可以通过点击这样的项目来启动动作。然而，在移动设备上，并不存在这样的东西。因此，设计必须考虑到这一点，这样用户就不会困惑、害怕，或者更糟糕的是，对使用你的游戏或应用程序犹豫不决。

本节的其余部分将介绍您的移动战略的一些主要实施注意事项以及一些当前的最佳实践。这两个部分同样适用于移动游戏和移动应用程序(即非游戏应用程序)。尽管这份考虑事项和最佳实践的清单并不广泛，但它应该足以让你朝着正确的方向思考，并为成功的移动营销活动指明方向。

## 主要实施注意事项

移动设备与台式电脑最大的区别可能是移动设备总是可访问的。一旦用户离开他或她的房子，台式计算机就被停放，直到可能许多小时后。另一方面，移动设备可以离用户像他或她的口袋一样远。因此，用户可以随时拔出移动设备，开始玩你的游戏或使用你的应用程序。

非常重要的是，这种始终可访问的用例的一个延续是，用户将在很短的时间内玩你的游戏——在等电梯的时候，在商店排队的时候，或者在第一次约会中试图掩盖尴尬时刻的时候。因此，你的游戏必须适应这些短暂的，非常短暂的游戏时间，并且它必须以这样一种方式进行，即玩家在一次玩 30 到 120 秒的游戏时仍然可以在游戏中取得进步。

您的移动游戏的一些重要考虑因素与移动设备的物理特性更为相关，包括其有限的屏幕尺寸、轻松改变屏幕方向的可能性、有限的计算能力(当然相对于台式计算机)、有限的电池电量以及浏览器差异(不，这些在移动设备上也没有消失)。

### 屏幕尺寸和方向

台式电脑和移动设备最明显的区别是尺寸。尽管大多数现代设备可以模拟大屏幕分辨率，但物理屏幕尺寸仍然相当有限。不仅如此，用户还可以随时侧向旋转设备，期待应用程序的某种响应反馈。

在一般的网页设计中，解决屏幕尺寸变小和变化的标准方法是一种叫做响应设计的技术。今天用来实现响应设计的主要工具是新的 CSS 媒体查询 API (我们将在本章后面讨论)。简而言之，这个应用编程接口允许我们根据屏幕大小、比例和方向加载不同的样式表或 CSS 规则集。

例如，我们可以为屏幕宽于屏幕高的情况定义一个 CSS 样式表(根据定义，这将使其成为横向视口)，并为屏幕高于屏幕宽的情况设计第二个样式表(使其成为纵向视图)。媒体查询将允许我们根据当前屏幕状态自动动态加载这两个样式表中的一个。也就是说，如果用户手动调整浏览器窗口的大小，样式表将实时触发。

至于屏幕方向的改变，基于 DOM 的 web 应用程序更容易，因为浏览器本身如果能够旋转一切，那么它面对的方向是正确的。在基于画布的应用程序(2D 画布或 WebGL)中，屏幕旋转也会旋转浏览器的坐标系，但不会旋转画布。因此，如果你想让一个特定的游戏水平地在风景视图上玩，垂直地在肖像视图上玩，你需要手工管理画布坐标系的旋转。

最重要的是，然而，事实是，当设计一个移动友好的，或者一个游戏的移动版本时，屏幕尺寸会明显变小。这意味着更少的元素可以被塞进一个特定的视图。需要呈现的信息更少，因为可以一次传递的信息更少。

这个问题的两个常见解决方案是开发一个具有两个独立表示层(或两个独立视图或模板)的应用程序，只提供适合请求它的设备的视图(当模板访问应用程序时提供移动模板，当桌面浏览器请求应用程序时提供完整模板)和开发一个具有单个模板的单个应用程序，但使该模板具有响应性，如前所述。不太受欢迎的选择是一起开发两个独立的应用程序，其中每个应用程序都专注于一个给定的范例(移动和桌面)。

通常，移动模板是完整模板的缩小版本，并非所有元素都必须显示，如下图所示:

![Screen size and orientation](graphics/6029OT_08_01.jpg)

### 计算能力

如前所述，如今的移动设备已经变得相当强大。更令人惊讶的是，这种趋势正在持续改善，将更多的计算能力塞进更少的物理空间。然而，今天最好的智能手机甚至比不上一台普通的游戏电脑。对于大多数 web 应用程序来说，这种差异通常可以忽略不计，但对于更复杂的游戏来说肯定不会。

在这方面，移动设备相对于台式计算机的一个具体缺点是，与低端台式计算机和普通计算机相比，低端移动设备和普通移动设备之间的计算能力差距相当大。因此，当考虑你的游戏用户的能力时，记住大量的玩家将拥有非常有限的设备。

### 电池寿命

信不信由你，智能手机最常用的功能就是打电话和接电话。由于如此重要的功能是移动设备的主要用途，因此阻止设备执行此类任务将是非常悲惨的，因为游戏会耗尽设备的所有电池电量。由于这个原因，移动应用程序(包括游戏和移动网络应用程序)的一个非常重要的特征是它节能的程度。

应用程序需要处理的数据越多，处理所需的电力就越多。如果游戏花费大量时间执行复杂的计算，它很可能会比人们希望的更快耗尽设备的电池。您的移动游戏必须使用尽可能少的电量，以便玩家可以尽可能多地享受游戏，同时仍然节省足够的电池电量，以便设备可以服务于其最基本的目的——打电话。

### 浏览器差异

如果你认为一旦你开始将你的网络开发工作集中在移动设备上，你的浏览器兼容性问题就会消失，请再想想。不仅各种移动浏览器本身存在差异(就像它们的桌面版本存在差异一样)，而且给定桌面浏览器上可用的每个 HTML5 API 和功能也不一定在同一浏览器的移动版本上可用。

一些功能实际上在移动浏览器上是可用的，但是性能离被接受还有很长的路要走。我们将在本章开发的游戏中看到的一个简单的例子是 CSS 动画。根据您对动画的创意程度，移动浏览器可能很难处理动画，而在桌面浏览器上，流畅一致地显示动画所需的计算和渲染能力非常微不足道。

总之，在定义您的移动应用程序的具体实现方式时，请记住，一些应用程序接口和特性将不得不被丢弃，以免应用程序以不可接受的水平运行。

### 最佳实践

既然您已经准备好接受刚才讨论的理论，让我们讨论一些如何做到这一点的最佳实践。虽然一本完整的书可以专门介绍这个主题，但下面的选择涵盖了我认为移动 web 开发最重要的五个最佳实践。同样，这些概念适用于一般的网络应用程序以及游戏。

### 优雅地降解并逐渐增强

直到几年前，任何关于向 web 应用程序添加新的尖端功能的讨论都是围绕着优雅降级这个主题展开的。最近，这种意识形态更多地转向了另一端，即构建多平台和多设备应用程序的建议方式是渐进式增强。

在这种情况下，优雅的降级是指首先构建完整的应用程序(最新和最棒的桌面浏览器)，然后将其缩小，以便它可以在功能较弱的浏览器和移动设备上工作。同样，渐进式增强是指首先构建应用程序的移动版本，然后使其在桌面浏览器上工作。无论采用哪种方法，最终结果都是一样的——一个应用程序在两个平台上运行得一样好。

虽然这两种方法可以说得很多，但实际上没有一种比另一种更好。唯一的区别只是你从哪里开始。希望这个应用程序已经被很好地计划好了，这样在构建开始之前每个版本都已经被设想好了，这样在任一端开始都会把应用程序带到同一个地方。然而，通常情况下，理想的方法很大程度上取决于所讨论的项目类型。

在大多数游戏中，就像为本章构建的 2D 太空射击游戏一样，首先开发桌面版本，然后删除移动设备不支持或不适合的任何功能要容易得多。

比如我们游戏的主渲染循环就是基于新的`requestAnimationFrame`功能。现在，还不是所有的浏览器都公开这个功能，而其他浏览器通过不同的界面公开它。优雅地降级这个功能意味着在可用的地方使用函数，在不可用的地方使用回退。

```
window.requestAnimationFrame = (function() {

  // Check if the unprefixed version is present
  if (window.requestAnimationFrame) {
    return window.requestAnimationFrame;
  }

  // Check for WebKit based implementation
  if (window.webkitRequestAnimationFrame) {
    return window.webkitRequestAnimationFrame;
  }

  // Check for Mozilla based implementation
  if (window.mozRequestAnimationFrame) {
    return window.mozRequestAnimationFrame;
  }

  // Check for Microsoft based implementation
  if (window.msRequestAnimationFrame) {
    return window.msRequestAnimationFrame;
  }

  // Check for Opera based implementation
  if (window.oRequestAnimationFrame) {
    return window.oRequestAnimationFrame;
  }

  // If nothing else, simulate the functionality with
  // something similar - a custom timer
  return function(callback) {
    var fps = 1000 / 60;
    var timestamp = Date.now();

    setTimeout(function(){
      callback(timestamp);
    }, fps);
  };
})();
```

另一方面，渐进式增强方法将首先从最小公分母开始，不承诺给任何人任何特殊的铃声和口哨声，而是在客户端技术允许的情况下添加这些铃声和口哨声。

例如，假设我们想广泛使用 CSS 动画。具体来说，我们希望使用一个非常大的图像作为背景，然后使用关键帧动画不断地设置其位置和大小。在移动设备上，这可能会消耗大量处理能力，导致严重的性能问题。因此，我们决定在这种情况下不使用这些动画。

在这种情况下，逐步增强应用程序意味着我们从背景的静态图像开始。默认情况下，不会加载定义动画并将其应用于应用程序的 CSS 文件。

```
// ---------------------------------
// Default Stylesheet: style.css
// ---------------------------------
.background-img {
  background: url("/img/bg.png");
}

// ---------------------------------
// HTML Template: template.html
// ---------------------------------
<div id="container" class="background-img"></div>
```

一旦最低的功能到位，我们就可以测试环境，以确定是否应该加载 CSS 文件，注入更健壮的功能。

```
// ---------------------------------
// Enhanced Stylesheet: enhanced.css
// ---------------------------------

@-webkit-keyframes animagedBg {
  from {
    background-position: 0 0;
  }
  to {
    background-position: 1300% 600%;
  }
}

.anim-background {
  -webkit-animation: animagedBg;
  -webkit-animation-duration: 500s;
  -webkit-animation-timing-function: linear;
  -webkit-animation-iteration-count: infinite;
}

// ---------------------------------
// JavaScript Detection: main.js
// ---------------------------------

// Returns true if the browser is mobile
function isMobile(userAgent) {
  var mobileAgents = [
    "ANDROID",
    "BLACKBERRY",
    "IPHONE",
    "IPAD",
    "IPHONE",
    "OPERA MINI",
    "IEMOBILE"
  ];

  return mobileAgents.indexOf(userAgent.toUpperCase()) >= 0;
}

var mobile = isMobile(navigator.userAgent);

// If the browser is not mobile, add enhanced CSS functionality
if (!mobile) {
  var container = document.querySelector("#container");
  container.classList.add("anim-background");
}
```

现在，首先用动画背景构建游戏，然后在检测到特定设备时移除它并不是特别困难。采用这种方法也不一定会有任何附加价值。

总之，无论哪种方法对您的具体应用和设计目标更有意义，关键原则是牢记用户体验。永远不要向游戏或应用程序的用户展示不可用的产品或功能。要么将该功能降级为有用的功能，要么在您确定用户环境可以正确使用该功能时对其进行升级。

### 手指友好型设计

另一个非常重要的设计考虑是各种元素的大小，这一点很容易被忽视。虽然让文本足够大很重要，但这更容易理解。此外，文本大小很容易动态调整，因此用户可以调整内容，直到他们适应应用程序中文本的确切大小。然而，从点击世界来看，如果鼠标指针能放在上面，动作目标就足够大，我们可能没有意识到不同的人有着截然不同的手指尺寸。对于大手指用户来说，没有什么比因为点击目标太小而错过目标更令人沮丧的了。几年前，当第一个触敏移动应用程序问世时，用户可能会考虑在设备中携带一个卷笔刀，这样就可以触及这些微小的触摸目标。

在下图中，左侧的屏幕截图是用户触摸不到的太小项目以及靠得太近的项目的示例。更好的解决方案，如右边截图所示，让界面更宽容，用户更难搞砸。

![Finger-friendly design](graphics/6029OT_08_02.jpg)

如果你看看各种移动平台制造商发布的开发者指南，你会发现特定的像素尺寸被建议为可以触摸的小部件的最小尺寸以及两个或多个可触摸元素之间的最小距离。虽然没有任何特定小部件的完美尺寸，但我们在设计时必须始终牢记这个问题。

### 节省电池寿命

不管你的手机游戏有多神奇，当用户意识到游戏对他们设备的电池有粗暴要求的那一分钟，游戏就会立刻被皱眉头。如果用户电量不足，但他们知道你的游戏对功耗非常友好，你的应用肯定会得到额外的喜爱。

现在，移动应用程序能效低下的主要原因是大量不必要的硬件使用。例如，如果一个应用程序每秒多次拉动全球定位系统，它可能会很快耗尽电池。然而，在 HTML5 应用程序中，直接硬件访问并不容易实现。

对于 web 应用程序，节省能量的主要方法是尽可能多地进行缓存。这里缓存的要点是避免额外的网络活动。额外的处理不仅需要更多的能量，还会迫使用户花费通常有限的带宽。作为一个额外的好处，缓存还会使您的应用程序运行得更快。

### 计划下线

如今，大量的移动游戏玩家只能通过他们的移动设备进行有限的互联网访问。对用户来说，额外使用这些宝贵的数据计划可能是一笔昂贵的交易。因此，许多用户主动禁用他们设备上的互联网接入。因此，你永远不要假设你的游戏可以持续访问互联网。

同样，这个用例的最佳解决方案是使用对您有利的缓存。首先，通过减少服务器往返，即使每批都更大，您也可以节省用户试图节省的昂贵带宽。其次，如果在应用程序没有做任何有意义的事情(例如显示与游戏相关的消息或等待用户输入信息)时，将 HTTP 请求保存一会儿，应用程序看起来会更快、响应更快。

### 提供桌面版

用户可能想要签出移动应用的非移动版本的原因有很多。也许是因为功能缺失，也许用户有一个足够好的移动设备，实际上可以很好地处理完整版本，或者也许用户只是出于好奇想从移动设备访问完整版本。不管是什么原因，添加一个链接到你的应用程序的全尺寸版本可能是你能做的最简单的事情，所以为什么不为可能真正使用它的少数用户做这件事呢！

# 了解媒体查询

媒体查询从 HTML4 和 CSS2 开始就有了。最初，CSS 媒体属性用于根据加载页面的媒体类型(如屏幕、电视、投影或手持设备)指定要加载的不同样式表。在 HTML5 中，媒体查询还允许表达式检查查看文档的用户代理的其他属性，如视口宽度、高度、分辨率等。

一个**媒体查询**由两部分组成，即一个媒体类型声明和一个或多个评估为真或假的表达式。每当任何媒体查询表达式评估为真时，都会应用嵌套在媒体查询声明中的任何 CSS 规则。或者，由链接标签引用的样式表中的每个 CSS 规则，其媒体属性包含一个 **truthy** 媒体查询表达式应用于指定的媒体类型。

```
// ---------------------------------
// Media queries on the HTML file
// ---------------------------------
<link rel="stylesheet"
  media="screen and (min-device-width: 960px)"
  href="default-style.css" />

// ---------------------------------
// Media queries within a CSS file
// ---------------------------------
@media screen and (min-device-width: 960px) {
  html, body {
    margin: 0;
    padding: 0;
  }

  /* ... */
}
```

### 注

根据规范，当浏览器环境发生变化时，浏览器应该(但不是必须)继续评估媒体查询中的表达式并更新 CSS 规则。换句话说，如果在一个页面中指定了两个媒体查询——一个用于宽度小于某个大小的窗口，另一个用于宽度大于该值的窗口——如果用户手动调整浏览器宽度而不刷新页面，则浏览器不需要加载相应的样式表。然而，因为这不是一个非常常见的用例，所以它不应该是 web 设计者非常关心的问题。此外，大多数现代浏览器事实上确实实时地重新评估媒体查询表达式。

有九种媒体类型可以从媒体查询中指定和定位。或者，关键字`all` 可以用来表示所有的媒体类型。 CSS 媒体类型中允许的媒体类型如下:

*   `braille`:用于盲文触觉反馈装置
*   `handheld`:用于手持设备
*   `print`:用于打印机的
*   `projection`:用于投影仪的
*   `screen`:用于电脑屏幕的
*   `tty`:用于使用固定间距字符网格的媒体
*   `tv`:用于电视的
*   `embossed`:用于分页盲文打印机
*   `speech`:用于语音合成器的

可用于连接两个或多个表达式的两个运算符是逻辑运算符`AND`和 `OR`，分别由`and`关键字和一个`comma`字符表示。此外，逻辑`NOT`运算符可用于否定表达式。该运算符由`not`关键字表示。

```
// Applies media queries to:
// viewport width between [200px, 450px] OR wider than orequals to 1200px
@media
  all and (min-width: 200px) and (max-width: 450px),
  (min-width: 1200px) {
  /* ... */
}

// Applies media queries to:
// non-printer viewport width between [200px, 450px]
// OR any media type wider than or equal to 1200px
@media
  not print and (min-width: 200px) and (max-width: 450px),
  all (min-width: 1200px) {
  /* ... */
}
```

可以在媒体查询表达式中检查的 13 个值是宽度、高度、设备宽度、设备高度、方向、纵横比、设备纵横比、颜色、颜色索引、单色、分辨率、扫描和网格。只要表达式有意义，这些值的任何组合都可以用在表达式中。这是一些基本的布尔逻辑和一些常识派上用场的时候。

最后，可以与每个表达式一起使用的单位与 CSS 单位相同。我们可以使用固定单位(如像素、厘米或英寸)或相对单位(如百分比或 ems)。作为复习，以下列表描述了 CSS 中可能使用的单位，因此，在媒体查询表达式中:

*   `%`:百分比
*   `in`:英寸
*   `cm`:厘米
*   `mm`:毫米
*   `em` : em (1 em =当前字体大小的高度)
*   `ex` : ex (1 ex =字体高度)
*   `pt`:点(1 点= 1/72 英寸)
*   `pc` : pica (1 pica = 12 点)
*   `px`CSS 像素

本部分的其余部分将包含媒体查询中使用的每个有效值的更详细解释，以及每个有效值的示例。

## 宽度

当针对连续媒体类型查询时，该值是指设备的总视口(可见窗口区域)宽度，包括任何渲染的滚动条。当查询分页媒体类型时，总宽度是输出页面的宽度。

或者，前缀`min`和`max`可以与`width`关键字一起使用，允许我们指定范围，而不是离散值。

```
@media all and (min-width: 250px) {
  body {
    background: red;
  }
}

@media all and (max-width: 249px) {
  body {
    background: blue;
  }
}
```

前面的截图指定了两个适用于所有媒体类型的媒体查询。当输出宽度小于 250(不包括)时，背景颜色设置为蓝色。否则，背景颜色变成红色。与大多数现代浏览器一样，我们可以手动调整浏览器窗口的大小，新的 CSS 规则将自动应用。否则，属性将在浏览器第一次呈现页面时进行测试和设置。

在下图中，左侧的窗口不够宽，不足以触发对前一个片段的第一个媒体查询，这将导致第二个片段评估为真。通过简单地调整浏览器窗口的大小(可以通过最大化浏览器或可能通过简单地将移动设备转到横向模式来实现)，第二个媒体查询将被无效，第一个将被启用。

![width](graphics/6029OT_08_03.jpg)

请注意，在之前的媒体查询评估中使用的单位是 CSS 像素。当为像素不太容易应用的媒体类型设置特殊规则时，我们可以使用其他单位，如`in`(英寸)或`cm`(厘米)，如下例所示:

```
@media print and (min-width: 7.0in) {
  h1 {
    color: red;
  }
}

@media print and (max-width: 6.5in) {
  h1 {
    color: blue;
  }
}
```

之前的代码片段的输出可以在下面的截图中看到。注意所讨论的最小和最大宽度不一定是进行打印的页面的宽度，而是纸张宽度减去打印机设置的任何边距所形成的盒子的宽度。在这种情况下，一张 8.5 英寸宽的纸，从左右页边距减去一英寸，在纵向模式下的有效宽度为 6.5 英寸。同一页面的横向版本为 11 英寸宽，产生 9 英寸的框宽，该宽度足以触发第一个媒体查询。

下面屏幕截图上的顶部打印预览代表以纵向模式打印的页面。也就是说，它的宽度(在这种情况下)不超过 6.5 英寸。底部的预览宽于 7.0 英寸，这将导致启用不同的媒体查询，从而更改要打印的页面的样式表设置。

![width](graphics/6029OT_08_04.jpg)

## 身高

与`width`属性类似，`height`属性是指连续媒体类型的视口高度，包括渲染的滚动条。对于分页媒体类型，这是指输出媒体可用的有效页面框。不用说，高度属性的值不能是负单位。同样，就像前面描述的`width`属性一样，我们也可以向该属性添加修饰符前缀`min`和`max`，以便指定值的范围，而不是单位完美的单个值。

```
@media all and (min-height: 500px) {
  article {
    width: 100%;
    float: none;
  }
}

@media all and (max-height: 499px) {
  article {
    width: 33%;
    float: left;
  }
}
```

## 器件宽度

类似于`width`属性，设备宽度指的是整个物理窗口或页面，而不管当前浏览器窗口的宽度或分页媒体的可用输出宽度。

```
@media all and (min-device-width: 1601px) {
  h1 {
    color: red;
  }
}

@media all and (max-device-width: 1599px) {
  h1 {
    color: green;
  }
}

@media all and (device-width: 1600px) {
  h1 {
    color: blue;
  }
}
```

在前面的代码示例中，如果屏幕宽度(而不是浏览器宽度)正好为 1600px，则无论浏览器如何调整大小，最后一个媒体查询都将处于活动状态。页面也是如此——如果页面的整个宽度精确到 1600px 宽，相应的媒体查询将匹配。任何比这更多或更少的内容以及另外两个媒体查询中的一个将被使用。同样，关键字`min`和`max`是我们可以结合该属性使用的有效修饰符。

关于何时选择设备宽度或宽度(反之亦然)的问题，答案很简单:只要应用程序的设计需要。大多数情况下，最终结果是一样的。只有当宽度比设备宽度更合适时，用户才可能使用定制大小(非最大化)的浏览器窗口，并且设计旨在重排和自动调整到浏览器的当前宽度。另一方面，如果无论当前浏览器状态如何，某个设计都要在某个显示器宽度(或宽度范围)上保持不变，那么设备宽度可能是更优雅、更有效的方法。

## 装置高度

最后，最后一种可能性是查询显示器的矩形边，设备高度与设备宽度完全相同(除了测量的尺寸)。虽然到目前为止描述的其他视口查询也可以获得相同的结果，但是在到目前为止描述的四个查询中，设备高度可能是识别移动方向(纵向或横向)的理想候选(与设备宽度一起)。

## 方位

由于媒体查询不允许对两个属性进行比较(例如，如果宽度大于或等于高度)，方向允许我们确定媒体类型的旋转方向。如果 CSS 媒体查询引擎中包含了比较运算符，我们就可以轻松确定页面是否处于横向模式。为此，我们只需要确定宽度是否大于高度。如果两个边的长度相同(正方形视口)，则规范会确定媒体处于纵向模式。然而，由于这种方法不能直接用于媒体查询，我们可以使用更直观的方向属性。

该属性的两个可能值是`portrait`和`landscape`，这并不奇怪。这个查询不允许使用前缀`min`和`max`，因为将某些东西分类为至少是风景或者仅仅是肖像是没有意义的。

```
@media all and (orientation: portrait) {
  body {
    backgroundcolor: red;
  }
}

@media all and (orientation: landscape) {
  body {
    backgroundcolor: green;
  }
}

@media all and
  not (orientation: portrait) and
  not (orientation: portrait) {
  body {
    backgroundcolor: blue;
  }
}
```

在前面的示例中，我们检查媒体是横向还是纵向。无论方向如何，媒体查询都会被激活。请注意，第三个查询试图基于错误的结论设置第三个方向。人们可能会想象，确定某个东西是横向还是纵向的方法是取两者之间的比率——如果宽度大于高度，则媒体处于横向模式，否则媒体处于纵向模式。你可以想象一下，如果两边(宽度和高度)相同，有人会如何断定方向既不是横向也不是纵向。然而，重要的是要记住，一个正方形的人物不是风景，而是肖像。关键是要记住，这个属性只有两种可能的值，这正是因为一个媒体一次只能处于两种可能的状态。

## 长宽比

纵横比属性允许我们检查媒体的宽度相对于其高度的比例(按此顺序)。该属性考虑了`width`和`height`媒体查询值之间的实际比率，这意味着视口宽度和高度的动态变化会直接影响该属性。`min`和`max`关键词可用于该属性的评估。

```
// Aspect ratio is exactly twice as high as wide
@media all and (aspect-ratio: 1/2) {
  h1 {
    color: blue;
    font-size: 1.0em;
  }
}

// Aspect ratio is at least three times as high as wide
@media all and (min-aspect-ratio: 1/3) {
  h1 {
    color: red;
    font-size: 0.5em;
  }
}

// Aspect ratio is no more than four times as wide as high
@media all and (max-aspect-ratio: 4/1) {
  h1 {
    color: green;
    font-size: 3.0em;
  }
}

// Aspect ratio is an exact square
@media all and (aspect-ratio: 1/1) {
  h1 {
    color: yellow;
    font-size: 2.0em;
  }
}

// Aspect ratio is no more than half as high as wide – ERROR!
@media all and (max-aspect-ratio: 1/0.5) {
  h1 {
    color: green;
    font-size: 3.0em;
  }
}
```

之前的代码片段演示了计算长宽比的各种方法。请记住，该属性的值必须始终读取为单个分数，不包含浮点数。简单地说，值必须是整数形式，后跟一个斜杠，后跟第二个整数。第一个整数表示宽度值，第二个整数表示高度值。它们一起形成一个比率。

上一个示例中的第一个媒体查询测试的视口是每一个宽度单位正好有两个宽度单位。换句话说，该表达式检查的视口是高的两倍还是宽的一半。相比之下，最后一个媒体查询尝试生成相同的结果，但方向相反。试图查询一种宽度至多是其高度两倍的媒体类型。该表达式将引发静默表达式(该表达式将被忽略)，因为格式不合适。正确的方法不是检查 1/0.5，而是将其设为 2/1，使宽度长度是高度的两倍。

为媒体查询纵横比表达式指定所需值时，左边的数字指的是相对于高度的宽度，由右边的值表示。两个数字都必须是正整数，两个值中较大的一个可以在任意一边。或者，两个值可以相同，这将测试正方形纵横比(1/1)。

![aspect-ratio](graphics/6029OT_08_05.jpg)

## 器件纵横比

检查器件宽高比的工作方式与前面解释的宽高比完全相同，唯一的区别是`width`和`height`参考是基于器件宽度和器件高度的，如它们各自章节中所解释的。

同样，与设备宽度和设备高度一样，这是检查访问应用程序的设备的底层指纹的好方法，它与测试媒体查询时浏览器窗口的当前状态无关。就响应用户动作而言，测试宽高比可能是比设备宽高比更好的解决方案，因为用户可以独立于设备屏幕比改变浏览器窗口的尺寸。然而，为了确定设备的真实纵横比，另一种方法是使用设备纵横比。

此外，请记住，在查询纵横比时，很有可能定义冗余的媒体查询。在这样的情况下，就像 CSS 的情况一样，最后一个匹配表达式会覆盖之前重复的表达式和值。

```
// Aspect ratio evaluates to 1/1
@media all and (device-aspect-ratio: 1/1) {
  h1 {
    color: blue;
    font-size: 3.0em;
  }
}

// Aspect ratio evaluates to 1/1
@media all and (device-aspect-ratio: 1/1) {
  h1 {
    color: red;
    font-size: 3.0em;
  }
}

// Aspect ratio evaluates to 1/1
@media all and (device-aspect-ratio: 2/2) {
  h1 {
    color: green;
    font-size: 0.5em;
  }
}

// Aspect ratio evaluates to 1/1
@media all and (device-aspect-ratio: 10/10) {
  h1 {
    color: purple;
    font-size: 0.5em;
  }
}

// Aspect ratio evaluates to 1/1
@media all and (device-aspect-ratio: 2000/2000) {
  h1 {
    color: orange;
    font-size: 10.5em;
  }
}

// Aspect ratio evaluates to 1/1
@media all and (device-aspect-ratio: 17/17) {
  h1 {
    color: transparent;
    font-size: 0.0em;
    display: none;
  }
}
```

前面的代码示例显示了六个媒体查询表达式，所有这些表达式的长宽比都相同。无论原始表示的比率是前一个值的副本还是减少到相同比率的不同值，最终结果都是一样的。当找到相等的比率，并且没有其他表达式通过进一步限定整个表达式来打破联系时，重复表达式的最后一次出现将成为对先前表达式不唯一的值的唯一活动查询。例如，如果两个或多个表达式的长宽比相同，那么这两个表达式共有的任何 CSS 属性都将优先于查询的最后一次出现。每个表达式之间的唯一值级联到最终计算中。

```
// Aspect ratio evaluates to 1/1
//  Properties set: color, font-size
//  Properties overridden: none
@media all and (device-aspect-ratio: 1/1) {
  h1 {
    color: blue;
    font-size: 1.5em;
  }
}

// Aspect ratio evaluates to 1/1
//  Properties set: color, border, padding
//  Properties overridden: color
@media all and (device-aspect-ratio: 1/1) {
  h1 {
    color: red;
    border: 1px solid green;
    padding: 20px;
  }
}

// Aspect ratio evaluates to 1/1 and anything landscape
//  Properties set: color
//  Properties overridden: color
@media all and (min-device-aspect-ratio: 1/1) {
  h1 {
    color: green;
  }
}
```

在前面的代码片段中，三个独立的媒体查询的长宽比相同。最后一个查询还使用了`min`修饰符，这意味着它匹配任何不是 1/1 的纵横比(以及任何正好是 1/1 的纵横比)，但是设备宽度仍然大于高度(换句话说，任何纵横比为 1/1 的媒体类型和任何方向横向的媒体类型)。

在这种情况下，当媒体类型为`landscape`(记住正方形或 1/1 宽高比永远不会被认为是风景)时，只有第三个查询匹配当前状态。因此，只有颜色属性被分配给在该媒体查询中指定的`h1`标签。然而，当纵横比实际上是 1/1 时，所有三个媒体查询的评估结果都为真，因此所有三个查询都应用于它们指定的元素。

第一个查询只将标签的颜色设置为绿色。第二个查询重置该标签颜色，并另外向标签应用一些属性。最后，第三个查询再次重置标签颜色，但不触及任何其他属性。对于长宽比为 1/1 的媒体类型，这些复合查询的最终结果可以在下面的代码片段中看到。

```
@media all and (device-aspect-ratio: 1/1) {
  h1 {
    color: green;
    border: 1px solid green;
    padding: 20;
  }
}
```

## 颜色

该媒体查询属性检查输出设备使用的每个颜色分量的位数。例如，如果输出设备使用 8 位颜色系统，其中使用 2 位表示红色、绿色、蓝色和 alpha 分量，则媒体查询表达式中的颜色属性为 2。`min`和`max`修改器也可以用来测试这一点。

```
@media all and (color: 2) {
  h1 {
    color: green;
    border: 1px solid green;
    padding: 20;
  }
}
```

如果输出设备不是彩色设备，则颜色属性的值将为零。

```
@media all and (color: 0) {
  h1 {
    color: green;
    border: 1px solid green;
    padding: 20;
  }
}
// This query produces the exact same result as the previous one
@media all and (min-color: 1) {
  h1 {
    color: green;
    border: 1px solid green;
    padding: 20;
  }
}
```

在某些情况下，输出设备对每个颜色分量使用不同的比特计数，颜色属性是指每个分量的最小比特值。例如，如果输出设备使用 8 位颜色系统，并且红色分量使用 3 位，绿色分量使用 3 位，蓝色分量使用 2 位，则用作媒体查询的颜色属性的值将是 2。

## 颜色指数

`color-index`属性返回输出设备使用的颜色数量。例如，具有 256 种颜色的设备将与以下媒体查询完全匹配:

```
@media all and (color-index: 256) {
  h1 {
    color: green;
    border: 1px solid green;
    padding: 20;
  }
}
```

与颜色属性一样，为颜色索引属性指定的值不能为负数。此外，如果输出设备不使用颜色查找表，颜色索引的值为零。

## 单色

如果输出设备为单色，则该媒体查询属性指设备使用的每像素位数。这类似于彩色，但仅适用于单色设备，并且由于明显的原因，仅适用于单个像素，而不是最低的颜色分量。

```
@media all and (monochrome: 1) {
  h1 {
    color: black;
    border: 1px solid black;
    padding: 20;
  }
}
```

如果设备不是单色的，该属性将匹配零值。另外，我们可以使用`min`和`max`修饰符关键字来确定目标范围。或者，可以使用单个布尔表达式来确定设备是否是单色的。

```
@media not all and (monochrome) {
  h1 {
    color: red;
    border: 1px solid purple;
    padding: 20;
  }
}

// This query produces the exact same result as the previous one
@media all and (color) {
  h1 {
    color: red;
    border: 1px solid purple;
    padding: 20;
  }
}
```

## 分辨率

与可能相信的相反，分辨率属性并不像我们可以通过操作系统设置给显示器的分辨率那样查询屏幕分辨率。相反，分辨率属性查询以 dpi(每英寸点数或每英寸像素数)和 dpcm(每厘米点数或像素数)测量的像素密度(或打印机的点密度)。

```
@media all and (resolution: 300dpi) {
  h1 {
    color: black;
    border: 1px solid black;
    padding: 20;
  }
}
```

`min`和`max`修饰符在该查询表达式中有效。如果输出设备不使用方形像素，使用`min-resolution`查询输出设备的最小密集维度。当发出`max-resolution`查询时，使用输出设备的最密集的维度来评估表达式。

## 扫描

当在电视上渲染时，扫描属性查询设备的扫描。唯一可能的值是`progressive`和`interlace`。使用`min`和`max`修饰语在电视扫描过程中没有意义，因此表达无效。

```
@media all and (scan: interlace) {
  h1 {
    color: black;
    border: 1px solid black;
    padding: 20;
  }
}

@media all and (scan: progressive) {
  h1 {
    color: red;
    border: 1px solid red;
    padding: 20;
  }
}
```

## 网格

网格输出设备不是基于位图的设备。当输出设备不是基于位图时，查询`grid`属性返回真。唯一可以查询的值是 1 和 0。`min`和`max`修饰符在此查询中无效。

基于网格的设备的例子包括任何使用字符网格的设备，例如那些老式计算器，甚至是带有固定字体的老式手机。

```
// Evaluates to true on grid-based devices
@media all and (grid) {
  h1 {
    color: black;
    border: 1px solid black;
    padding: 20;
  }
}

// Evaluates to true on grid-based devices
@media all and (grid: 1) {
  h1 {
    color: black;
    border: 1px solid black;
    padding: 20;
  }
}

// Evaluates to true on bitmap-based devices
@media all and (grid: 0) {
  h1 {
    color: black;
    border: 1px solid black;
    padding: 20;
  }
}

// Evaluates to true on bitmap-based devices
@media not all and (grid) {
  h1 {
    color: black;
    border: 1px solid black;
    padding: 20;
  }
}
```

# 了解触摸事件

虽然本质上类似于普通的鼠标点击，但是触摸事件允许我们主要通过点和响应的方式与计算机交互。然而，触摸远比点击更灵活，因此为一种全新的游戏类型打开了舞台。

从根本上说，触摸不同于点击，因为在同一表面上，同一时间可能有多次触摸。此外，触摸通常不同于点击，因为它允许更大的目标区域以及变化的压力。我说一般是因为不是所有的设备都能以高精度(或任何精度)或触摸压力来检测触摸区域。类似地，一些鼠标或其他等效的输入设备实际上确实提供了压力敏感性，尽管大多数浏览器没有使用这样的功能，也没有通过点击事件对象公开数据。

### 注

出于兼容性的考虑，大多数移动浏览器会在 JavaScript 代码需要触摸时响应触摸事件。换句话说，点击处理器可以由用户触摸屏幕来触发。在这种情况下，常规点击事件对象被传递给注册的`callback`功能，而不是触摸事件对象。此外，拖动事件(`dragMove`事件)和触摸移动事件之间的体验可能不同。最后，多次触摸可能触发也可能不触发同时点击事件监听器。

与触摸相关的事件有三个，即触摸开始、触摸移动、触摸结束。触摸开始和触摸结束可以分别与鼠标向下和鼠标向上事件相关，而触摸移动事件类似于拖动移动事件。

## 触摸启动

当触摸区域检测到新的触摸时，无论一个或多个触摸事件是否已经开始且尚未结束，都会触发该事件。

```
document.body.addEventListener("touchstart", doOnTouchStart);

function doOnTouchStart(event) {
  event.preventDefault();

  // ...
}
```

传递到注册的`callback`函数中的对象是`TouchEvent`类的一个实例，包含以下属性:

### 触摸

类`TouchList`的一个实例看起来像一个普通的数组，包含一个列表，其中列出了在触摸设备上已经触摸到但尚未被移除的所有触摸，即使其他活动触摸已经在屏幕或输入设备上移动。该列表中的每个元素都是类型`Touch`的实例。

### 换能器

包含触摸对象列表的`TouchList`类的一个实例，这些对象代表自上次触摸事件以来引入的所有新触摸点。例如，如果已经检测到两个触摸对象(换句话说，两个手指已经压在触摸设备上)，并且检测到第三次触摸，则在该触摸列表中仅存在该第三次触摸。同样，该触摸列表中包含的每个触摸相关元素都是类型`Touch`。

### 瞄准键

类的一个实例，包含一个触摸对象列表，代表给定 DOM 节点捕获的所有触摸点。例如，如果在整个屏幕上检测到多个触摸，但某个特定元素注册了触摸开始事件并捕获了该事件(从捕获或气泡阶段)，则只有该节点捕获的触摸事件才会出现在该触摸列表中。同样，该触摸列表中包含的每个触摸相关元素都是类型`Touch`。

## 触地得分

类似于鼠标向上事件，当任何注册的触摸事件离开输入触摸设备时，触发`touchend` 事件。

```
document.body.addEventListener("touchend", doOnTouchEnd);

function doOnTouchEnd(event) {
  event.preventDefault();

  // ...
}
```

就像`touchstart`事件一样，传递到注册的`callback`函数中的对象是`TouchEvent`类的一个实例，它包含相同的三个`TouchList`属性。`touches`和`targetTouches`属性的上下文与`touchstart`中的版本完全相同。但是`changedTouches`触摸列表在此事件中的含义略有不同。

虽然`touchend`事件中的`TouchList`对象与`touchstart`中的对象完全相同，但此处包含的触摸对象列表代表已经离开触摸输入设备的触摸。

## 触地移动

类似于`drag`事件的`touchmove`事件每当至少一个注册的触摸对象的改变位置而没有触发`touchend`事件时被触发。正如我们将很快看到的，每个触摸对象都被唯一地跟踪，因此可以确定是否有任何注册的触摸对象已经移动，以及哪些实际上已经移动。

```
document.body.addEventListener("touchmove", doOnTouchMove);

function doOnTouchMove(event) {
  event.preventDefault();

  // ...
}
```

同样，就像`touchend`事件一样，传递到注册的`callback`函数中的对象是`TouchEvent`类的一个实例，它包含相同的三个`TouchList`属性。`touches`和`targetTouches`属性的上下文与`touchstart`中的版本完全相同。`touchmove`事件中的`changedTouches`列表中的触摸对象表示已经在输入设备周围移动的先前登记的触摸。

`touchmove`事件有一点很重要，那就是它可以与一个`drag`事件相关联。如果您注意到，`drag`事件的默认行为是向滚动方向滚动页面。在一些涉及用手指在屏幕上拖动的应用程序中，这种行为可能并不理想。为此，调用`event.preventDefault()`方法，产生提醒浏览器不需要滚动的效果。然而，如果意图是用`touchmove`事件滚动屏幕，假设被触摸的元素支持这种行为，这可以通过省略对防止默认功能的调用来实现。

## 触摸物体

现在，您可能已经注意到每个`TouchList`对象都包含一个非常具体的对象的实例，该对象是`Touch`类的实例。这很重要，因为输入设备需要跟踪单个触摸。否则，`changedTouches`的列表将是不准确的，从而限制了我们使用该应用编程接口所能完成的工作。

唯一识别每个触摸的方法是让输入设备为它捕获的每个事件分配一个唯一的标识。对于同一触摸对象，该标识保持不变，直到该对象被释放(换句话说，当该特定触摸离开输入设备时)。

让我们看看`Touch`类的所有其他属性，看看其中还包含哪些重要信息。

### 标识符

包含在当前触摸`TouchList`中的特定触摸事件的唯一整数标识符。这个数字保持不变，直到触摸事件离开输入设备，这允许我们单独跟踪每个触摸，即使许多其他触摸对象正在开始、移动和结束，而一个特定的触摸对象可以被挑选出来并适当保留。

请注意，有时该属性的值可能与`TouchList`对象内的触摸对象的数组索引值相匹配。有时，标识符属性甚至可能与输入设备检测到每次触摸的顺序相匹配。作为一个细心的程序员，你绝不能假设这两个值总是相同的。

例如，假设设备第一次检测到触摸时，它的标识符标识为零(由于这是**触摸列表**中的第一次触摸，它显然将被索引到索引值为零的列表中)。现在检测到第二次触摸，使其成为**触摸列表**数组中的第二个对象，这将给它一个索引键 1。假设此触摸还接收到一个标识符，因此所有三个值都匹配(触摸顺序、数组顺序和标识符值)。现在，在输入设备周围移动这两个触摸之后，假设第一个触摸对象被释放并且检测到新的触摸事件。现在**触摸列表**中又出现了两个触摸对象，但是它们的值与前两个触摸元素完全不同。虽然第二个触摸事件仍然具有相同的标识符(在本例中，标识符是一个)，但它现在(可能)是**触摸列表**中的第一个元素。

尽管有时检测到触摸的顺序、触摸在**触摸列表**数组中的位置以及触摸的唯一标识符编号可能都匹配(假设输入设备甚至分配了特定的标识符值)，但您永远不应该使用这些假设来跟踪单个触摸。当跟踪多个触摸时，应始终通过其唯一标识符属性来跟踪触摸。如果只跟踪单次触摸，该触摸将始终是`TouchList`对象中的第一个元素。

![identifier](graphics/6029OT_08_06.jpg)

总之，检测触摸并将其分配给`TouchList`对象的顺序是不可预测的，不应假设。跟踪单个触摸对象的正确方法是通过分配给每个对象的标识符属性。一旦触摸事件被释放，它以前的标识符属性的值可以被重新分配给后续的触摸，所以一定要记住这一点。

### screenX

`screenX`坐标是指浏览器视口中相对于系统显示原点被触摸的点。该计算完全不考虑浏览器视口的原点。点(0，0)是监视器的左上角，无论它右边有多少像素被触摸，这就是这个属性所指的地方。

### 屏幕

`screenY`坐标是指从系统屏幕(监视器)向下的点，与浏览器相对于该点的位置无关。例如，如果屏幕高度为 800 像素，并且浏览器设置为高度为 100 像素，正好位于屏幕顶部下方 100 像素处，则在触摸 a 时，浏览器视口左上角和左下角之间的中点将导致触摸的`screenY`坐标为 150。

想想看，浏览器的视窗有 100 个像素高，所以它的中点正好比原点低 50 个像素。如果浏览器正好在屏幕原点下方 100 像素，则中点在屏幕垂直原点下方 150 像素。

`screenX`和`screenY`属性看起来几乎没有考虑浏览器的坐标系。这样一来，由于浏览器的计算是基于其屏幕原点的，因此由`screenX`和`screenY`返回的点永远不会小于零，因为我们无法触摸屏幕表面区域之外的点并仍然让屏幕检测到该点。

### 客户端

类似于`screenX`，`clientX`坐标指的是从浏览器视窗原点到触摸位置的偏移，与页面内的任何滚动无关。换句话说，由于浏览器视窗的原点是其左上角，在该点右侧触摸 100 像素对应于`clientX`值 100。现在，如果用户向右滚动该页面，比如说 500 个像素，那么在浏览器左边框右侧触摸 100 个像素仍然会导致`clientX`值为 100，即使触摸发生在页面内的点 600。

### 客户端

`clientY`坐标指的是从浏览器的视口原点向下的点，与页面中触摸发生的位置无关。如果页面向右下方滚动任意数量的像素，并且在浏览器视窗左上角右侧的第一个像素处检测到触摸，并且正好向下一个像素，则`clientY`值将被计算为 1。

`clientX`和`clientY`属性没有考虑网页的坐标系。这样，因为该点是相对于浏览器的框架计算的，所以由`clientX`和`clientY`返回的点永远不会小于零，因为我们无法触摸浏览器视口表面区域之外的点并且仍然让浏览器检测该点。

### 第 X 页

最后， `pageX`表示的坐标是指实际页面内检测到触摸的点。换句话说，如果浏览器只有 500 像素宽，但应用程序有 3000 像素宽(这意味着我们可以将应用程序的内容向右滚动 2500 像素)，那么从浏览器的视口原点精确检测到 2000 像素的触摸将产生 2000 的`pageX`值。

在游戏世界中，`pageX`更好的名字可能是`worldCoordinateX`，因为触摸会考虑到触摸事件发生在世界的哪个地方。当然，这仅在网页物理滚动时起作用，而不是在出现滚动表示时。例如，假设我们在 2D 画布上渲染一个世界，这个世界实际上比画布元素的宽度和高度大得多。如果我们滚动虚拟地图任意数量的像素，但画布元素本身从未实际移动过，那么`pageX`值对于游戏地图的偏移将毫无意义。

### 佩吉

最后得出结论，`pageY`坐标指的是在浏览器视窗原点下方检测到触摸的点，加上任何滚动偏移。与其他触摸点位置一样，无法获得`pageX`和`pageY`属性的负值，因为无法触摸页面中尚未滚动到的点，尤其是页面原点后面我们无法滚动到的点。

下图显示了屏幕、客户端和页面位置之间的差异。屏幕位置是指屏幕内的位置(不是浏览器窗口)，原点是显示屏的左上角。客户端位置类似于屏幕位置，但将原点放在浏览器视口的左上角。即使浏览器调整了大小并在屏幕上移动了一半，浏览器视口右侧的第一个像素也将是点(0，0)。页面位置类似于客户端位置，但会考虑浏览器视口内的任何滚动。如果页面垂直向下滚动 100 像素，而没有水平滚动，浏览器视口左边距右侧的第一个像素将是(100，1)。

![pageY](graphics/6029OT_08_08.jpg)

### radiusX

当输入设备检测到触摸时，输入设备会在触摸区域周围绘制一个椭圆。可以通过`radiusX`和`radiusY`属性访问椭圆的半径，提示触摸覆盖了多少区域。请记住，描述触摸区域的椭圆的精度由使用的设备决定，因此里程可能会在这里有很大差异。

### 半径

为了获得输入设备检测到的触摸所形成的椭圆水平轴上的半径，我们可以使用 `radiusY`属性。有了这些信息，我们可以为使用触摸作为输入创建的应用程序类型增加额外的深度。

作为一个示例应用程序，下面的代码片段检测输入设备可以同时处理的尽可能多的触摸，跟踪每个触摸的半径，然后以大约的大小显示每个触摸。

首先，我们需要将文档视口设置为与设备相同的宽度和高度，并设置初始缩放级别。我们还希望禁用捏手势，因为在这个特定的示例应用程序中，我们希望该手势充当任何其他触摸动作，并且没有任何特殊意义。

```
<meta name="viewport"
  content="width=device-width, initial-scale=1.0,
    user-scalable=no" />
```

元视口标签允许我们为视口定义特定的宽度和高度值，或者使用可选的设备宽度和设备高度属性。如果只指定了宽度或高度值，则由用户代理推断另一个值。该标签还允许我们指定默认缩放级别，以及通过手势或其他方式禁用缩放。

接下来，我们需要确保应用程序中的根 DOM 节点拉伸显示器的整个宽度和高度，以便我们可以捕获其中的所有触摸事件。

```
<style>
body, html {
  width: 200%;
  height: 100%;
  margin: 0;
  padding: 0;
  position: relative;
  top: 0;
  left: 0;
}

div {
  position: absolute;
  background: #c00;
  border-radius: 100px;
}
</style>
```

我们将`body`标签设置为与视口一样宽，并从其中移除任何边距和填充，以便元素的事件处理不会错过屏幕边缘附近的触摸。我们还设计了`div`元素的样式，使其看起来是圆形的，有一个红色的背景色，并且绝对定位，这样我们就可以在任何检测到触摸的地方放置一个。我们本可以使用一个画布元素来代替渲染多个`div`标签来表示每次触摸，但是这对于这个演示来说是一个无关紧要的细节。

最后，我们进入应用程序的 JavaScript 逻辑。为了总结这个演示的结构，我们简单地使用一个全局数组来存储每个触摸。每当在文档上检测到任何触摸事件时，我们刷新跟踪每个触摸的全局数组，为每个活动的触摸创建一个`div`元素，并将该新节点推送到全局数组。与此同时，我们使用一个请求动画帧外观来连续渲染包含在全局触摸数组中的所有 DOM 节点。

```
// Global array that keeps track of all active touches.
// Each element of this array is a DOM element representingthe location
// and area of each touch.
var touches = new Array();

// Draw each DOM element in the touches array
function drawTouches() {
  for (var i = 0, len = touches.length; i < len; i++) {
    document.body.appendChild(touches[i]);
  }
}

// Deletes every DOM element drawn on screen
function clearMarks() {
  var marks = document.querySelectorAll("div");

  for (var i = 0, len = marks.length; i < len; i++) {
    document.body.removeChild(marks[i]);
  }
}

// Create a DOM element for each active touch detected by the
// input device. Each node is positioned where the touch was
// detected, and has a width and height close to what the device
// determined each touch was
function addTouch(event) {
  // Get a reference to the touches TouchList
  var _touches = event.touches;

  // Flush the current touches array
  touches = new Array();

  for (var i = 0, len = _touches.length; i < len; i++) {
    var width = _touches[i].webkitRadiusX * 20;
    var height = _touches[i].webkitRadiusY * 20;

    var touch = document.createElement("div");
    touch.style.width = width + "px";
    touch.style.height = height + "px";
    touch.style.left = (_touches[i].pageX - width / 2) + "px";
    touch.style.top = (_touches[i].pageY - height / 2) + "px";

    touches.push(touch);
  }
}

// Cancel the default behavior for a drag gesture,
// so that the application doesn't scroll.
document.body.addEventListener("touchmove", function(event) {
  event.preventDefault();
});

// Register our function for all the touch events we want to track.
document.body.addEventListener("touchstart", addTouch);
document.body.addEventListener("touchend", addTouch);
document.body.addEventListener("touchmove", addTouch);

// The render loop
(function render() {
  clearMarks();
  drawTouches();

  requestAnimationFrame(render);
})();
```

考虑到每个触摸的半径的多次触摸的例子如下所示。通过将握紧的拳头的侧面接触移动设备，我们可以看到手的每个触摸屏幕的部分是如何通过它们的相对大小和接触面积来检测的。

![radiusY](graphics/6029OT_08_07.jpg)

### 旋转尺

根据检测到触摸的方式，代表触摸的椭圆可能会旋转。与每个触摸对象相关联的 `rotationAngle`属性是顺时针角度，以度为单位，旋转椭圆以最接近地匹配触摸。

### 力

一些触摸设备是能够检测用户施加到输入表面表面的压力量的。在这种情况下，force 属性用 0.0 到 1.0 之间的变量表示压力，其中 1.0 表示设备可以处理的最大压力。当设备不支持力敏感时，该属性将始终返回 1.0。

由于 force 属性的值总是介于 0 和 1 之间，因此我们可以方便地使用它来渲染具有不同不透明度的元素(0 是完全透明的-不可见的-元素，1 是完全渲染的)。

```
var width = _touches[i].webkitRadiusX * 20;
var height = _touches[i].webkitRadiusY * 20;
var force = _touches[i].webkitForce;

var touch = document.createElement("div");
touch.style.width = width + "px";
touch.style.height = height + "px";
touch.style.left = (_touches[i].pageX - width / 2) + "px";
touch.style.top = (_touches[i].pageY - height / 2) + "px";
touch.style.opacity = force;

touches.push(touch);
```

### 目标

当检测到触摸事件时，通过 `target`属性引用首次检测到触摸的 DOM 元素。由于跟踪触摸对象直到触摸结束，因此目标属性将在触摸生命周期期间引用最初开始触摸的原始 DOM 元素。

# 比赛

正如我们在本章开头所讨论的，在设计和构建要在移动设备和桌面浏览器上玩的游戏时，必须牢记几个注意事项。在我们写这本书的最后一个游戏时，我们将应用这些原则和最佳实践，使游戏既可以在移动设备上玩，也可以在 HTML5 就绪的浏览器上玩。

在这个特定项目中采用的方法是先为桌面设计，然后再添加特定于移动设备的 API 和功能。做出这一决定的首要原因是，使用现有工具和通用实践在桌面浏览器上测试和调试应用程序要容易得多，然后添加必要的东西，使代码在移动设备上也能顺利运行。

最后一个游戏是传统的二维空间射击游戏，玩家控制着一艘飞船，它可以绕着屏幕移动，并且总是朝着同一个方向射击。随机的敌人太空飞船从屏幕的四面八方出现，试图击中玩家的飞船，从而对玩家的飞船造成伤害，直到飞船爆炸。

![The game](graphics/6029OT_08_09.jpg)

## 代码结构

考虑到这个游戏的复杂性，代码的结构必须仔细考虑。为了简单起见，我们将使用一种基于组件的方法，这样一个接一个地添加特性就容易多了，尤其是在动态添加输入处理机制的时候。由于游戏需要在移动设备上和桌面上玩得一样好(换句话说，游戏需要接受和处理鼠标和键盘输入以及触摸输入，这取决于游戏所处的环境)，因此能够动态地为游戏添加特定组件是一个非常重要的特性。

如果你不熟悉基于组件的游戏开发，不要太担心。基于组件的开发的一般思想是将每个功能从一个类中分离出来，并使该功能成为自己的类。这使我们能够创建代表单个功能的单个对象，如移动、渲染等。

这个游戏的最终项目结构如下，其中文件和目录列表显示了项目文件夹的根目录:

### /css

这是存储单个样式表文件的地方。这个样式表定义了桌面和移动版本的所有样式，尽管两者之间几乎没有区别。将 CSS 特性添加到游戏版本的方法是在 CSS 类中声明这些特性，然后在适当的时候将这些类分配给 DOM 元素。

我们要在这个样式表中声明的第一件事是视口，确保屏幕中的每个像素都是文档的一部分，这样我们就可以在文档的任何地方捕获输入事件。我们还想防止文档以某种方式变得比视窗大，这会给游戏带来滚动条，这在本例中是不希望的。

```
body, html {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

body {
  background: url("../img/space-bg-01.jpg") repeat;
}
```

如果运行它的设备支持，我们在游戏中想要的两个特性是 DOM 元素的过渡效果以及背景图像的动画。为了仅在适当的地方添加该功能(例如，将该功能添加到某些移动设备可能会将游戏播放速度降低到不可播放的水平，因为移动浏览器需要进行大量处理才能生成 CSS 动画和过渡)，我们创建了 CSS 动画并将其添加到自定义类中。当我们确定设备可以处理动画时，我们只需将类添加到文档中。

```
/**
 * Make the background image continually move up and to the left,
 * giving the illusion that the game world is scrolling at anangle.
 */
@-webkit-keyframes NebulaBg {
  from {
    background-position: 0 0;
  }
  to {
    background-position: 1300% 600%;
  }
}

/**
 * Add the animation to this class, and add a transition
 * to any box-shadow applied to whatever element this class isattached to.
 */
.animBody {
  -webkit-transition: box-shadow 8s;

  -webkit-animation: NebulaBg;
  -webkit-animation-duration: 500s;
  -webkit-animation-timing-function: linear;
  -webkit-animation-iteration-count: infinite;
}
```

最后，为了简化一些游戏用户界面，我们将一些游戏元素创建为普通的 DOM 元素，而不是直接在渲染游戏其余部分的画布中渲染等效元素。

我们作为 DOM 元素构建的唯一游戏元素是玩家飞船的能量条，它指示飞船还剩多少能量。这个能量条由一个容器元件组成，其中包含一个`div`元件。这个嵌套的`div`的宽度代表玩家剩余的能量，可以是 0-100%之间的值。

```
.energyBar {
  position: absolute;
  top: 2%;
  left: 4%;
  z-index: 99999;
  width: 92%;
  height: 25px;
  border: 1px solid #ff5;
  background: #c00;
  overflow: hidden;
}

.energyBar div {
  background: #ff5;
  height: 100%;
  width: 100%;
  -webkit-transition: width 0.2s;
}
```

### /img

在这个文件夹中，我们存储了游戏中使用的所有图像资源。由于所有这些图像都是在画布中呈现的，我们可以很好地将所有图像组合成一个图像图谱。这将是一个非常好的优化，尤其是随着游戏的增长和图像资产数量的增长。由于大多数浏览器限制了应用程序向同一服务器发出的并行 HTTP 请求的数量，我们只能同时获取有限数量的图像。这意味着，如果从同一服务器提取的单个图像文件太多，将处理前 4-8 个请求(到同一服务器的默认并行连接数因浏览器而异，但通常约为 6 个左右)，而其余请求则在队列中等待。

因此，很容易看出，与下载多个单独的图像文件相比，创建单个图像地图集资产是一个更好的选择。即使地图集的总图像文件大小大于所有其他图像的总大小之和，最大的好处也是传输延迟。即使游戏在某个时间点的单个图像资产翻倍，我们仍然只需要下载一个图像图谱(或者几个可以同时下载的单独图谱)。

### 注

因为并不是每个人都有很高的天赋来为你的游戏创建令人敬畏的图形，更少的人有时间创建游戏中使用的每个图像。许多游戏开发者发现从数字艺术家那里购买图形是值得的。

在这个游戏中，所有的图形都是从网站上下载的，在那里艺术家们免费或以极低的成本分享他们的创作。这个精彩社区的网址是[http://opengameart.org](http://opengameart.org)。

### /js

如前所述，这款游戏建立在基于组件的模型之上。文件结构分为四大类；即组件、实体、小部件和通用代码。这些代码的每一部分都是通用的和可重用的。所有这些部件的粘合是在一个名为`main.js`的文件中完成的。

### /组件

组件目录是我们存储游戏中使用的所有组件的地方。在游戏开发的上下文中，组件是一个非常具体的类，它可能包含自己的数据并执行非常具体的功能。例如，当设计一个类来表示玩家时，我们可以将这个类的每个功能分解成许多单独的更小的类或组件，而不是让这个类来处理玩家船只的渲染、移动、执行碰撞检测等等。

通常，游戏中的每个组件都实现了一个公共接口，因此我们可以利用面向对象的技术。虽然可以在 JavaScript 中模拟经典继承和其他面向对象技术，但我们只是为每个组件复制相同的基本接口，并在客户端代码中假设每个组件遵循相同的接口。

```
// Namespace the component in order to keep the global namespaceclean
var Packt = Packt || {};
Packt.Components = Packt.Components || {};

Packt.Components.Component = function(entity) {
  var entity = entity;

  this.doSomething = function() {
};
```

这个游戏中的每个组件都有两个共同点。它们都存在于模拟基于包的结构的`Pack.Components`对象中，并且都持有对使用组件提供的服务的父实体的引用。

我们将创建的第一个组件是`sprite`组件，它负责渲染一个实体。正如我们将在关于实体的讨论中看到的，一个实体只记录它自己在游戏世界中的位置，而不知道它的宽度和高度。因此，`sprite`组件还跟踪实体的物理尺寸以及在视觉上表示实体的图像。

```
var Packt = Packt || {};
Packt.Components = Packt.Components || {};
Packt.Components.Sprite = function(pEntity, pImgSrc, pWidth, pHeight) {
  var entity = pEntity;
  var img = new Image();
  img.src = pImgSrc;

  var width = pWidth;
  var height = pHeight;
  var sWidth = pWidth;
  var sHeight = pHeight;
  var sX = 0;
  var sY = 0;
  var ctx = null;

  // Inject the canvas context where the rendering of the entity
  // managed by this component is done
  function setCtx(context) {
    ctx = context;
  }

  // Public access to the private function setCtx
  this.setCtx = setCtx;

  // If the image used to render the entity managed by thiscomponent
  // is part of an atlas, we can specify the specific region
  // within the atlas that we want rendered
  this.setSpriteCoords = function(x, y, width, height) {
    sX = x;
    sY = y;
    sWidth = width;
    sHeight = height;
  };

  // Render the entity
  this.update = function() {
    if (ctx && entity.isActive()) {
      var pos = entity.getPosition();
      ctx.drawImage(img, sX, sY, sWidth, sHeight, pos.x, pos.y,width, height);
    }
  };

  // Return both values at once, instead of using two getterfunctions
  this.getSize = function() {
    return {
      width: width,
      height: height
    };
  };
};
```

一旦渲染实体的功能到位，我们现在可以继续添加一个组件，允许玩家在屏幕上移动实体。现在，使用组件的全部意义在于允许最大限度的代码重用。在我们的例子中，我们希望重用让玩家移动的组件，这样我们就可以让每艘敌舰使用相同的功能在游戏世界中移动。

为了使实体移动，我们使用一个非常标准的`Move`组件，该组件根据实体的方向向量和实体在给定方向上移动的恒定速度来移动实体。`Vec2`数据类型是本章后面讨论的自定义通用类。基本上，这个类表示一个向量，其中它保存了两个表示向量两个分量的变量，并定义了一个非常方便的函数，以便在需要时对向量进行归一化。

```
var Packt = Packt || {};
Packt.Components = Packt.Components || {};

Packt.Components.Move = function(entity, speed) {
  var entity = entity;
  var speed = speed;
  var direction = new Packt.Vec2(0, 0);

  // Move the entity in the direction it is facing by a constantspeed
  this.update = function() {
    var pos = entity.getPosition();
    direction.normalize();

    var newPos = {
      x: pos.x + direction.get("x") * speed,
      y: pos.y + direction.get("y") * speed
    };

    entity.setPosition(newPos);
  };

  // Allow the input mechanism to tell the entity where to move
  this.setDirection = function(x, y) {
    direction.set(x, y);
  };
};
```

现在，玩家和敌人都可以使用同一个`Move`组件来移动他们的实体的方式略有不同。在敌人的情况下，我们可以简单地创建一些原始的人工智能来设置敌人实体的方向，并且`Move`组件负责根据需要更新实体的位置。

然而，为了让玩家的船移动，我们希望玩家自己告诉实体去哪里。为了实现这一点，我们只需创建一个监听人类输入的输入组件。然而，由于玩家可能从支持鼠标事件或直接触摸事件的设备玩这个游戏，我们需要创建两个独立的组件来处理每种情况。

这些组件在各方面都是相同的，除了一个注册鼠标事件，另一个注册触摸事件。虽然这可以在单个组件中完成，条件语句规定了要监听哪些事件，但我们选择了单独的组件，以便使代码更少地耦合到任何特定设备。

```
var Packt = Packt || {};
Packt.Components = Packt.Components || {};

Packt.Components.TouchDrag = function(entity, canvas) {
  var entity = entity;
  var canvas = canvas;
  var isDown = false;
  var pos = entity.getPosition();

  canvas.getCanvas().addEventListener("touchstart", doOnTouchDown);
  canvas.getCanvas().addEventListener("touchend", doOnTouchUp);
  canvas.getCanvas().addEventListener("touchmove", doOnTouchMove);

  // Set a isDown flag on the entity, indicating that the playeris currently
  // touching the entity that is to be controlled
  function doOnTouchDown(event) {
    event.preventDefault();
    var phy = entity.getComponent("physics");
    var touch = event.changedTouches;

    if (phy) {
      isDown = phy.collide(touch.pageX, touch.pageY, 0, 0);
    }
  }

  // Whenever the player releases the touch on the screen,
  // we must unset the isDown flag
  function doOnTouchUp(event) {
    event.preventDefault();
    isDown = false;
  }

  // When the player drags his/her finger across the screen,
  // store the new touch position if and only if the player
  // is actually dragging the entity
  function doOnTouchMove(event) {
    event.preventDefault();
    var touch = event.changedTouches;

    if (isDown) {
      pos.x = touch.pageX;
      pos.y = touch.pageY;
    }
  }

  // Reposition the player's entity so that its center is placed
  // right below the player's finger
  this.centerEntity = function() {
    if (isDown) {
      var sprite = entity.getComponent("sprite");

      if (sprite) {
        var size = sprite.getSize();
        var x = pos.x - size.width / 2;
        var y = pos.y - size.height / 2;

        entity.setPosition({x: x, y: y});
      }
    }
  };

  this.getPosition = function() {
    return pos;
  };
};
```

接下来，让我们来看看任何带有移动实体的游戏的一个非常关键的组件，即`physics`组件，它们在生活中的唯一责任是判断两个实体是否碰撞。这是以非常简单有效的方式完成的。为了让实体能够使用 `physics`组件，它还必须有一个`sprite`组件，因为`physics`组件需要知道每个实体的位置以及每个实体的高度和宽度。通过一个`sprite`组件，我们能够提取关于每个实体的两条信息。

检查两个实体是否碰撞的方法很简单。组件本身存储了对实体的引用，因此执行检查的函数需要知道我们正在检查碰撞的实体的位置和大小。一旦我们有了两个实体的位置和尺寸，我们只需检查一个实体的右侧是否在另一个实体的左侧，一个实体的左侧是否在另一个实体的右侧，或者一个实体的底部是否在另一个实体的顶部上方，以及一个实体的顶部是否在另一个实体的底部下方。如果这些测试中的任何一个通过了(换句话说，条件检查返回正)，那么我们就知道没有冲突，因为两个矩形不可能相互相交，然而这四个陈述中的任何一个都是正确的。类似地，如果所有这些测试都失败了，我们知道实体相互交叉，并且发生了碰撞。

```
var Packt = Packt || {};
Packt.Components = Packt.Components || {};

Packt.Components.Physics = function(entity) {
  var entity = entity;

  // Check if these two rectangles are intersecting
  this.collide = function(x, y, w, h) {
    var sprite = entity.getComponent("sprite");
    if (sprite) {
      var pos = entity.getPosition();
      var size = sprite.getSize();

      if (pos.x > x + w) {
        return false;
      }

      if (pos.x + size.width < x) {
        return false;
      }

      if (pos.y > y + h) {
        return false;
      }

      if (pos.y + size.height < y) {
        return false;
      }

      return true;
    }

    return false;
  };

  // Return the entity's location and dimensions
  this.getBodyDef = function() {
    var pos = entity.getPosition();
    var sprite = entity.getComponent("sprite");
    var size = sprite.getSize() || {width: 0, height: 0};

    return {
      x: pos.x,
      y: pos.y,
      width: size.width,
      height: size.height
    };
  };
};
```

游戏中使用的最后两个组件非常简单，对于这种特殊类型的游戏来说比其他组件稍微独特一些。这些组件是`Strength`组件和 `LaserGun`组件，它们赋予实体向其他实体发射激光束的能力。

`Strength`组件隔离了玩家自身能量的管理以及所有敌舰和所有人的激光。该组件用于确定一个实体是否仍然存在，以及它在接触时会对其他实体造成多大的损害。如果一个实体不再存在(如果它的强度已经低于零)，那么它就会被完全从游戏中移除，就像激光每次与另一个实体碰撞时的情况一样。

```
var Packt = Packt || {};
Packt.Components = Packt.Components || {};
Packt.Components.Strength = function(pEntity, pHP, pEnergy) {
  var entity = pEntity;
  var hp = pHP;
  var energy = pEnergy;

  // This is how much damage the entity causes to other entities
  // upon collision between the two
  this.getHP = function() {
    return hp;
  };

  // This represents how much energy the entity has left. When
  // the energy gets to or below zero, the entity dies
  this.getEnergy = function() {
    return energy;
  };

  // Update the entity's energy levels
  this.takeDamage = function(damage) {
    energy -= damage;
    return energy;
  };
};
```

`LaserGun`组件稍微复杂一些，因为它包含了它所管理的实体的集合。每次包含激光枪的实体发射激光束时，都会创建一个新的实体来表示该激光束。这个实体类似于游戏中的所有其他实体，因为它还包含一个`sprite`组件来为自己绘制一个`Move`组件和一个`physics`组件。

每次激光枪自我更新时，它都需要向前移动所有的激光，如果激光已经超出屏幕区域，它就需要从控制中移除任何激光束。

```
var Packt = Packt || {};
Packt.Components = Packt.Components || {};

Packt.Components.LaserGun = function(entity, canvas, maxShots) {
  var entity = entity;
  var MAX_SHOTS = maxShots;
  var canvas = canvas;
  var shots = new Array();
  var shotsPerSec = 1000 / 15;
  var timeLastShot = 0;

  // Move all lasers forward, and remove any lasers outsidethe screen
  this.update = function() {
    for (var i = 0, len = shots.length; i < len; i++) {
      try {
        shots[i].update();
        var shotPos = shots[i].getPosition();

        if (shotPos.y < -100) {
          shots.splice(i, 1);
        }
      } catch (e) {}
    }
  };

  // Create a new laser entity, and assign all of the components
  // it will need in order to actually destroy other ships
  this.add = function(x, y) {
    var time = Date.now();

    // Don't add a new laser until at least some time has passed,
    // so that we don't fire too many lasers at once
    if (time - timeLastShot >= shotsPerSec) {

      // Restrict the amount of lasers that can be on the screenat once
      if (shots.length < MAX_SHOTS) {
        var shot = new Packt.Entity(Packt.ENTITY_TYPES.BULLET, x, y);
        var spriteComp = new Packt.Components.Sprite(
          shot, "./img/laser-blue.png", 8, 32);
        spriteComp.setCtx(canvas.getContext());
        var strengthComp = new Packt.Components.Strength(shot, 10, 0);
        var physComp = new Packt.Components.Physics(shot);
        var mockMove = new Packt.Components.Move(shot, 15);

        shot.addComponent("sprite", spriteComp);
        shot.addComponent("move", mockMove);
        shot.addComponent("physics", physComp);
        shot.addComponent("strength", strengthComp);

        shot.setOnUpdate(function() {
          mockMove.setDirection(0, -1);
          mockMove.update();
        });

        shots.push(shot);
      }

      timeLastShot = time;
    }
  };

  // Return a list of active shots
  this.getShots = function() {
    return shots;
  };
};
```

随着我们所有主要组件的就位，我们准备好看一看游戏中的其他类。但是，请记住，使用组件的全部目的是简化开发，并放松各个功能之间的耦合。因此，如果我们想给游戏添加更多的组件，比如爆炸效果组件，我们所需要做的就是遵循组件的相同基本结构，我们可以简单地将其插入主游戏逻辑脚本。

### /实体

实体是游戏的主要积木。它们是我们可以与之交互的任何东西的广义表示——玩家的船、敌舰或激光束。有些人把他们的实体称为对象、角色或演员，但他们背后的想法是一样的。

在我们的游戏中，我们不会为了区分船只和激光而扩展基本实体类。唯一让他们与众不同的是他们使用的组件以及这些组件是如何使用的。

我们的游戏实体的结构是基本的和中肯的。每个实体都跟踪自己在游戏世界中的位置、指示其状态的标志(无论实体是活动的还是非活动的——死的还是活的)、组件列表和更新功能。此外，为简单起见，每个实体声明一个`draw`函数，该函数将实际绘图委托给`sprite`组件，如果该实体恰好有一个的话。我们还在每个实体中定义了一些通用函数，以便于添加、移除和使用组件。最后，每个实体都允许一个自定义的更新功能，这样每个实例化的实体就可以以不同的方式更新自己。

```
var Packt = Packt || {};
Packt.ENTITY_TYPES = {
  SHIP: 0,
  BULLET: 1
};

Packt.Entity = function(type, x, y) {
  var type = type;
  var pos = {
    x: x,
    y: y
  };

  var isActive = true;
  var components = new Object();

  // Make this function empty by default, and allow the user tooverride it
  var update = function(){};

  // Add a component to this entity if one by this name has notyet been added
  function addComponent(key, component) {
    if (!components[key]) {
      components[key] = component;
    }

    return component;
  }

  // Attempt to remove an entity by its name
  function removeComponent(key) {
    if (components[key]) {
      return delete components[key];
    }

    return false;
  }

  // Return a reference to a component
  function getComponent(key) {
    return components[key] || null;
  }

  // Draw this component
  function draw() {
    if (components.sprite) {
      components.sprite.update();
    }
  }

  // Expose these functions through a public interface
  this.addComponent = addComponent;
  this.removeComponent = removeComponent;
  this.getComponent = getComponent;
  this.getPosition = function() {
    return pos;
  };

  this.setPosition = function(newPos) {
    pos = newPos;
  };

  this.isActive = function() {
    return isActive;
  };

  this.setActive = function(active) {
    isActive = active;
  };

  this.draw = draw;
  this.update = update;
  this.update = function() {
    update();
  };
  // Save a reference to a new update callback function
  this.setOnUpdate = function(cb){
    update = cb;
  };
};
```

可以看到，这个实体类真的是相当的光秃秃的。它考虑了我们的游戏需要做什么，在游戏中使用什么，并在此基础上封装了最常见的功能。从这里，我们可以实例化一个实体，并向它添加组件，使它成为一个非常独特的实体，基于它可能做和不能做的一切。

### /小部件

这个游戏中唯一使用的小部件是`EnergyBar`小部件。小部件的全部意义在于简化不同用户界面元素的管理。每个小部件决定如何显示它们所代表的元素的方式是它们自己的事情，任何使用它们的客户端代码都应该只关心它可以与小部件通信的接口。

`EnergyBar`小部件的作用是在页面顶部显示一个横条，代表玩家还剩多少能量。每当玩家被敌方飞船击中时，它的能量水平就会下降一些。当能量计归零时，玩家死亡，游戏结束。

这个能量条的一种呈现方式是通过画布应用编程接口，小部件直接呈现在游戏画布上。虽然这是一个非常可接受的解决方案，也是一个非常常见的解决方案，但我决定只使用一个普通的旧 DOM 元素。通过这种方式，样式可以通过 CSS 更容易地更改，并且在代码中不需要更改任何其他内容。换句话说，当有人处理实际代码时，第二个人可以处理小部件的样式，他们需要访问的只是与之相关的样式表。

```
var Packt = Packt || {};
Packt.Widgets = Packt.Widgets || {};

Packt.Widgets.EnergyBar = function(cssClass) {
  var energy = 100;

  // Create the DOM element to represent this widget on screen
  var container = document.createElement("div");
  container.classList.add(cssClass);

  var bar = document.createElement("div");
  bar.style.width = energy + "%";
  container.appendChild(bar);

  // Return the DOM element so it can be appended to the document
  this.getElement = function() {
    return container;
  };

  // Increase the player's energy level and update the DOM element
  // that represents it on screen. To decrease the energy level, simply
  // pass a negative number to this function
  this.addEnergy = function(amount) {
    energy += amount;
    bar.style.width = energy + "%";
  };

  // Set the energy level directly, instead of just adding to
  // or removing from it
  this.setEnergy = function(amount) {
    energy = amount;
    bar.style.width = energy + "%";
  };
};
```

当`EnergyBar`小部件被实例化时，它会创建自己的表示小部件的 DOM 元素，添加任何与其相关联的 CSS 类和标识。成员属性能量表示一个实体拥有的能量，并且由小部件创建的 DOM 元素之一的宽度与其包含的能量的百分比相匹配。在一个小部件的元素被添加到文档之后，我们可以简单地通过它的公共接口与小部件类进行通信，并且文档上显示的 DOM 元素会相应地更新。

### Canvas.js

除了`EnergyBar`小部件的之外，在这个游戏中渲染到屏幕上的所有其他东西都是通过画布，使用 2D 渲染上下文来渲染的。为了将东西放在一起，并使代码更有条理，我们在画布 API 上创建了一个非常简单的抽象。我们没有跟踪引用某个 DOM 元素的画布变量及其附带的上下文引用，而是将画布元素、对它的 JavaScript 引用以及对呈现上下文的引用都封装在一个对象中。

```
// Namespace the canvas abstraction
var Packt = Packt || {};

// Construct a canvas of an arbitrary size
Packt.Canvas = function(w, h) {
  var width = w;
  var height = h;
  var canvas = document.createElement("canvas");

  canvas.width = width;
  canvas.height = height;

  var ctx = canvas.getContext("2d");

  this.getCanvas = function() {
    return canvas;
  };

  this.getContext = function() {
    return ctx;
  };

  this.getWidth = function() {
    return width;
  };

  this.getHeight = function() {
    return height;
  };

  // Allow the client to clear the entire rendering buffer without
  // needing to know how things are done under the hood, andwithout
  // anyone needing to worry about the width and height of thecanvas
  this.clear = function() {
    ctx.clearRect(0, 0, width, height);
  };
};
```

我们还通过添加一些助手函数隐藏了画布 API 的一些详细功能，例如`getWidth`、`getHeight`、`clear`，这样代码中的其他区域就可以通过这个简化的界面与画布进行交互。

像这样的抽象非常方便的另一个原因是，如果我们决定使用两个或更多的画布，它将大大简化事情。假设我们想要将一个小部件渲染到它自己的画布中。如果没有这样的抽象，我们现在在代码中将有四个独立的变量需要跟踪。

使用 2D 画布的 HTML5 游戏渲染中常见的优化模式是将渲染分成层。例如，帧与帧之间变化不是很频繁的东西(例如一个级别的背景图形)可以比动态对象更少地被重新渲染，动态对象可能需要在每个帧的不同位置被渲染(玩家和试图杀死英雄的敌人)。我们可以将整个背景场景绘制到自己的画布上，并将其绝对放置在另一个只绘制较小部分的画布后面，这样就可以更容易地重新绘制每一帧，而不是在每一帧都重新绘制背景图形的每个像素，因为大多数像素都与前一帧完全相同。

因为背景层不会经常改变，如果有的话，我们可以在上面渲染更复杂的图形，而不必担心经常在那里重绘任何东西。虽然前景层通常需要每一帧都被清除和重画，但我们仍然可以保持良好的帧速率，因为我们通常只在前景画布的一小部分上渲染，这不像每一帧重画背景层那样需要太多的处理。

![Canvas.js](graphics/6029OT_08_10.jpg)

现在很容易看出，当使用更高级的渲染技术时，一个简单的画布抽象是多么有价值。在大多数情况下，即使我们只是在单个画布上渲染，能够封装与画布相关联的所有松散变量通常会使事情更加高效，尤其是当您需要将画布和画布上下文传递给其他函数和类时。

### 管理人. js

因为我们的游戏的玩家将在整个游戏中只控制一个实体，创建一个实体类的实例并让玩家控制该实体是微不足道的。挑战是找到一种方法来创建敌人实体，移动它们，并随着游戏的进行管理它们。为了解决这个问题，我们创建了一个`EnemyManager`类，其工作是在需要时创建敌方实体并管理它们的存在。

虽然这看起来是一项复杂的任务，但如果我们将任务分解成更小的部分，它会变得更容易管理。`EnemyManager`类的职责包括创建一个新的敌方实体，并将其添加到其存储的活动实体列表中，单独更新每个实体，以及从其管理的实体列表中移除任何死亡实体。

```
// Namespace the enemy manager object
var Packt = Packt || {};

Packt.EnemyManager = function(canvas) {
  var entities = new Array();
  var canvas = canvas;
  var worldWidth = canvas.getWidth();
  var worldHeight = canvas.getHeight();

  // By returning the list of active enemies to the client code,
  // we can pass on the responsibility of rendering each entity,
  // as well as allow other components to interact with theentities
  this.getEntities = function() {
    return entities;
  };

  // Create a new entity at a certain screen location, along
  // with a list of components
  function addEnemies(x, y, components) {
    var entity = new Packt.Entity(Packt.ENTITY_TYPES.SHIP, x || 0,y || -100);
    for (var c in components) {
      entity.addComponent(c, components[c]);
    };

    var strengthComp = new Packt.Components.Strength(entity, 0.5, 25);
    var physComp = new Packt.Components.Physics(entity);
    var mockMove = new Packt.Components.Move(entity, (Math.random() * 5 >> 0) + 2);

    var enemySprite = "./img/enemy-red.png";

    // Randomly assign a different skin to the sprite component
    if (parseInt(Math.random() * 100) % 2 == 0) {
      enemySprite = "./img/spaceship.png";
    }

    var spriteComp = new Packt.Components.Sprite(entity, enemySprite, 64, 64);

    spriteComp.setCtx(canvas.getContext());
    spriteComp.setSpriteCoords(0, 0, 64, 64);
    entity.addComponent("sprite", spriteComp);
    entity.addComponent("move", mockMove);
    entity.addComponent("physics", physComp);
    entity.addComponent("strength", strengthComp);

    // Randomly assign a starting direction to each entity
    var randPathX = (Math.random() * 100 % 10) - 5;
    var randPathY = (Math.random() * 100 % 50) + 10;
    entity.setOnUpdate(function() {
      mockMove.setDirection(randPathX, 1);
      mockMove.update();
    });

    entities.push(entity);
  }

  this.add = addEnemies;

  // Remove dead entities from our management
  this.remove = function(entity) {
    for (var i = 0, len = entities.length; i < len; i++) {
      if (entities[i] === entity) {
        entities.splice(i, 1);
        return entity;
      }
    }

    return null;
  };

  // Update each entity's position, and remove dead entities
  this.update = function() {
    var enemiesDeleted = 0;
    for (var i = 0, len = entities.length; i < len; i++) {
      try {
        entities[i].update();

        var pos = entities[i].getPosition();

        if (pos.y > worldHeight + 100 || !entities[i].isActive())
        {
          entities.splice(i, 1);
          enemiesDeleted++;
        }

        if (pos.x < -100) {
          pos.x = worldWidth + 50;
          entities[i].setPosition(pos);
        } else if (pos.x > worldWidth + 100) {
          pos.x = -50;
          entities[i].setPosition(pos);
        }
      } catch (e) {}
    }

    if (enemiesDeleted > 0) {
      for (var i = 0; i < enemiesDeleted; i++) {
        var offset = (Math.random() * 100 >> 0) % (worldWidth / 75 >> 0);
        var x = 50 * offset + 25 + (25 * offset);
        var y = 0 - Math.random() * 100 - 100;
        addEnemies(x, y, {});
      }
    }
  };
};
```

因为我们使用的是基于组件的架构，这三个任务一点也不复杂。为了创建一个新的实体，我们只需实例化这个类，并添加它运行所需的必要组件。为了给游戏增加多样性，我们可以给每个创建的实体随机分配一个不同的`sprite`以及随机调整每个实体的属性，比如让它移动更快，造成更多伤害，看起来更大等等。

移除死实体甚至更容易。我们所需要做的就是遍历活动实体的列表，如果某个实体的活动标志未设置，就将它们从列表中移除。我们还可以做的一件事是移除任何远离屏幕区域的实体，这样我们就不需要管理那些不可能被玩家激光击中的实体。

最后，更新功能负责更新每个活动实体的位置(或者更确切地说，它告诉每个实体根据它们前进的方向更新自己的位置)，通过向前移动每个实体来模拟一些基本的人工智能，然后移除任何死亡的实体。

### 游戏循环. js

游戏循环类负责运行每一帧的游戏逻辑。我们从使用这样的类中获得的主要附加价值是，我们可以封装这种样板功能，并以最小的努力在不同的设置中重用它。

```
// Namespace the game loop class
var Packt = Packt || {};

Packt.GameLoop = function(fps) {
  var fps = fps;
  var frameDelay = 1000 / fps;
  var lastFrameTime = 0;
  var isRunning = true;

  // By default, the game tick is empty, indicating that we expect
    the client
  // to provide their own update function
  var update = function(){};

  // Once the game loop object is set to running, this functionwill be called
  // as close to the specified frame rate as it can, until theclient code
  // sets the object's running state to false
  function run(time) {
    if (isRunning) {
      var delta = time - lastFrameTime;

      if (delta >= frameDelay) {
        update();
        lastFrameTime = time;
      }

      requestAnimationFrame(run);
    }
  }

  // Allows client code to start/stop the game loop
  this.setRunning = function(running) {
    isRunning = running;
    return isRunning;
  };

  this.isRunning = function() {
    return isRunning;
  };

  this.run = run;

  // Allows client code to override default update function
  this.setOnUpdate = function(cb){
    update = cb;
  };
};
```

当我们创建这个类的一个实例时，我们告诉它我们希望游戏循环以每秒帧数的形式运行多快，并且这个类负责其余部分。一旦设置好了，这个类将以我们告诉它的任何频率来初始化它自己的更新类。作为额外的奖励，我们还可以指定我们自己的更新函数，在每次游戏循环计时时执行。

### PhysicsManager.js

类似于的`EnemyManager`类，`PhysicsManager`类负责隔离复杂的功能，以便客户端代码更清晰，并且功能可以在其他地方重用。因为这个类有点复杂，所以我们不会在书中展示它的完整源代码。和其他章节一样，这本书可以在 Packt 的网站上找到。

总之，`PhysicsManager`类引用了所有的敌方实体(可以从`EnemyManager`对象获得)、所有玩家的激光束以及玩家的实体本身。然后，在其更新方法中，它检查所有这些实体之间的冲突。

### Vec2.js

由于这个游戏的`physics`引擎大量使用了向量结构，并且由于 JavaScript 不提供原生向量数据类型，我们决定创建自己的。这个简单的类表示一个有两个分量的向量，并提供一个函数来规范化这个向量。当我们想要在一个实体面向的任何方向上移动它时，这是特别有用的。

### main.js

最后，我们把所有的放在一个我们称之为`main.js`的文件中。当我去一家快餐店时，这个文件看起来和我很像:拿一个所有的东西，看看它们是如何搭配在一起的。首先我们实例化一个画布对象，然后是玩家实体、`EnemyManager`对象、`PhysicsManager`对象，最后是一个游戏循环对象。一切就绪后，我们开始游戏循环，游戏开始了。

```
(function main(){
  var WIDTH = document.body.offsetWidth;
  var HEIGHT = document.body.offsetHeight;
  var MAX_ENEMIES = 100;

  // The main canvas where the game is rendered
  var canvas = new Packt.Canvas(WIDTH, HEIGHT);
  document.body.appendChild(canvas.getCanvas());

  // The energy widget
  var playerEnergy = new Packt.Widgets.EnergyBar("energyBar");
  document.body.appendChild(playerEnergy.getElement());

  // The player entity, along with its required components
  var player = new Packt.Entity(Packt.ENTITY_TYPES.SHIP,
    canvas.getWidth() / 2, canvas.getHeight() - 100);

  var playerLaserGunComp = new Packt.Components.LaserGun(player, canvas, 10);
  var playerStrengthComp = new Packt.Components.Strength(player, 0, 100);
  var playerMoveComp = new Packt.Components.Drag(player, canvas);
  var playerPhysComp = new Packt.Components.Physics(player);
  var playerSpriteComp = new Packt.Components.Sprite(player, "./img/fighter.png", 64, 64);
  playerSpriteComp.setCtx(canvas.getContext());
  playerSpriteComp.setSpriteCoords(64 * 3, 0, 64, 64);
  player.addComponent("sprite", playerSpriteComp);
  player.addComponent("drag", playerMoveComp);
  player.addComponent("physics", playerPhysComp);
  player.addComponent("strength", playerStrengthComp);
  player.addComponent("laserGun", playerLaserGunComp);

  // Override the player's update function
  player.setOnUpdate(function() {
    var drag = player.getComponent("drag");
    drag.centerEntity();

    var pos = player.getPosition();
    var laserGun = player.getComponent("laserGun");
    laserGun.add(pos.x + 28, pos.y);
    laserGun.update();
  });

  // The enemy manager
  var enMan = new Packt.EnemyManager(canvas);
  for (var i = 0; i < MAX_ENEMIES; i++) {
    var offset = i % (WIDTH / 75 >> 0);
    var x = 50 * offset + 25 + (25 * offset);
    var y = -50 * i + 25 + (-50 * i);
    enMan.add(x, y, {});
  }

  // The physics manager
  var phy = new Packt.PhysicsManager();
  phy.setPlayer(player);

  // The game loop, along with its overriden update function
  var gameLoop = new Packt.GameLoop(60);
  gameLoop.setOnUpdate(function() {
    // Check if game is over
    if (playerStrengthComp.getEnergy() < 0) {
      document.body.classList.add("zoomOut");

      var ctx = canvas.getContext();
      ctx.globalAlpha = 0.01;

      gameLoop.setRunning(false);
    }

    // Add everyone to the physics manager to check for collision
    var enemies = enMan.getEntities();
    for (var i = 0, len = enemies.length; i < len; i++) {
      phy.addEnemy(enemies[i]);
    }

    var playerLasers = playerLaserGunComp.getShots();
    for (var i = 0, len = playerLasers.length; i < len; i++) {
      phy.addPlayerShots(playerLasers[i]);
    }

    // Update positions
    enMan.update();
    player.update();

    // Check for collisions
    phy.checkCollisions();

    // Draw
    canvas.clear();
    for (var i = 0, len = enemies.length; i < len; i++) {
      enemies[i].draw();
    }

    for (var i = 0, len = playerLasers.length; i < len; i++) {
      playerLasers[i].draw();
    }

    player.draw();
    playerEnergy.setEnergy(playerStrengthComp.getEnergy());
  });

  // Get the game going
  gameLoop.run();
})();
```

自调用 main 函数的主要原因是为了私下限定函数中包含的所有变量的范围，以防止用户从浏览器的 JavaScript 控制台操纵游戏。如果游戏变量都存储在全局范围内，任何能够访问它的人都可以操纵游戏状态。此外，由于此函数只是一个设置函数，因此这是放置任何条件逻辑的最佳位置，以便根据执行脚本的用户代理加载替代资源。

### index.html

这个游戏的主机页面再简单不过了。我们在这个文件中所做的就是加载我们所有的资源。由于不同的组件有时依赖于我们游戏中定义的其他组件或其他模块(并且由于 JavaScript 没有提供将单个组件加载到脚本中的机制)，因此我们的 JavaScript 资源的加载顺序非常重要。

```
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>2D Space Shooter</title>
    <link rel="stylesheet" href="./css/style.css" />
  </head>

  <body class="animBody">
    <script src="./js/Vec2.js"></script>
    <script src="./js/components/Sprite.js"></script>
    <script src="./js/components/Move.js"></script>
    <script src="./js/entities/Entity.js"></script>
    <script src="./js/Canvas.js"></script>
    <script src="./js/GameLoop.js"></script>
    <script src="./js/components/TouchDrag.js"></script>
    <script src="./js/components/Physics.js"></script>
    <script src="./js/components/Strength.js"></script>
    <script src="./js/components/LaserGun.js"></script>
    <script src="./js/PhysicsManager.js"></script>
    <script src="./js/EnemyManager.js"></script>
    <script src="./js/widgets/EnergyBar.js"></script>
    <script src="./js/main.js"></script>
  </body>
</html>
```

## 移动优化

在这最后一部分，让我们来看看游戏的几个方面，我们可以(并且应该)特别针对移动设备上的部署进行优化。虽然下面讨论的一些优化在桌面优化方面也有重叠，但它们在移动 web 开发中特别有影响力。

### 组合资源

虽然编写松散的模块化代码是一种很好的实践，但我们绝不能止步于此。在将应用程序部署到生产服务器之前，我们明智的做法是至少将所有这些文件合并到一个文件中。最简单的方法是简单地连接每个文件，并提供那个更大的文件，而不是多个文件。

这种方式优于向客户端发送多个单独文件的原因是，在与同一服务器进行一定量的并发连接后，浏览器会对后续连接进行排队，加载所有文件所需的总时间会增加。

此外，在所有资源都组合成一个资源后，我们还应该使用许多可用的工具之一来压缩、缩小、混淆和丑化我们的代码。对于一个移动玩家来说，我们所能做的任何将代码减少到最小可能字节数的事情都是一大胜利。这项工作的一个特别强大的工具是由谷歌开发的流行的开源闭包编译器。在它的许多特性中，闭包编译器还提供了一个分析最终代码并移除任何不可到达的死代码的功能。这样做将进一步减少应用程序代码的最终大小，使其特别便于通过有限的网络连接下载，例如当今大多数移动设备中的网络连接。

### 通过标识跟踪触摸

我们编写通过触摸处理用户输入的组件的方式假设在任何时候都只使用一次触摸。虽然这个假设在我们的游戏中大多数时候都成立，但在其他游戏中可能不是这样。`TouchDrag`组件总是寻找在改变的触摸列表中找到的第一个触摸对象的触摸信息。唯一的问题是，原始触摸可能并不总是其父数组中的第一个数组元素。

要改变这一点，我们需要做的就是跟踪第一次触摸屏幕的手指的触摸标识，然后根据其识别值来引用该触摸。

```
Packt.Components.TouchDrag = function(entity, canvas) {
  var touchId = 0;

  // When a successful touch is first captured, cache the touch'sidentification
  function doOnTouchDown(event) {
    event.preventDefault();
    var phy = entity.getComponent("physics");
    var touch = event.changedTouches;

    if (phy) {
      touchId = touch.identifier;
      isDown = phy.collide(touch[touchId].pageX, touch[touchId].pageY, 0, 0);
    }
  }

  // Clear the touch flag on the entity, as well as the touch id
  function doOnTouchUp(event) {
    event.preventDefault();
    isDown = false;
    touchId = 0;
  }

  // Always move the entity based on the cached touch id
  function doOnTouchMove(event) {
    event.preventDefault();
    var touch = event.changedTouches;

    if (isDown) {
      pos.x = touch[touchId].pageX;
      pos.y = touch[touchId].pageY;
    }
  }
};
```

通过跟踪的原始触摸并只对其做出响应，我们可以保证触摸输入的保真度，即使在屏幕上启动了多次触摸。这也是跟踪单独触摸的适当方式，以便基于触摸的任意组合来实现手势或其他输入触发。

### 谨慎使用 CSS 动画

有一种奇怪的现象，当我们对一些更新的 CSS 属性过于慷慨时，这种现象有时会在移动浏览器中发生。例如，如果我们给一个元素添加一个盒子阴影，我们仍然可以获得相当强的性能。可选地，如果我们将 CSS 转换添加到一些其他元素，性能仍然可以保持。然而，如果这两个属性一起分配，那么性能会突然下降到几乎无法玩的状态。

由于没有公式来描述哪些属性应该使用和不应该使用，以及哪些组合应该避免，这里的建议是使用尽可能少的 CSS 属性，并慢慢添加它们。在我们的游戏中，桌面版本大量使用 CSS 动画来渲染背景，我们需要考虑这对移动设备的影响。在今天最受欢迎的两个移动平台上尝试这种效果并看到性能严重下降后，我们得出结论，我们想要的特定动画以及不断渲染的画布对于移动处理器来说太难处理了。

确定特定的 CSS 动画在移动设备上是否要求过高的一种方法是使用分析工具，如谷歌开发工具，并记录浏览器需要完成的工作，以实现所需的动画。在像这个游戏这样的情况下，背景细节的生成是如此计算密集，以至于它与简单地玩游戏所需的计算相冲突，我们很可能会选择一个要求较低的替代方案。在这个游戏中，我们不是将 CSS 动画加载到文档主体上，而是简单地显示一个静止的背景图形。

### 为每个游戏层使用单独的画布

正如前面简要讨论的一样，HTML5 渲染中一种强大的优化技术是使用多个画布。关键是不要频繁渲染那些只需要偶尔渲染一次的东西。那些需要更频繁渲染的东西，我们在一个专用的画布上下文中自己渲染，这样就不用 CPU(或 CPU)来渲染这些元素周围的细节。

例如，游戏的背景场景通常在几帧内保持不变。我们可以只在专用画布上渲染一个背景场景，并且只在屏幕滚动或场景发生变化时再次渲染该场景，而不是清除整个画布上下文，只是为了在完全相同的先前位置上重新绘制这些完全相同的像素。在那之前，那块画布不需要被打扰。任何需要每秒渲染多次的可移动对象和实体，只需在第二块画布上渲染即可，背景是透明的，这样背景层就可以被看穿。

在这个游戏中，我们可以很好地将用作背景图形的图像渲染到一个专用的背景层上，然后以这种方式向画布提供背景动画。然而，由于 HTML5 提供了一个类似的功能，产生同样的效果，我们选择了它。

### 使用影像图谱

图像地图集背后的想法真的很棒。由于画布应用编程接口指定了一个函数，该函数允许我们从源图像绘制到画布上下文上，该源图像指定了图像中要进行像素复制的区域，因此我们可以简单地使用一个主图像，从该主图像中可以绘制我们所有的图形资产。

我们可以简单地将所有图像打包成一个地图集文件，然后从这个更大的拼贴画的某个部分中绘制每个资产，而不是将多个松散的图像从服务器发送到客户端。

下面是一个图像地图集，里面有许多并排放置的小图像，允许我们从单个图像资源中检索每个单独的图像。这项技术的主要好处之一是，我们只需要向服务器发出一个 HTTP 请求，就可以访问地图集内使用的所有图像。

![Use image atlases](graphics/6029OT_08_11.jpg)

当然，使用这种技术的挑战是我们需要一种方法来知道每个特定的图像在地图集文件中的位置。虽然在这样一个小项目中手工完成这个任务看起来不太麻烦，但是这个任务的复杂性很快就变得难以驾驭。

有许多开源工具可以用来解决这个问题。这些工具获取单个松散的图像文件，将它们打包成最小的地图集，该地图集可以从提供的图像列表中生成，并且还生成一个 JSON 文件，我们可以使用该文件将每个松散的图像映射到它们在地图集中的新表示。

# 总结

这一章专门介绍了带有新的 HTML5 APIs 的移动开发。我们谈到了开放网络平台中游戏开发者在移动设备方面的巨大机遇，以及与之相关的一些主要挑战。我们讨论了移动网络开发的一些最佳实践，包括优雅地降级和逐步增强、为所有手指尺寸进行设计、尽可能节省电池寿命、规划离线游戏以及提供桌面版应用程序。

本章介绍的最后两个 API 是 CSS 媒体查询和 JavaScript 触摸事件。媒体查询允许我们检查查看文档的用户代理的其他属性，如视口宽度、高度、分辨率、方向等。根据在执行我们的应用程序的用户代理上设置的属性，我们可以使用媒体查询来加载不同的 CSS 规则和文档，从而在运行时有效地修改文档样式。新的 JavaScript 触摸事件与鼠标事件的不同之处在于，允许同时进行多次触摸以及压力检测、触摸大小和旋转角度。

现在您已经了解了 HTML5 的新功能，包括最新的 CSS 和 JavaScript APIs，下一步是让您获得一些键盘时间，并开始为有史以来最大、最令人兴奋的计算平台——开放网络开发自己的游戏。游戏快乐！