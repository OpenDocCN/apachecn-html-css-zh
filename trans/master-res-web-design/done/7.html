<html>
<head><title>Chapter 7. Meaningful Typography for Responsive Web Design</title>
<link rel="stylesheet" href="epub.css" type="text/css"/>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
</head>
<body id="page">
<h1 class="title"><a id="ch07"/>第7章：响应性网页设计的有意义排版</h1>



<p>正如我在代顿网络开发者会议上的一次演讲中所说：</p>
<blockquote class="blockquote"><p><em>“有了坚实的排版比例，你甚至可以在网站上不用一张图片。”</em></p>
</blockquote>

<p>印刷术的力量已经成为网页设计中最被低估的资产之一。诚然，我们看到越来越多的设计都在考虑排版，在创造网站或应用程序的预期氛围方面发挥着重要作用。</p>
<p>在这一章中，我们的重点将放在一些方面，技巧和技巧，我们需要从排版立场考虑RWD的东西。</p>
<p>我们将讨论：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">印刷用像素、ems或REM？</li>
<li class="listitem" style="list-style-type: disc">计算相对字体大小。</li>
<li class="listitem" style="list-style-type: disc">为和谐的排版创建模块化比例。</li>
<li class="listitem" style="list-style-type: disc">使用模块化比例进行排版。</li>
<li class="listitem" style="list-style-type: disc">网页字体及其对RWD的影响。</li>
<li class="listitem" style="list-style-type: disc">流体尺寸标题使用<code class="literal">FitText.js</code>。</li>
<li class="listitem" style="list-style-type: disc">使用<code class="literal">FlowType.js</code>提高易读性。</li>
</ul>

<h1 class="title" id="sigil_toc_id_282"><a id="ch07lvl1sec46"/>用于排版的像素、ems或REM？</h1>



<p><a id="id542" class="indexterm"/>很难决定<a id="id543" class="indexterm"/>是<a id="id544" class="indexterm"/>使用像素、ems还是rems进行排版。这是风格的问题。一些web设计师/开发人员仍然使用像素作为其单位来声明字体大小。只不过把我们的脑袋绕在尺寸上要容易得多。</p>
<p>以像素为单位设置字体大小的问题基本上是在传统IEs上，如果用户出于任何原因想放大页面，文本将保持在给定的像素大小。</p>
<p>现在，就现代浏览器而言，这已经成为过去。当你放大任何现代的<a id="id547" class="indexterm"/>浏览器时，如果它放大到足够大，它将触发媒体查询，从而显示网站的移动版本。</p>
<p>基于像素的字体大小调整的另一个问题是很难缩放和维护。这基本上意味着我们必须在每个媒体查询中一遍又一遍地声明更多元素的字体大小。</p>
<p>另一方面，我们有相对的单位，ems和REM，这几乎是我们推荐的设置字体大小的方法。</p>
<p>然而，ems的问题是，我们必须（在思想上，在CSS/HTML注释中，或在某个文本文件中）跟踪父容器的大小，这很容易成为字体管理的噩梦。ems中的字体大小取决于其父容器的字体大小。因此，如果我们有不同级别的嵌套容器，事情可能会很快变得糟糕，因为跟踪父容器的字体大小并不容易。</p>
<p>但是随后<em>rem</em>出现了。Rem指<em>根em</em>。<em>根</em>是<code class="literal">&lt;html&gt;</code>元素。</p>
<p>Rems带来了两个方面的好处：我们可以使用与我们声明像素相同的心智模型在Rems中声明字体大小，但使用ems等相对单位的好处是。使用rems的唯一问题是传统浏览器不支持此单元，因此需要考虑基于像素的字体大小回退值。这是一个简短的Sass混合来拯救这一天。</p>
<p>但在尝试任何Sass技巧之前，让我们先从本章的核心策略开始。</p>


<h1 class="title" id="sigil_toc_id_283"><a id="ch07lvl1sec47"/>计算相对字体大小</h1>



<p>还记得我们在<a class="link" href="3.html" title="Chapter 3. Mobile-first or Desktop-first?">第3章</a>中提到的<a id="id548" class="indexterm"/>RWD魔术公式吗？<em>移动优先还是桌面优先？</em>：</p>
<p>（目标÷背景）x 100=结果%</p>
<p>当字体大小以像素为单位设置时，还有另一个类似的计算相对字体大小（ems）的神奇公式。唯一的区别是我们没有乘以100。</p>
<p>这是一个公式：</p>
<p>目标÷上下文=结果</p>
<p><em>目标</em>是以像素为单位定义的字体大小。<em>上下文</em>是父容器中定义的字体大小。<em>结果</em>是ems中定义的值。</p>
<p>下面是一个示例，考虑到父容器（本例中的主体）中的字体大小为16px：</p>
<pre class="programlisting">header {
    font: 30px Arial, "Helvetica Neue", Helvetica, sans-serif;
}</pre>

<p>为了<a id="id549" class="indexterm"/>计算相对字体大小，我们使用以下公式：</p>
<p><em>30px÷16px=1.875em</em>。</p>
<p>因此，我们的CSS规则如下所示：</p>
<pre class="programlisting">header {
    font: 1.875em Arial, "Helvetica Neue", Helvetica, sans-serif;
}</pre>

<p>我们必须对设计中的每种字体大小都这样做。</p>
<p>就理解数学而言，这很好。然而，真正的价值在于首先创建这些基于像素的值的思考过程。这就是模块化规模的由来。</p>

<h1 class="title" id="sigil_toc_id_284"><a id="ch07lvl1sec48"/>为和谐的排版创建模块化比例</h1>



<p><a id="id550" class="indexterm"/>模块化量表由蒂姆·布朗<a id="id551" class="indexterm"/>创建。有不同的方法来创建排版的模块化比例。在我们的示例中，我们将使用两个基数和一个比率创建一个模块化比例。这些数字的乘法创建了一个在所有值之间和谐且成比例的刻度。</p>
<p>最著名的比例是<em>黄金比例</em>也称为<em>黄金分割</em>、<em>神圣比例</em>等等。其值为<em>1.618</em>。</p>
<p>现在，为了避免不必要的数学运算，黄金分割率基于斐波那契序列：1、1、2、3、5、8、13、21等等。</p>
<p>这些数字具有以下模式：下一个数字是前两个数字相加的结果。例如：</p>
<p>所以0加T0，1加T2，1加T3等于2加T4，1乘T5等于3加T6，2乘T7等于5加T8，3乘T9等于8加T10，5乘T11等于13加T12，8乘T13，也就是21。</p>
<p>这里的想法是理解创建一组在一起使用时和谐的数字的意图。我们也将使用模块化规模的web应用程序创建一个排版规模，用于我们的项目中，而忘记手动计算项目的相对字体大小。</p>
<p>那么让我们来看看由蒂姆·布朗和斯科特·凯勒姆构建的模块化网络应用程序：<a class="ulink" href="http://www.modularscale.com/">http://www.modularscale.com/ </a>。</p>
<p>一旦<a id="id553" class="indexterm"/>web应用程序打开，我们需要<a id="id554" class="indexterm"/>三个步骤来创建我们的模块化规模：</p>
<ol class="orderedlist arabic"><li class="listitem">定义第一个基数。</li>
<li class="listitem">定义第二个基数。</li>
<li class="listitem">选择一个比率。</li>
</ol>

<h3 class="title" id="sigil_toc_id_285"><a id="tip73"/>提示</h3>
<p>模块化比例可以用于任何使用某种值的东西，而不仅仅是排版。可用于<code class="literal">padding</code>、<code class="literal">margin</code>、<code class="literal">line-height</code>等。然而，我们在本章的重点是排版。</p>


<h2 class="title" id="sigil_toc_id_286"><a id="ch07lvl2sec82"/>定义第一个基数</h2>



<p><a id="id555" class="indexterm"/>建议定义第一个数字的方法是使用正文文本大小，即段落中使用的字体大小。但请记住，使用正文文本大小作为第一个基数不是强制性的。我们可以使用字体的x高度，或者字体中的其他长度，我们认为这可能是一个很好的起点。</p>
<p>尽管我们可以选择任何字体大小，但让我们从所有浏览器都使用的默认字体16px开始。所以我们在第一个基本字段中输入<code class="literal">16px</code>。</p>
<p>单击加号图标并添加第二个基本字段。</p>
<h3 class="title" id="sigil_toc_id_287"><a id="tip74"/>提示</h3>
<p>不要担心应用程序的字体大小预览，正如您所看到的，当我们为基本值键入数字时，右侧预览窗格中的字体大小会发生变化。我们将在下一步中实现这一点。</p>



<h2 class="title" id="sigil_toc_id_288"><a id="ch07lvl2sec83"/>定义第二个基数</h2>



<p><a id="id556" class="indexterm"/>第二个基本字段是我所说的<em>幻数</em>，因为这个数字完全是主观的和任意的，然而，它与我们正在进行的项目密切相关。</p>
<p>当我说<em>紧密相关</em>时，我的意思是使用主容器的宽度，例如960px、980px、1140px等等。或者，它也可以是网格中使用的列数，例如12或16。它也可以是站点最大宽度处的柱宽度，例如60px，甚至是排水沟间距，例如20px。</p>
<p>这个<em>魔法数字</em>是我们想要的任何东西，但它以某种方式与我们的项目直接相关。在这个例子中，假设我们的目标屏幕的最大宽度为1280px，那么我们的主容器的最大宽度为1140px。因此，让我们在第二个基本字段中键入<code class="literal">1140px</code>。</p>

<h2 class="title" id="sigil_toc_id_289"><a id="ch07lvl2sec84"/>选择一个比率</h2>



<p>这就是魔法发生的地方。选择一个比率意味着该比率将乘以基数，创建成比例相关的数值比例。</p>
<p>这些比率是基于音阶的，如果我们决定使用黄金比率（1.618），那么在这个列表中也有黄金比率。从<strong>比率</strong>下拉列表中，选择<strong>1:1.618–黄金分割</strong>比率。</p>
<p>就这样！我们现在已经创建了第一个模块化量表。</p>
<p>此模块化比例尺提供的字体大小完全协调，因为它们根据与我们的项目直接相关的相关值相互成比例：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">理想的正文字体大小是16px</li>
<li class="listitem" style="list-style-type: disc">我们主容器的最大宽度是1140px</li>
<li class="listitem" style="list-style-type: disc">黄金比率为1.618</li>
</ul>

<p>我们的排版现在有一个坚实的模块化基础，让我们使用它。</p>


<h1 class="title" id="sigil_toc_id_290"><a id="ch07lvl1sec49"/>使用模块化比例进行排版</h1>



<p>如果您<a id="id559" class="indexterm"/>点击<strong>表</strong>视图，所有文本都将消失，我们将看到一个字体大小列表，范围从可笑的小值到同样可笑的大值。不过没关系。这就是模块化秤的威力。</p>
<p>这就是我们看到的：</p>
<p><img src="img/B02102_07_01.jpg" alt="Using the Modular Scale for typography"/></p>
<p>如上图所示，共有三列：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">第一列以像素为单位显示字体大小。</li>
<li class="listitem" style="list-style-type: disc">第二列显示ems中的字体大小。</li>
<li class="listitem" style="list-style-type: disc">如果基数为16px，则第三列显示字体大小。</li>
</ul>

<p><a id="id560" class="indexterm"/>我们需要做的是只关注第一列和第二列。突出显示的一行表示16px或1em，这将是我们段落的字体大小。16px是大多数浏览器的默认字体大小。</p>
<p>然后，我们定义标题元素。假设我们只定义了<code class="literal">h1</code>、<code class="literal">h2</code>和<code class="literal">h3</code>。这意味着我们将选择16px以上的行，这些行具有较大的字体大小：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;h1&gt;</code>：<strong>39.269px</strong>即2.454em</li>
<li class="listitem" style="list-style-type: disc"><code class="literal">&lt;h2&gt;</code>：<strong>25.888px</strong>即1.618em</li>
<li class="listitem" style="list-style-type: disc"><code class="literal">&lt;h3&gt;</code>：<strong>24.57px</strong>即1.517em</li>
</ul>

<p>对于<code class="literal">&lt;small&gt;</code>元素，如果我们的网站上有任何免责声明，我们选择16px以下的字体大小：</p>
<p><code class="literal">&lt;small&gt;</code>：<strong>9.889px</strong>即0.618em</p>
<p>就这样！这个模块化量表中的所有数字都是和谐的，当一起使用时，将提供一个清晰的视觉层次，以及一种难以通过其他方法获得的关系。</p>
<p>这里有一个例子。</p>
<p>这是HTML：</p>
<pre class="programlisting">&lt;h1&gt;Meaningful Typography for RWD&lt;/h1&gt;
&lt;blockquote&gt;
    &lt;p&gt;"With a solid typographic scale you might even get away with not using a single image on your website."&lt;/p&gt;
    &lt;p&gt;— Ricardo Zea&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Creating a Modular Scale for a Harmonious Typography&lt;/h2&gt;
&lt;p&gt;A Modular Scale is a combination of a ratio of two or more numbers, and a base number.&lt;/p&gt;
&lt;h3&gt;The Golden Ratio&lt;/h3&gt;
&lt;p&gt;The most well-known ratio is the Golden Ratio also known as the Golden Section, Divine Proportion, etc. It's value is 1.618.&lt;/p&gt;</pre>

<p>这是SCSS：</p>
<pre class="programlisting">//Mobile-first Media Query Mixin
@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content; }
}
body {
    font:16px/1.4 Arial, "Helvetica Neue", Helvetica, sans-serif;
    @include forLargeScreens(640) {
        font-size: 20px;
    }
}
h1 { font-size: 2.454em; }
h2 { font-size: 1.618em; }
h3 { font-size: 1.517em; }</pre>

<h3 class="title" id="sigil_toc_id_291"><a id="tip75"/>提示</h3>
<p>注意，我是如何将mobilefirst-Sass混入其中的。</p>


<p>以下是<a id="id561" class="indexterm"/>编译的CSS：</p>
<pre class="programlisting">body {
    font: 16px/1.4 Arial, "Helvetica Neue", Helvetica, sans-serif;
}
@media (min-width: 40em) {
    body {
        font-size: 20px;
    }
}
h1 {
    font-size: 2.454em;
}
h2 {
    font-size: 1.618em;
}
h3 {
    font-size: 1.517em;
}</pre>

<p>在小屏幕（510px宽）上，模块化比例如下所示：</p>
<p><img src="img/B02102_07_02.jpg" alt="Using the Modular Scale for typography"/></p>
<p>而<a id="id562" class="indexterm"/>在大屏幕（850px宽）上也是如此：</p>
<p><img src="img/B02102_07_03.jpg" alt="Using the Modular Scale for typography"/></p>
<p>这里唯一的潜在问题是我之前提到的关于使用ems的问题：跟踪父元素的字体大小可能会变成字体管理的噩梦。</p>
<p>使用像素是不可能的，因为它在传统浏览器中存在可伸缩性问题。然而，使用rems可以使事情保持在“相对字体大小”的范围内，同时提供基于像素的思维方式，但不存在可伸缩性问题。这使我们能够支持不支持rems的传统浏览器。</p>
<p>下面是我在CodePen中为此创建的一个<a id="id564" class="indexterm"/>演示：</p>
<p><a class="ulink" href="http://codepen.io/ricardozea/pen/0b781bef63029bff6155c00ff3caed85">http://codepen.io/ricardozea/pen/0b781bef63029bff6155c00ff3caed85 </a></p>
<h2 class="title" id="sigil_toc_id_292"><a id="ch07lvl2sec85"/>rems到Sass的混合</h2>



<p><a id="id565" class="indexterm"/>我们只需要一个Sass mixin，它允许我们在没有特定单位的情况下设置字体值，mixin负责为现代浏览器添加基于rem的字体大小，为传统浏览器添加基于像素的字体大小。</p>
<p>这是Chris Coyer创建的Sass mixin：</p>
<pre class="programlisting">//Pixels to Rems Mixin
@mixin fontSize($sizeValue: 1.6) {
    font-size: ($sizeValue * 10) + px;
    font-size: $sizeValue + rem;
}</pre>

<h3 class="title" id="sigil_toc_id_293"><a id="tip76"/>提示</h3>
<p>我对mixin的原始名称做了一个小小的修改，从使用dash separated改为camelCase。我这样做的原因是，在扫描文档时，可以更容易地从类名中找到mixin的名称。</p>


<p><a id="id566" class="indexterm"/>用法如下：</p>
<pre class="programlisting">@include fontSize(2);</pre>

<p>本例使用了与前一章相同的标记，因此我将仅向您展示SCS和一些屏幕截图。</p>
<p>SCSS如下所示：</p>
<pre class="programlisting">//Mobile-first Media Query Mixin
@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content; }
}
<strong>//Pixels to Rems Mixin</strong>
<strong>@mixin fontSize($sizeValue: 1.6) {</strong>
<strong>    font-size: ($sizeValue * 10) + px;</strong>
<strong>    font-size: $sizeValue + rem;</strong>
<strong>}</strong>
//Base-10 model
html { font-size: 62.5%;
    @include forLargeScreens(640) {
        font-size: 75%;
    }
}
h1 { @include fontSize(3.9269); }
h2 { @include fontSize(2.5888); }
h3 { @include fontSize(2.457); }
p { @include fontSize(1.6); }</pre>

<p>考虑以下几点：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">我们将根字体大小设置为62.5%，这将字体大小减少到10px。这使得声明字体值更加容易。例如，字体大小1.2rem与12px相同，8rem与8px相同，依此类推。</li>
<li class="listitem" style="list-style-type: disc">在rems中声明字体大小时，我们需要将小数点从基于像素的值向左移动一个点。例如，根据我们的模块化比例，<code class="literal">&lt;h1&gt;</code>像素大小为39.269px，因此在rems中声明字体大小时，我们将其声明为3.9269，<em>而无单位</em>。</li>
</ul>

<p>已编译的CSS如下所示：</p>
<pre class="programlisting">html {
    font-size: 62.5%;
}
@media (min-width: 40em) {
    html {
        font-size: 75%;
    }
}
h1 {
    font-size: 39.269px;
    font-size: 3.9269rem;
}
h2 {
    font-size: 25.888px;
    font-size: 2.5888rem;
}
h3 {
    font-size: 24.57px;
    font-size: 2.457rem;
}
p {
    font-size: 16px;
    font-size: 1.6rem;
}</pre>

<p>这<a id="id567" class="indexterm"/>是在小屏幕（510px宽）上使用rems到像素混合的模块化比例：</p>
<p><img src="img/B02102_07_04.jpg" alt="The rems-to-pixels Sass mixin"/></p>
<p>这是<a id="id568" class="indexterm"/>在大屏幕（850px宽）上的样子：</p>
<p><img src="img/B02102_07_05.jpg" alt="The rems-to-pixels Sass mixin"/></p>
<p>下面是我在CodePen中为此创建的一个<a id="id569" class="indexterm"/>演示：</p>
<p>T0http://codepen.io/ricardozea/pen/8a95403db5b73c995443720475fdd900 T1</p>
<p>我们刚才看到的示例使用的是系统字体Arial。让我们继续用一些网页字体来修饰这些例子，让它们更具<em>字符</em>。</p>


<h1 class="title" id="sigil_toc_id_294"><a id="ch07lvl1sec50"/>网页字体及其对RWD的影响</h1>



<p>网页<a id="id570" class="indexterm"/>字体现在几乎是必须使用的，我说<em>几乎是</em>，因为<a id="id571" class="indexterm"/>我们需要注意它们给我们的项目带来的影响，如果有必要，我们实际上可能根本不使用它们。</p>
<p>在我们深入了解如何使用web字体之前，以下是一些web字体资源，它们可能会对您中的许多人有所帮助：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>字体松鼠</strong>（<a class="ulink" href="http://www.fontsquirrel.com/">http://www.fontsquirrel.com/ </a>：我已经广泛使用这项服务<a id="id572" class="indexterm"/>并取得了巨大成功。要使用<a id="id573" class="indexterm"/>字体，您需要下载文件，然后在CSS中与<code class="literal">@font-face</code>一起使用。他们有你能找到的最好的网页字体生成器<a id="id574" class="indexterm"/>工具（<a class="ulink" href="http://www.fontsquirrel.com/tools/webfont-generator">http://www.fontsquirrel.com/tools/webfont-generator </a></li>
<li class="listitem" style="list-style-type: disc"><strong>谷歌字体</strong><a class="ulink" href="https://www.google.com/fonts">https://www.google.com/fonts </a>：如果不提到谷歌<a id="id576" class="indexterm"/>字体，我就无法谈论网络字体<a id="id575" class="indexterm"/>资源。如果我在Font Squirrel上找不到它，我会来这里，反之亦然。您可以下载字体文件或使用JavaScript。以下示例中使用的字体是从Google字体下载的（<a class="ulink" href="https://github.com/google/fonts/tree/master/ofl/oswald">https://github.com/google/fonts/tree/master/ofl/oswald </a>。</li>
<li class="listitem" style="list-style-type: disc"><strong>Adobe Edge网页字体</strong>（<a class="ulink" href="https://edgewebfonts.adobe.com/">https://edgewebfonts.adobe.com/ </a>：这也是<a id="id578" class="indexterm"/>一个很棒的工具。此服务由TypeKit（第一个web字体服务）提供支持。我也广泛使用了TypeKit。您<a id="id579" class="indexterm"/>无法下载字体，您必须使用<a id="id580" class="indexterm"/>JavaScript。</li>
</ul>

<p>现在，让我们<a id="id581" class="indexterm"/>看看使用网页字体的利弊：</p>
<p><a id="id582" class="indexterm"/>的优点是：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">它们有助于突出品牌，并在不同媒体之间建立一致性。</li>
<li class="listitem" style="list-style-type: disc">如果使用得当，它们会使设计看起来更吸引人。</li>
<li class="listitem" style="list-style-type: disc">不再需要使用图像替换技术。</li>
<li class="listitem" style="list-style-type: disc">这使文本保持为HTML格式，使内容更易于访问和<em>可索引</em>。</li>
<li class="listitem" style="list-style-type: disc">传统浏览器支持web字体。</li>
<li class="listitem" style="list-style-type: disc">免费字体的巨大资源。</li>
<li class="listitem" style="list-style-type: disc">所有这些反过来又有助于保持标记的整洁。</li>
</ul>

<p><a id="id583" class="indexterm"/>缺点是：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">由于HTTP请求或对第三方服务器的依赖性，它们会减慢网站/应用程序的速度。</li>
<li class="listitem" style="list-style-type: disc">并非所有的网页字体在大小上都清晰可辨。</li>
<li class="listitem" style="list-style-type: disc">如果需要支持传统浏览器，则需要管理更多文件。</li>
<li class="listitem" style="list-style-type: disc">授权使用字体需要某种形式的付款：每月、每种字体系列、每种字体样式，等等。</li>
<li class="listitem" style="list-style-type: disc">一些免费字体没有很好地构建。</li>
<li class="listitem" style="list-style-type: disc">存在渲染副作用：<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>未设置样式的文本</strong>（<strong>FOUT</strong>）闪烁：在现代浏览器上，当页面<a id="id584" class="indexterm"/>加载时，文本首先以系统字体呈现在屏幕上，然后再以web字体交换和设置样式。</li>
<li class="listitem" style="list-style-type: disc"><strong>不可见文本的闪烁</strong>（<strong>FOIT</strong>）：在传统浏览器上，当页面<a id="id585" class="indexterm"/>加载时，文本不可见，但一秒钟后会使用web字体呈现。</li>
</ul>
</li>
</ul>

<p>还有<a id="id586" class="indexterm"/>其他不值得进入的内容，如回退文本的<strong>闪现和虚假文本</strong>的<a id="id587" class="indexterm"/><strong>闪现（<strong>FOFT</strong>）。</strong></p>
<p>如何<a id="id588" class="indexterm"/>处理所有“任何文本的闪光”不属于本节<a id="id589" class="indexterm"/>的范围。但是，我鼓励您阅读Zach Leatherman在Opera博客上的文章<em>Better@Font face with Font Load Events</em>（<a class="ulink" href="https://dev.opera.com/articles/better-font-face/">中关于字体加载事件的<a id="id590" class="indexterm"/>https://dev.opera.com/articles/better-font-face/ </a>）。</p>

<h1 class="title" id="sigil_toc_id_295"><a id="ch07lvl1sec51"/>用于实现web字体的Sass mixin</h1>



<p>为了<a id="id591" class="indexterm"/>实现web字体，我们需要在CSS中使用<code class="literal">@font-face</code>指令……嗯，SCSS。</p>
<p><code class="literal">@font-face</code>声明块在其香草CSS形式中如下所示：</p>
<pre class="programlisting">@font-face {
    font-family: fontName;
    src: url('path/to/font.eot'); /*IE9 Compat Modes*/
    src: url('path/to/font.eot?#iefix') format('embedded-opentype'), /*IE6-IE8 */
        url('path/to/font.woff') format('woff'), /*Modern Browsers*/
        url('path/to/font.ttf') format('truetype'), /*Safari, Android, iOS*/
        url('path/to/font.svg#fontName') format('svg'); /*iOS devices*/
    font-weight: normal;
    font-style: normal;
}</pre>

<p>现在，如果您使用多个样式或字体系列，则需要为每个字体文件重复整个<code class="literal">@font-face</code>声明块。这不是很干（不要重复）。</p>
<h3 class="title" id="sigil_toc_id_296"><a id="tip77"/>提示</h3>
<p>Web字体在文件大小和服务器请求方面非常昂贵，因此请适度使用Web字体。你使用的越多，你的网站/网络应用程序就会变得越慢。</p>


<p>是的，这是一个相当强大的CSS来处理网页字体，哦，伙计。</p>
<p>为了保持理智，让我们将前面的<code class="literal">@font-face</code>CSS声明块转换为Sass mixin：</p>
<pre class="programlisting">@mixin fontFace($font-family, $file-path) {
    @font-face {
        font: {
            family: $font-family;
            weight: normal;
            style: normal;
        }
        //IE9 Compat Modes
        src: url('#{$file-path}.eot');
        //IE6-IE8
        src: url('#{$file-path}.eot?#iefix') format('embedded-opentype'),
        //Modern Browsers
        url('#{$file-path}.woff') format('woff'),
        //Safari, Android, iOS
        url('#{$file-path}.ttf') format('truetype'),
        //Safari, Android, iOS
        url('#{$file-path}.svg') format('svg');
    }
}</pre>

<p><a id="id592" class="indexterm"/>用法是调用字体文件的一行代码。让我们使用Oswald字体：</p>
<pre class="programlisting">@include fontFace(oswald-light, '../fonts/oswald-light');</pre>

<p>在任何元素上使用它都需要在字体堆栈的开头添加字体名称，如下所示：</p>
<pre class="programlisting">p { font: 2.2rem oswald-bold, Arial, "Helvetica Neue", Helvetica, sans-serif; }</pre>

<p>如果需要包含多个字体文件，只需添加另一行调用mixin，但指定其他字体名称：</p>
<pre class="programlisting">@include fontFace(oswald-light, '../fonts/oswald-light');
<strong>@include fontFace(oswald-regular, '../fonts/oswald-regular');</strong>
</pre>

<p>前两行代码将编译为以下CSS：</p>
<pre class="programlisting">@font-face {
    font-family: oswald-light;
    font-weight: normal;
    font-style: normal;
    src: url("../fonts/oswald-light.eot");
    src: url("../fonts/oswald-light.eot?#iefix") format("embedded-opentype"), url("../fonts/oswald-light.woff") format("woff"), url("../fonts/oswald-light.ttf") format("truetype"), url("../fonts/oswald-light.svg") format("svg");
}
@font-face {
    font-family: oswald-regular;
    font-weight: normal;
    font-style: normal;
    src: url("../fonts/oswald-regular.eot");
    src: url("../fonts/oswald-regular.eot?#iefix") format("embedded-opentype"), url("../fonts/oswald-regular.woff") format("woff"), url("../fonts/oswald-regular.ttf") format("truetype"), url("../fonts/oswald-regular.svg") format("svg");
}</pre>

<p>这是一种很好的方式，只需两行代码就可以创建所有CSS，是吗？但是，如果我们想纠正错误，让我们分析一下我们在这里做的事情：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">我们支持传统浏览器：<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">IE8及以下，带有<code class="literal">.eot</code>字体。</li>
<li class="listitem" style="list-style-type: disc">iOS中Android上的老Safari，字体为<code class="literal">.ttf</code>。</li>
<li class="listitem" style="list-style-type: disc">旧的iOS，用于几乎被遗忘的iPhone3及以下版本，带有<code class="literal">.svg</code>文件。</li>
</ul>
</li>
<li class="listitem" style="list-style-type: disc">现代浏览器只需要<code class="literal">.woff</code>字体。根据CanIUse.com的数据，<code class="literal">.woff</code>字体文件的支持率为99%，但在<a id="id594" class="indexterm"/>撰写本书时（<a class="ulink" href="http://caniuse.com/#search=woff">的Opera Mini除外http://caniuse.com/#search=woff </a>）。</li>
</ul>

<p>所以问题是：我们能否优雅地降低传统浏览器和操作系统的体验，让它们改用系统字体？</p>
<p>当然可以！</p>
<p>将mixin优化为仅使用<code class="literal">.woff</code>字体后，看起来是这样的：</p>
<pre class="programlisting">@mixin fontFace($font-family, $file-path) {
    @font-face {
        font: {
            family: $font-family;
            weight: normal;
            style: normal;
        }
      //Modern Browsers
        src: url('#{$file-path}.woff') format('woff');
    }
}</pre>

<p>用法完全相同：</p>
<pre class="programlisting">@include fontFace(oswald-light, '../fonts/oswald-light');
@include fontFace(oswald-regular, '../fonts/oswald-regular');</pre>

<p>编译后的CSS要短得多：</p>
<pre class="programlisting">@font-face {
    font-family: oswald-light;
    font-weight: normal;
    font-style: normal;
    src: url("../fonts/oswald-light.woff") format("woff");
}
@font-face {
    font-family: oswald-regular;
    font-weight: normal;
    font-style: normal;
    src: url("../fonts/oswald-regular.woff") format("woff");
}</pre>

<p>在几个元素上使用它<a id="id595" class="indexterm"/>如下所示：</p>
<pre class="programlisting">h1 { font: 4.1rem oswald-regular, Arial, "Helvetica Neue", Helvetica, sans-serif; }
p { font: 2.4rem oswald-light, Arial, "Helvetica Neue", Helvetica, sans-serif; }</pre>

<p>只使用<code class="literal">.woff</code>字体可以大大减少文件管理的工作量，这有助于将我们的大脑从不必要的任务中解放出来，让我们专注于最重要的事情：建立一个难忘的体验。更不用说，它使我们的CSS代码更加精简和可伸缩。</p>
<p>但是等等，我们让传统浏览器优雅地降级为系统字体，我们仍然需要为它们定义像素大小！</p>
<p>像素到rems Sass混合到救援中！</p>
<p>记住在<code class="literal">&lt;html&gt;</code>标签中看到base-10模型，以便于计算：</p>
<pre class="programlisting">//Base-10 model
html { font-size: 62.5%; }</pre>

<p>然后，让我们声明字体大小和字体系列：</p>
<pre class="programlisting">h1 {
    @include fontSize(4.1);
    font-family: oswald-regular, Arial, "Helvetica Neue", Helvetica, sans-serif;
}
p {
    @include fontSize(2.4);
    font-family: oswald-light, Arial, "Helvetica Neue", Helvetica, sans-serif;
}</pre>

<p>编译后的CSS如下所示：</p>
<pre class="programlisting">h1 {
    font-size: 41px;
    font-size: 4.1rem;
    font-family: oswald-regular, Arial, "Helvetica Neue", Helvetica, sans-serif;
}

p {
    font-size: 24px;
    font-size: 2.4rem;
    font-family: oswald-light, Arial, "Helvetica Neue", Helvetica, sans-serif;
}</pre>

<h3 class="title" id="sigil_toc_id_297"><a id="tip78"/>提示</h3>
<p>我们在同一规则中声明了两种不同的字体大小，因此在这种情况下不能使用字体速记。</p>


<p>因此，通过<a id="id596" class="indexterm"/>利用两个简单的Sass混合的超级功能，我们可以轻松嵌入web字体并使用rems调整字体大小，同时为传统浏览器提供基于像素的字体大小。</p>
<p>这是一个健壮的可伸缩性的好例子。</p>
<p>下面是我在CodePen中为此创建的一个<a id="id597" class="indexterm"/>演示：</p>
<p>T0http://codepen.io/ricardozea/pen/9c93240a3404f12ffad83fa88f14d6ef T1</p>
<p>在不失去任何动力的情况下，让我们换个角度，讨论一下如何通过简单聚焦，使用令人敬畏的FlowType.js jQuery插件实现最小行长，从而提高页面的易读性。</p>

<h1 class="title" id="sigil_toc_id_298"><a id="ch07lvl1sec52"/>使用FlowType.js提高易读性</h1>



<p>最引人注目的编辑原则之一是，最清晰的排版的理想行长在45到75个字符之间。</p>
<p>如果你问我的话，这是一个相当不错的范围。然而，实际上，让你的段落足够长，或者足够短，就像是一个“盲人领导盲人”的游戏。我们如何判断容器宽度和字体大小的组合是否符合45到75个字符的建议？此外，在小型或中型屏幕上，您如何判断情况是这样？</p>
<p>棘手的一个，嗯？</p>
<p>不用担心，因为使用FlowType.js，我们可以解决这些问题。</p>
<p>您可以<a id="id599" class="indexterm"/>从<a class="ulink" href="http://simplefocus.com/flowtype/">下载插件http://simplefocus.com/flowtype/ </a>。</p>
<p>我们首先需要的是HTML，下面是我们将要使用的标记：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;!--[if IE 8]&gt; &lt;html class="no-js ie8" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if IE 9]&gt; &lt;html class="no-js ie9" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if gt IE 9]&gt;&lt;!--&gt;&lt;html class="no-js" lang="en"&gt;&lt;!--&lt;![endif]--&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;Meaningful Typography for RWD&lt;/title&gt;
    &lt;script src="//code.jquery.com/jquery-latest.min.js"&gt;&lt;/script&gt;
    &lt;script src="js/flowtype.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;main class="main-ctnr" role="main"&gt;
        &lt;h1&gt;Meaningful Typography for RWD&lt;/h1&gt;
        &lt;blockquote&gt;
            &lt;p&gt;"With a solid typographic scale you might even get away with not using a single image on your website."&lt;/p&gt;
            &lt;p&gt;— Ricardo Zea&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;One of the most compelling editorial principles states that the ideal line length for the most legible typography is between 45 and 75 characters.&lt;/p&gt;
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<p>一旦您熟悉FlowType.js，您可能会开始思考，“如果FlowType在几乎任何视口宽度下自动修改字体大小，我认为我不需要在我的SCS中声明任何字体大小！毕竟，它们将被FlowType覆盖。”</p>
<p>不管怎样，我们都需要设置字体大小，因为如果不加载FlowType.js，我们将任由浏览器的默认样式支配，我们设计师不希望这样。</p>
<p><a id="id600" class="indexterm"/>说到这里，下面是SCS来声明必要的字体大小：</p>
<pre class="programlisting">//Pixels to Rems Mixin
@mixin font-size($sizeValue: 1.6) {
    font-size: ($sizeValue * 10) + px;
    font-size: $sizeValue + rem;
}
//Base-10 model
html { font-size: 62.5%; }
h1 { @include fontSize(3.9269); }
p { @include fontSize(1.6); }</pre>

<p>这将编译为以下CSS：</p>
<pre class="programlisting">html {
    font-size: 62.5%;
}
h1 {
    font-size: 39.269px;
    font-size: 3.9269rem;
}
p {
    font-size: 16px;
    font-size: 1.6rem;
}</pre>

<p>这就是魔法发生的地方。我们创建了一个jQuery函数，可以在其中指定要针对的元素。此函数可以放在单独的JavaScript文件中，也可以放在标记中。</p>
<p>在我们的示例中，我们告诉FlowType.js将字体的大小调整应用于<code class="literal">&lt;html&gt;</code>元素。因为我们使用的是相对字体大小单位rems，所以所有文本都会在任何屏幕宽度下自动调整大小，保持理想的行长。</p>
<p>以下是jQuery函数：</p>
<pre class="programlisting">$(function() {
    $("html").flowtype();
});</pre>

<h2 class="title" id="sigil_toc_id_299"><a id="ch07lvl2sec86"/>定义阈值</h2>



<p>我们刚才看到的解决方案有一个潜在的问题：FlowType.js将无限期地修改段落的字体大小。换句话说，在小屏幕上，文本将非常小，而在大屏幕上，文本将太大。</p>
<p>我们可以使用两种单独的阈值方法或两者的组合来解决这个问题。</p>
<p>现在，我们需要弄清楚的一件事是，这一部分需要一些调整和调整，以获得最佳结果，没有特定的值适用于所有情况。</p>
<p>我们将采用以下方法：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">定义容器或元素的最小和最大宽度。</li>
<li class="listitem" style="list-style-type: disc">定义容器或元素的最小和最大字体大小。</li>
</ul>

<h3 class="title" id="sigil_toc_id_300"><a id="ch07lvl3sec48"/>阈值宽度</h3>



<p>定义<a id="id602" class="indexterm"/>最小和最大宽度将告诉FlowType.js应该在哪些点停止调整大小。</p>
<p>让我们定义宽度阈值：</p>
<pre class="programlisting">$(function() {
    $("html").flowtype({
      //Max width at which script stops enlarging
        <strong>maximum: 980,</strong>
      //Min width at which script stops decreasing
      <strong>minimum: 320</strong>
   });
});</pre>

<h3 class="title" id="sigil_toc_id_301"><a id="tip79"/>提示</h3>
<p>我选择的阈值特别适用于本例，但不一定适用于其他情况。调整和测试，直到获得理想的宽度，每行推荐45-75个字符。</p>



<h3 class="title" id="sigil_toc_id_302"><a id="ch07lvl3sec49"/>阈值字体大小</h3>



<p>就像<a id="id603" class="indexterm"/>使用宽度阈值一样，定义最小和最大字体大小将告诉FlowType.js它应该缩放文本的最小和最大字体大小。</p>
<p>我们还将使用<code class="literal">fontRatio</code>变量声明我们自己的字体大小；数字越大，字体越小；数字越小，字体越大。如果这感觉违反直觉，请这样看：数字越高，压缩越高（因此使其变小），数字越低，压缩越低（因此使其变大）。</p>
<p>调整<code class="literal">fontRatio</code>值是一项<em>目不转睛的</em>练习，因此调整并测试，就像没有明天一样。</p>
<p>让我们看一看字体大小值：</p>
<pre class="programlisting">$(function() {
 $("html").flowtype({
      //Max width at which script stops enlarging
      maximum: 980,
      //Min width at which script stops decreasing
      minimum: 320,
      //Max font size
      <strong>maxFont : 18,</strong>
      //Min font size
      <strong>minFont : 8,</strong>
<strong>      //Define own font-size</strong>
<strong>      fontRatio : 58</strong>
   });
});</pre>

<h3 class="title" id="sigil_toc_id_303"><a id="tip80"/>提示</h3>
<p>列表中最后一个值后面不需要包含逗号。</p>


<p>FlowType.js只是普通的石头人！</p>
<p>下面是我在CodePen中为此创建的一个<a id="id605" class="indexterm"/>演示：</p>
<p>T0http://codepen.io/ricardozea/pen/c2e6abf545dbaa82a16ae84718c79d34 T1</p>



<h1 class="title" id="sigil_toc_id_304"><a id="ch07lvl1sec53"/>总结</h1>



<p>因此，我们在这里，在RWD的排版水平。还有更多关于排版的内容吗？当然！这个惊人的主题本身就是一个完整的行业，没有它我们就不会读这本书。</p>
<p>我们现在可以说，我们理解了为什么在排版中使用相对单位是一个好方法：可伸缩性。此外，使用我们的小魔术公式，我们可以计算设计中每个文本元素的相对字体大小，但为什么要经历这些麻烦呢？在这方面，排版的模块化规模节省了时间，它为我们的项目注入了令人敬畏的排版和谐。谁知道呢，也许我们根本不需要使用图像！</p>
<p>品牌现在可以通过Web字体扩展到Web，但我们需要小心，并考虑使用它们对我们的网站/应用程序的影响。此外，就现代浏览器而言，我们只需要使用单一的文件类型（WOFF字体文件），这使得浏览器下载和用户享受时更容易管理。</p>
<p>js增强了标题和正文文本，同时保持了良好的易读性。</p>
<p>现在，RWD的一个重要部分是（信不信由你）像我们很多年前做的那样做。在下一章中，我们将保持简单，我们将在电子邮件中讨论RWD。</p>
<p>时光倒流！</p>

</body>
</html>