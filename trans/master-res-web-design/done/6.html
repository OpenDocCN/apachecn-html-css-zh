<html>
<head><title>Chapter 6. Working with Images and Videos in Responsive Web Design</title>
<link rel="stylesheet" href="epub.css" type="text/css"/>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
</head>
<body id="page">
<h1 class="title"><a id="ch06"/>第6章。在响应式网页设计中使用图像和视频</h1>



<p>我一直把图像称为<strong>RWD</strong>的“丑孩子”。为什么？直到最后一分钟，我总是尽量避免与他们打交道。我是否使用图像精灵？如果是这样，我是否将我的透明PNG导出为8位、24位或32位？一些传统IE不支持带有alpha通道的PNG，所以我必须导出一个GIF精灵。我可以改用SVG，但IE8及以下版本不支持SVG。我可以使用图标字体，但如果图标字体不加载会发生什么？那我得查一些分析资料。有一款新的<em>iDevice</em>带有新型高密度屏幕？现在我必须每次导出两个（或更多）图像。伟大的但我不能为小屏幕设备提供一个比常规尺寸图像大一倍以上的高质量图像！是的，它可能看起来不错，但下载会花费很长时间，他们甚至可能在第一次H1加载之前就离开网站。</p>
<p>你明白了。这仅仅是在RWD中使用媒体的皮毛。</p>
<p>这些想法中的一些至今仍然很活跃，但多年来我学到了一点常识，并且掌握了解决所有这些问题的技术，拥有一个简单的系统来处理图像（和视频）可以走很长的路。</p>
<p>和其他章节一样，我们将使事情简单但有意义。在图像方面没有银弹，特别是在RWD中，我们可以整天呆在这里，这当然是我们不想在这本书中看到的。我想让你尽快建立一个很棒的响应性网站。但我鼓励你们花些时间研究更多关于RWD的图片；在网页设计和开发者社区中，这确实是一个值得纪念的话题。</p>
<p>在本章中，我们将讨论以下主题：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">导出图像并在保持图像质量的同时大幅减小其最终文件大小的提示。</li>
<li class="listitem" style="list-style-type: disc">如何以及何时使用<code class="literal">srcset</code>和<code class="literal">sizes</code>属性以及<code class="literal">&lt;picture&gt;</code>元素。</li>
<li class="listitem" style="list-style-type: disc">使用<code class="literal">Retina.js</code>。</li>
<li class="listitem" style="list-style-type: disc">使视频具有响应性。</li>
<li class="listitem" style="list-style-type: disc">使用<code class="literal">FitVids.js</code>。</li>
<li class="listitem" style="list-style-type: disc">使用矢量格式：图标字体和SVG。</li>
<li class="listitem" style="list-style-type: disc">使用正确的CSS图像替换技术。</li>
</ul>

<p>下面是我们将在示例中使用的图像：</p>
<p><img src="img/B02102_06_01.jpg" alt="Working with Images and Videos in Responsive Web Design"/></p>
<p>这些令人敬畏的人物是来自中国少林寺的两位功夫大师。他们的名字是施德如和施德阳。</p>
<h3 class="title" id="sigil_toc_id_225"><a id="note10"/>注</h3>
<p><em>施德鲁和施德阳</em>由施德鲁（刘向阳饰）创作，他是少林寺正门照片真实性的唯一所有者和版权所有者。它通过<a id="id414" class="indexterm"/>维基百科获得CC BY-SA 3.0许可。可在<a class="ulink" href="http://en.wikipedia.org/wiki/Shaolin_Kung_Fu#/media/File:Shi_DeRu_and_Shi_DeYang.jpg">找到http://en.wikipedia.org/wiki/Shaolin_Kung_Fu#/media/File:Shi_DeRu_and_Shi_DeYang.jpg </a>。</p>


<p>由于我们也在<em>掌握HTML5和CSS3的</em>RWD，我认为这张照片正好符合我们的任务。</p>
<p>我将要描述的功夫大师的原始图像的属性将有助于建立一个基线，以便在为RWD优化图像时了解前后效果。</p>
<p>以下是<a id="id415" class="indexterm"/>原始图像的属性：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">这是一个24位JPG图像。</li>
<li class="listitem" style="list-style-type: disc">文件大小为556KB，但由于JPG算法的魔力（约12MB解压缩），它被压缩了。</li>
<li class="listitem" style="list-style-type: disc">尺寸<a id="id416" class="indexterm"/>为2496 x 1664像素，约为415万像素。从透视角度来看，这张图像的分辨率比我客厅里的55英寸LED电视还要高。</li>
</ul>

<p>在本书的结尾，我向你们保证两件事。首先，你将完全准备好构建响应性强的网站和应用程序。第二，当开始一个新项目的时候，你要从座位上站起来，摆出和这些大师们一样的姿势。</p>
<p>图像编辑超出了本书的范围，以下步骤将需要某种类型的图像处理。此时，您可以选择使用您喜爱的图像编辑器。我个人使用Adobe Fireworks（确实如此），但绝大多数使用Photoshop。</p>
<p>如果您不使用其中任何一款，您可以随时使用<strong>GNU图像处理软件</strong>（<strong>GIMP</strong>）或Paint.NET—这两款<a id="id417" class="indexterm"/>都是免费的。您可以从此处下载：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">GIMP:↓T0http://www.gimp.org/ T1。</li>
<li class="listitem" style="list-style-type: disc">Paint.NET:T0http://www.getpaint.net/ T1</li>
</ul>

<p>您还可以<a id="id418" class="indexterm"/>使用在线图像编辑工具。然而，我不得不承认我从未使用过任何一种，所以我不能推荐一种。在这一点上，我可以说的是尝试其中一些，并选择一个最适合你的需要。</p>
<p>让我们开始吧。</p>
<h1 class="title" id="sigil_toc_id_226"><a id="ch06lvl1sec39"/>减少RWD图像中文件大小的提示</h1>



<p>在<a id="id419" class="indexterm"/>设计中，创建图像副本的经验法则是从大到小，而不是相反。换句话说，图像越大，其后续副本就越好。</p>
<h2 class="title" id="sigil_toc_id_227"><a id="ch06lvl2sec64"/>调整尺寸</h2>



<p>只需<a id="id420" class="indexterm"/>将图像大小从2496 x 1664像素调整为1024 x 683像素，文件大小现在为331 KB。这使文件大小从556KB减少了近40%。这是一个巨大的进步，但我们还没有做到。</p>

<h2 class="title" id="sigil_toc_id_228"><a id="ch06lvl2sec65"/>背景模糊</h2>



<p>模糊<a id="id421" class="indexterm"/>背景本身其实相当有效，但<em>艺术方向</em>的观点也有另一个好处：它有助于吸引人们对图像重要部分的注意。</p>
<p>模糊背景后，该文件现在重达185KB。这意味着文件大小从556KB减少了67%。我们开始有所进展了。</p>
<p>以下是背景模糊的新图像：</p>
<p><img src="img/B02102_06_02.jpg" alt="Blurring the background"/></p>
<p>优化的巨大胜利！</p>

<h2 class="title" id="sigil_toc_id_229"><a id="ch06lvl2sec66"/>使不太重要的区域变暗或变亮</h2>



<p>变暗<a id="id422" class="indexterm"/>或变亮不太重要的<a id="id423" class="indexterm"/>区域是非常主观的，许多人可能不一定同意。在特殊情况下，这个过程就像背景模糊技术一样，可以帮助减小文件大小并将图像的重要部分显示出来。</p>
<p>我们试图通过使图像变暗或变亮来实现的基本目标是通过创建<em>纯色</em>区域来减少颜色的数量，或者至少尽可能地创建纯色区域。换句话说，我们正在降低对比度。谨慎使用这个技巧。</p>
<p>以我们的功夫大师为例，将背景中不太重要的部分变暗后，图像现在重178KB。诚然，这与前一个过程没有太大区别（只有7KB的差异），但我们可以从图像中提取出任何千字节的<a id="id424" class="indexterm"/>，而不影响质量始终是一件好事，178KB的文件大小大约减少了68%。</p>
<p>这是背景稍微变暗后图像的外观：</p>
<p><img src="img/B02102_06_03.jpg" alt="Darkening or lightening the less important areas"/></p>
<p>每千字节计数。</p>

<h2 class="title" id="sigil_toc_id_230"><a id="ch06lvl2sec67"/>优化图像</h2>



<p>这<a id="id426" class="indexterm"/>是过程中的最后一步。这个步骤实际上可以<a id="id427" class="indexterm"/>分为两个较小的步骤。</p>
<h3 class="title" id="sigil_toc_id_231"><a id="ch06lvl3sec41"/>使用Adobe Fireworks（可选）</h3>



<p>保存一个能够很好地平衡质量和文件大小的JPG。没有可以始终应用于每个图像的确定值。这一切都是在飞行中发生的。在执行此步骤时，您<a id="id428" class="indexterm"/>不希望以太低的质量保存图像，因为图像将经历另一个优化步骤。</p>
<p>实际上，我将使用Adobe在2013年5月停止开发的一个软件：Fireworks。</p>
<p>大家都知道焰火比Photoshop有更好的图像优化引擎，我自己做过测试，焰火压缩比Photoshop好。质量总是显示出最好的结果。Fireworks与当今的网页设计流程和工作流程的关联性不亚于任何其他图像编辑软件。所以不要害怕使用它。</p>
<p>在以80%的质量输出烟花图像后，功夫大师的图像现在只有71 KB。这使文件大小从原来的556KB减少了87%。</p>

<h3 class="title" id="sigil_toc_id_232"><a id="ch06lvl3sec42"/>压缩图像</h3>



<p>通过另一个图像优化<a id="id430" class="indexterm"/>工具运行<a id="id429" class="indexterm"/>图像，可以是一个独立的应用程序，如Mac的ImageOptim或<a id="id431" class="indexterm"/>Windows的激进图像优化工具（RIOT），也可以是一个在线服务，如<a class="ulink" href="https://tinypng.com/">https://tinypng.com/ </a>或<a class="ulink" href="http://www.jpegmini.com/">http://www.jpegmini.com/ </a>。</p>
<p>我们将使用<a class="ulink" href="https://tinypng.com/">https://tinypng.com/ </a>在线图像压缩服务。通过<a class="ulink" href="https://tinypng.com/">运行烟花导出的图像后https://tinypng.com/ </a>，文件大小现在约为52KB，比原来的556KB减少了91%。这是图像优化的巨大胜利。</p>
<h3 class="title" id="sigil_toc_id_233"><a id="tip54"/>提示</h3>
<p>如果你没有先在烟花中播放图像，别担心。即使你的图像可能会大一点，它仍然会被难以置信地优化，这就是这里的目标。</p>


<p>以下是556 KB图像和最终52 KB图像之间的前后（左）比较：</p>
<p><img src="img/B02102_06_04.jpg" alt="Compressing the image"/></p>




<h1 class="title" id="sigil_toc_id_234"><a id="ch06lvl1sec40"/>第三方图像缩放服务</h1>



<p>我们必须<a id="id432" class="indexterm"/>承认，如果在许多图像需要调整大小和优化的场景中，手动优化图像的过程可能非常繁琐和耗时，那么手动操作可能不是最好的主意。</p>
<p>有一些第三方和服务器端服务可以为我们自动化这个过程。我们将把如何实现这些服务的教程留给另一本书。不过，我们将列出一些最受欢迎的服务，以便您在想深入了解的情况下提供参考。</p>
<p>以下是一些<a id="id433" class="indexterm"/>第三方图像大小调整服务的示例：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong> Sencha.io Src </strong> from <a id="id434" class="indexterm"/> Sencha.com ( <a class="ulink" href="http://www.sencha.com/learn/how-to-use-src-sencha-io/"> http://www.sencha.com/learn/how-to-use-src-sencha-io/ </a> )</li>
<li class="listitem" style="list-style-type: disc"><strong>resrc</strong>by<a id="id435" class="indexterm"/>dom<a id="id436" class="indexterm"/>费和ed<a id="id437" class="indexterm"/>瑟古德（<a class="ulink" href="http://www.resrc.it/">http://www.resrc.it/ </a></li>
<li class="listitem" style="list-style-type: disc">T0 WURFL T1 T2裁剪图像T3http://web.wurfl.io/#wit （T4）</li>
</ul>

<p>以下是服务器端（<code class="literal">.htaccess</code>和/或<code class="literal">.php</code>图像大小调整服务的几个示例：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Matt<a id="id440" class="indexterm"/>Wilcox（<a class="ulink" href="http://adaptive-images.com/">制作的自适应<a id="id439" class="indexterm"/>图像http://adaptive-images.com/ </a></li>
<li class="listitem" style="list-style-type: disc">RESS.io（'T0'）http://ress.io/ T1（T1）</li>
</ul>


<h1 class="title" id="sigil_toc_id_235"><a id="ch06lvl1sec41"/>该&lt;图片&gt;元素与srcset和size属性</h1>



<p>首先让我说，RWD中的图像问题没有100%最优的<a id="id442" class="indexterm"/>解决方案。这是因为<a id="id443" class="indexterm"/>目前缺乏对推荐属性的支持，或者是因为存在双重资产下载。当然，Dave Newton在<a class="ulink" href="http://ww1.smashingmagzine.com/">中的文章http://ww1.smashingmagzine.com/ </a>、<em>如何避免在响应图像中重复下载</em>尝试解决此问题（<a class="ulink" href="http://www.smashingmagazine.com/2013/05/10/how-to-avoid-duplicate-downloads-in-responsive-img/">http://www.smashingmagazine.com/2013/05/10/how-to-avoid-duplicate-downloads-in-responsive-img/ </a>。</p>
<p>然而，这个<a id="id444" class="indexterm"/>解决方案非常冗长。如果您必须处理许多图像，此解决方案可能不是最佳选择，并且允许双重下载开始变得更有意义。每个项目都是不同的，所以尽可能做出最明智的决策是非常重要的。</p>
<p>一旦浏览器供应商决定完全支持这里提到的任何解决方案，就不必担心任何类型的双重下载或多重填充。</p>
<p><code class="literal">&lt;picture&gt;</code>元素以及<code class="literal">srcset</code>和<code class="literal">sizes</code>属性由<strong>Responsive Images社区组</strong>（<strong>RICG</strong>）维护，现在是HTML规范的一部分。换句话说，我们可以不使用任何类型的polyfill来使用它们，并且相信现代浏览器将支持它们。嗯，至少在某种程度上。</p>
<p>我们需要使用polyfill的唯一原因是为了支持那些尚未实现对它们的支持的浏览器（传统浏览器和现代浏览器）。</p>
<h3 class="title" id="sigil_toc_id_236"><a id="tip55"/>提示</h3>
<p>对于不支持它们的浏览器，<code class="literal">&lt;picture&gt;</code>元素和<code class="literal">srcset</code>属性都具有回退功能。您可以选择使用polyfill，但不需要<a id="id446" class="indexterm"/>这样做。如果您认为使用polyfill可以增强用户体验，那么请尽一切努力。请阅读Picturefill polyfill的创建者Scott Jehl（<a class="ulink" href="http://www.filamentgroup.com/lab/to-picturefill.html">的文章）http://www.filamentgroup.com/lab/to-picturefill.html </a>）。</p>


<p>这里有许多多边形填充，下面是我们今天可以使用的多边形填充的简短列表：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">图片由<a id="id447" class="indexterm"/>Scott Jehl提供（由RICG推荐：<a class="ulink" href="http://scottjehl.github.io/picturefill/">http://scottjehl.github.io/picturefill/ </a></li>
<li class="listitem" style="list-style-type: disc">图片由T0 Andrea Verlicchi（“T1”）填写http://verlok.github.io/picturePolyfill/ (2)</li>
<li class="listitem" style="list-style-type: disc">由'T0'亚历山大·法卡斯（'T1'拍摄）https://github.com/aFarkas/respimage (2)</li>
</ul>

<p>web设计和web开发社区的一些人强烈认为，新的HTML元素（<code class="literal">&lt;picture&gt;</code>）并不能解决我们在RWD中遇到的图像问题。他们认为解决方案应该来自一个已经存在的标记，<code class="literal">&lt;img&gt;</code>标记。</p>
<h3 class="title" id="sigil_toc_id_237"><a id="tip56"/>提示</h3>
<p><code class="literal">sizes</code>属性也可以与<code class="literal">&lt;picture&gt;</code>元素一起使用，但我们将重点介绍如何将<code class="literal">sizes</code>属性与<code class="literal">&lt;img&gt;</code>标记一起使用。</p>


<p>很好<a id="id450" class="indexterm"/>对我们来说，解决方案有两种口味。不管你用哪种方法以负责任的方式为你的图像服务，重要的是你应该使用这些方法中的一种。如果你已经是了，那太棒了。如果不是，不要担心。以下解释将有助于澄清您对此事的任何疑问。</p>
<h2 class="title" id="sigil_toc_id_238"><a id="ch06lvl2sec68"/>何时使用&lt;图片&gt;及何时使用srcset</h2>



<p>何时使用<a id="id453" class="indexterm"/>和何时使用<code class="literal">srcset</code>？这是一个非常合法的问题，当我第一次听到这些术语时，我自己都无法理解。所以我决定去问布拉德·弗罗斯特，他在代顿主持的一个研讨会。</p>
<p>推荐的方法归结为这个概念：艺术指导。在响应图像中，艺术方向基本上意味着以某种方式裁剪不同的图像，以便忽略图像中不太重要的部分，以便聚焦重要的部分。</p>
<p>这与仅调整同一图像的大小不同。诚然，您可以使用任何您想要的方法，但为了保持简单，当您想要为艺术导向的图像提供服务时，您可以使用<code class="literal">&lt;picture&gt;</code>元素，而当您只想为相同图像提供调整大小的版本时，可以使用<code class="literal">srcset</code>属性。</p>
<p>在我们深入讨论标记之前，让我们看一个视觉示例，使用功夫大师的照片对比艺术指导图像和调整大小的图像：</p>
<p><img src="img/B02102_06_05.jpg" alt="When to use &lt;picture&gt; and when to use srcset"/></p>
<p>让我们看看这里发生了什么。原始图像在功夫大师周围有很大的空间<a id="id456" class="indexterm"/>：我们可以看到后面的树木和建筑物。调整大小的版本保持原始图像的所有方面和比例为1:1。</p>
<p>然而，艺术导向的图像有很多不同之处。第一张由艺术指导的图像被裁剪成两位大师的特写镜头；第二幅由艺术指导的图像被裁剪得更加精细，以突出对施德如（左边的大师）的关注。我们本可以裁剪图像以聚焦施德阳（右边的大师），但这正是我想要给出图像的“艺术方向”。这是一个主观的决定，但基于坚实的意图。</p>
<p>现在，让我们看看<em>Picturefill polyfill/脚本</em>的实际操作。</p>

<h2 class="title" id="sigil_toc_id_239"><a id="ch06lvl2sec69"/>实现Picturefill polyfill</h2>



<p><a id="id457" class="indexterm"/>我们需要做的第一件事就是下载JavaScript文件，<a id="id458" class="indexterm"/>可以从<a class="ulink" href="https://github.com/scottjehl/picturefill/blob/2.3.0/dist/picturefill.min.js">下载https://github.com/scottjehl/picturefill/blob/2.3.0/dist/picturefill.min.js </a></p>
<p>那么，我们需要做的就是将其包含在我们文档的<code class="literal">&lt;head&gt;</code>部分：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;!--[if IE 8]&gt; &lt;html class="no-js ie8" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if IE 9]&gt; &lt;html class="no-js ie9" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if gt IE 9]&gt;&lt;!--&gt;&lt;html class="no-js" lang="en"&gt;&lt;!--&lt;![endif]--&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    <strong>&lt;script src="js/picturefill.min.js"&gt;&lt;/script&gt;</strong>
    &lt;title&gt;Picturefill polyfill&lt;/title&gt;
&lt;/head&gt;</pre>


<h2 class="title" id="sigil_toc_id_240"><a id="ch06lvl2sec70"/>使用&lt;图片&gt;元素</h2>



<p>当使用<code class="literal">&lt;picture&gt;</code>元素时，您（作者）告诉浏览器在<a id="id459" class="indexterm"/>哪个断点使用哪个图像。这样做的好处是，我们可以通过使用媒体查询精确地定义何时显示某个图像。媒体查询的工作原理与CSS中使用的媒体查询完全相同，甚至看起来也完全相同。</p>
<p>这是一个基本的<code class="literal">&lt;picture&gt;</code>代码片段的样子：</p>
<pre class="programlisting">&lt;picture&gt;
    &lt;source srcset="img/grandmasters-small.jpg" media="(max-width: 40em)"&gt;
    &lt;source srcset="img/grandmasters-medium.jpg" media="(max-width: 64em)"&gt;
    &lt;source srcset="img/grandmasters-default.jpg"&gt;
    &lt;img src="img/grandmasters-default.jpg" alt="Fallback image"&gt;
&lt;/picture&gt;</pre>

<p>现在，即使使用polyfill，IE9也存在<code class="literal">&lt;picture&gt;</code>元素的问题。听起来很奇怪，我们需要在条件注释中插入一个<code class="literal">&lt;video&gt;</code>标记，IE9才能正常工作。</p>
<p>这是为IE9修改标记后的外观：</p>
<pre class="programlisting">&lt;picture&gt;
<strong>    &lt;!--[if IE 9]&gt;&lt;video style="display: none;"&gt;&lt;![endif]--&gt;</strong>
    &lt;source srcset="img/grandmasters-small-ad.jpg" media="(max-width: 40em)"&gt;
    &lt;source srcset="img/grandmasters-medium-ad.jpg" media="(max-width: 64em)"&gt;
    &lt;source srcset="img/grandmasters-default.jpg"&gt;
    <strong>&lt;!--[if IE 9]&gt;&lt;/video&gt;&lt;![endif]--&gt;</strong>
    <strong>&lt;img src="img/grandmasters-default.jpg" alt="Fallback image"&gt;</strong>
&lt;/picture&gt;</pre>

<p>如您所见，我还突出显示了<code class="literal">&lt;img src="grandmasters-default.jpg" alt="Fallback image"&gt;</code>标记。这是不支持<code class="literal">&lt;picture&gt;</code>元素的浏览器的回退映像。</p>
<p>需要记住的一点是，不久前，这个回退图像在一些现代浏览器中导致了双重下载。我上一次的测试表明，Chrome和Firefox并不支持<code class="literal">&lt;picture&gt;</code>元素。因此，请确保您运行了所有必要的<a id="id460" class="indexterm"/>测试，以了解您所处的位置，然后如果您需要支持这些传统浏览器，请考虑解决方案。</p>
<p>这是我在CodePen中为此创建的一个<a id="id461" class="indexterm"/>演示：<a class="ulink" href="http://codepen.io/ricardozea/pen/cf6c0965785d552bad5e200acb761ffe">http://codepen.io/ricardozea/pen/cf6c0965785d552bad5e200acb761ffe </a></p>

<h2 class="title" id="sigil_toc_id_241"><a id="ch06lvl2sec71"/>使用srcset和size属性</h2>



<p><code class="literal">srcset</code>和<code class="literal">sizes</code>属性实际上来自<code class="literal">&lt;picture&gt;</code>规范，但在<code class="literal">&lt;img&gt;</code>元素中实现<a id="id462" class="indexterm"/>。当使用<code class="literal">srcset</code>和<code class="literal">sizes</code>属性时，浏览器会根据<a id="id463" class="indexterm"/>的具体情况决定使用哪个图像。如果您愿意，也可以使用媒体查询，尽管这不是必需的。单词<code class="literal">vw</code>表示<em>视口宽度</em>，用于让浏览器知道它应该以相对于视口宽度的一定百分比显示图像。如果您看到类似于<code class="literal">80vw</code>的内容，则表示图像应为当前视口宽度的80%。</p>
<p><code class="literal">w</code>描述符表示<em>图像</em>的宽度。如果您看到类似于<code class="literal">255w</code>的内容，这意味着浏览器将了解特定图像的宽度为255px。</p>
<p>让我们看一个带有Ty1 T1和Ty2 T2属性的Apple T0标签。</p>
<pre class="programlisting">&lt;img src="img/grandmasters-default.jpg"
     srcset="img/grandmasters-small-rsz.jpg 255w,
             img/grandmasters-medium-rsz.jpg 511w"
     sizes="(min-width: 30em) 80vw, 100vw"
     alt="Mastering RWD with HTML5 and CSS3"&gt;</pre>

<p>字母<code class="literal">rsz</code>是<em>和</em>的缩写。这是因为对于刚要在RWD中调整大小的图像，<code class="literal">srcset</code>属性使事情变得更简单。</p>
<p>以下标记被截断，以便轻松地集中于特定的解释。</p>
<p>我们首先看到的是已知的<code class="literal">src</code>属性，该属性充当后备映像：</p>
<pre class="programlisting">&lt;img <strong>src="img/grandmasters-default.jpg"…</strong>
</pre>

<p>请记住，图像<code class="literal">grandmasters-default.jpg</code><em>不会被理解<code class="literal">srcset</code>的浏览器</em>使用。换句话说，支持<code class="literal">srcset</code>的浏览器中的<em>默认</em>图像将成为列表中的第一个图像。在我们的例子中，它是<code class="literal">grandmasters-small-rsz.jpg</code>。然后，我们看到了<code class="literal">srcset</code>属性。</p>
<p>这就是魔法开始发生的地方：</p>
<pre class="programlisting"><strong>srcset="img/grandmasters-small-rsz.jpg 255w,img/grandmasters-medium-rsz.jpg 511w"</strong>
</pre>

<p>在本例中，我们的计划是在支持<code class="literal">srcset</code>的浏览器中显示两个不同的图像文件。这是通过列出用逗号分隔的图像来实现的。另外，每个图像后定义的<a id="id464" class="indexterm"/>值是图像的宽度：</p>
<pre class="programlisting">img/grandmasters-small-rsz.jpg <strong>255w</strong>
</pre>

<h3 class="title" id="sigil_toc_id_242"><a id="tip57"/>提示</h3>
<p>我们也可以使用高度：</p>
<pre class="programlisting">grandmasters-small-rsz.jpg 170h</pre>

<p>然而，最常见的用例是处理宽度并允许按比例调整高度，这样作者就可以更好地控制图像。</p>


<p>将<a id="id465" class="indexterm"/>图像的大小提供给浏览器将使其能够根据<code class="literal">sizes</code>片段中的媒体查询，更明智地决定使用哪个图像：</p>
<pre class="programlisting">sizes="<strong>(min-width: 30em)</strong> 80vw, 100vw"</pre>

<p>记住，<code class="literal">30em</code>与480px相同。通过媒体查询<code class="literal">min-width: 30em</code>，浏览器会经历以下过程：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">如果我的视口是30em（480px）或更小，我应该显示255px宽的图像。没有必要在只有480px的视口中显示511px的图像。那是对带宽的浪费！</li>
<li class="listitem" style="list-style-type: disc">但是，如果我的视口<em>大于</em>30em（480px），那么我应该显示511px宽的图像。</li>
</ul>

<p><code class="literal">sizes</code>属性的最后一部分是视口宽度：<code class="literal">80vw, 100vw</code>。</p>
<pre class="programlisting">sizes="(min-width: 30em) <strong>80vw, 100vw</strong>"</pre>

<p>这意味着，如果视口为30em（480px）或更小，浏览器将以80%的宽度显示图像。如果超过30em（480px），它将以100%的宽度显示图像。</p>
<p>最后，我们有<code class="literal">alt</code>属性：</p>
<pre class="programlisting">alt="Mastering RWD with HTML5 and CSS3"&gt;</pre>

<p>对于使用辅助技术的用户来说，添加一个<code class="literal">alt</code>属性始终是一个很好的可访问性实践。此外，如果没有加载图像，浏览器可以显示此文本。</p>
<h3 class="title" id="sigil_toc_id_243"><a id="tip59"/>提示</h3>
<p>属性的顺序并不重要。换句话说，您可以先有<code class="literal">srcset</code>，然后是<code class="literal">alt</code>，然后是<code class="literal">sizes</code>，然后是<code class="literal">src</code>属性（反之亦然）。</p>


<h3 class="title" id="sigil_toc_id_244"><a id="ch06lvl3sec43"/>使用srcset瞄准高密度屏幕</h3>



<p>高密度<a id="id466" class="indexterm"/>屏幕将永远是RWD世界中我们永远无法摆脱的东西。所以如果你不能打败他们，就加入他们。</p>
<p>下面是一个介绍普通和高密度屏幕的片段：</p>
<pre class="programlisting">&lt;img src="img/grandmasters-default.jpg"
     srcset="img/grandmasters-small-rsz.jpg 1x,img/grandmasters-medium-rsz.jpg 2x"&gt;</pre>

<p>如您所见，这是一个非常简短的标记。这真的是不言自明的：如果没有<code class="literal">srcset</code>支持，请使用回退映像。如果有支持，则如果设备具有正常密度显示，则使用<code class="literal">1x</code>图像。如果设备的高密度显示器的密度高达密度的两倍，则必须使用<code class="literal">2x</code>图像。如果我们支持甚至高于2倍密度的设备，则应添加3倍后缀。</p>
<p><code class="literal">sizes</code>属性不是必需的。如果您的设计或条件值得使用<code class="literal">sizes</code>属性，您可以自由使用它。</p>
<p>这是我在CodePen中为此创建的一个演示<a id="id467" class="indexterm"/>：<a class="ulink" href="http://codepen.io/ricardozea/pen/a13993f05a4cdc5f714a311a94f48a69">http://codepen.io/ricardozea/pen/a13993f05a4cdc5f714a311a94f48a69 </a></p>


<h2 class="title" id="sigil_toc_id_245"><a id="ch06lvl2sec72"/>&lt;图片&gt;对srcset</h2>



<p>一些<a id="id468" class="indexterm"/>网站设计师和开发人员表示<a id="id469" class="indexterm"/>在HTML中使用媒体查询，就像我们在<code class="literal">&lt;picture&gt;</code>和<code class="literal">srcset</code>中看到的那样，违反了关注点分离的原则：样式和标记应该始终作为分离的独立资产。</p>
<p>正如我前面提到的，其他人认为新的HTML元素是不必要的，任何解决方案都应该基于增强和扩展已有的元素，比如<code class="literal">&lt;img&gt;</code>标记。</p>
<p>我所能说的是，最后，这些都无关紧要。重要的是，作为web设计师和开发人员，我们应该利用我们所拥有的一切，让用户满意并创造难忘的体验，同时坚持最佳实践以实现持久的实现。</p>


<h1 class="title" id="sigil_toc_id_246"><a id="ch06lvl1sec42"/>使用Retina.js动态地将1x图像替换为2x图像</h1>



<p><code class="literal">Retina.js</code>脚本是<a id="id470" class="indexterm"/>脚本中的一种，它使事情变得如此简单，以至于有时你会想为什么响应图像如此困难。</p>
<p>如果您还没有准备好处理<code class="literal">&lt;picture&gt;</code>和/或<code class="literal">srcset</code>和<code class="literal">sizes</code>属性，我不会责怪您。这很可怕，但我建议您继续尝试理解这些工具，因为这是最先进的响应图像。</p>
<p><code class="literal">Retina.js</code>脚本是由<a id="id471" class="indexterm"/>伊穆卢斯的人（<a class="ulink" href="http://imulus.com/">开发的http://imulus.com/ </a>）。<code class="literal">Retina.js</code>脚本不是<a id="id472" class="indexterm"/>JavaScript唯一的解决方案；它们还有一个Sass mixin，可以在不依赖JavaScript的情况下生成相同的结果。</p>
<p>让我们先看看JavaScript解决方案。</p>
<h2 class="title" id="sigil_toc_id_247"><a id="ch06lvl2sec73"/>Retina.js–一个JavaScript解决方案</h2>



<p>使用<a id="id473" class="indexterm"/>脚本再简单不过了。我们需要<a id="id474" class="indexterm"/>从<a class="ulink" href="https://github.com/imulus/retinajs/blob/master/dist/retina.min.js">下载脚本https://github.com/imulus/retinajs/blob/master/dist/retina.min.js </a></p>
<p>然后，我们将脚本放在HTML的底部，就在结束<code class="literal">&lt;body&gt;</code>标记之前：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;!--[if IE 8]&gt; &lt;html class="no-js ie8" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if IE 9]&gt; &lt;html class="no-js ie9" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if gt IE 9]&gt;&lt;!--&gt;&lt;html class="no-js" lang="en"&gt;&lt;!--&lt;![endif]--&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;Retina.js - JavaScript Solution&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   ...
   <strong>&lt;script src="js/retina.min.js"&gt;&lt;/script&gt;</strong>
&lt;/body&gt;
&lt;/html&gt;</pre>

<h3 class="title" id="sigil_toc_id_248"><a id="tip60"/>提示</h3>
<p><code class="literal">Retina.js</code>脚本不依赖于框架。换句话说，它不需要jQuery、Mootools、Dojo或任何框架来工作。</p>


<p>然后，我们将图像添加到标记中：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;!--[if IE 8]&gt; &lt;html class="no-js ie8" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if IE 9]&gt; &lt;html class="no-js ie9" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if gt IE 9]&gt;&lt;!--&gt;&lt;html class="no-js" lang="en"&gt;&lt;!--&lt;![endif]--&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;Retina.js - JavaScript Solution&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   <strong>&lt;img src="img/grandmasters-default.jpg" alt=""&gt;</strong>
   &lt;script src="js/retina.min.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<p>就这样！我们<a id="id475" class="indexterm"/>不必对标记做任何修改，除非我们想排除替换图像。接下来我将解释如何进行此操作。</p>
<p><code class="literal">Retina.js</code>的JavaScript解决方案的基本功能是在页面中查找图像，如果服务器上存在图像，则将其替换为高分辨率版本。</p>
<p>您需要在高分辨率图像的名称末尾使用<code class="literal">@2x</code>修饰符命名。</p>
<p>换句话说，如果您有以下图像：</p>
<pre class="programlisting">&lt;img src="img/grandmasters-default.jpg" alt=""&gt;</pre>

<p>Retina.js将其替换为以下内容：</p>
<pre class="programlisting">&lt;img src="img/grandmasters-default<strong>@2x</strong>.jpg" alt=""&gt;</pre>

<p>只要服务器上存在<code class="literal">@2x</code>映像，<code class="literal">Retina.js</code>就会替换它。如果图像不存在，则它不会替换它。</p>
<h3 class="title" id="sigil_toc_id_249"><a id="ch06lvl3sec44"/>不包括图像</h3>



<p>如果您<a id="id476" class="indexterm"/>已经排除或想要排除图像被<code class="literal">Retina.js</code>替换，您可以将<code class="literal">data-no-retina</code>属性添加到您的图像中：</p>
<pre class="programlisting">&lt;img src="img/grandmasters-default.jpg" alt="" <strong>data-no-retina</strong>&gt;</pre>



<h2 class="title" id="sigil_toc_id_250"><a id="ch06lvl2sec74"/>Retina.js–一种Sass混合溶液</h2>



<p>好吧，这是<a id="id477" class="indexterm"/>奇怪的——一个JavaScript解决方案，不知何故碰巧也有一个CSS解决方案？含糖的请注意，此Sass mixin用于应用背景高分辨率图像。</p>
<p>Sass mixin看起来像这样：</p>
<pre class="programlisting">@mixin at2x($path, $ext: "jpg", $w: auto, $h: auto) {
    $at1x_path: "#{$path}.#{$ext}";
    $at2x_path: "#{$path}@2x.#{$ext}";

  background-image: url("#{$at1x_path}");

    @media all and (-webkit-min-device-pixel-ratio : 1.5),
        all and (-o-min-device-pixel-ratio: 3/2),
        all and (min--moz-device-pixel-ratio: 1.5),
        all and (min-device-pixel-ratio: 1.5) {
          background-image: url("#{$at2x_path}");
          background-size: $w $h;
  }
}</pre>

<p>用法非常简单：</p>
<pre class="programlisting">.hero {
    width: 100%;
    height: 510px;
    @include at2x('img/grandmasters-default', jpg, 100%, auto);
}</pre>

<p>我们需要<a id="id478" class="indexterm"/>将<strong>文件扩展名</strong>、<strong>宽度</strong>和<strong>高度</strong>声明为逗号分隔的值。前面的Sass代码段将编译为：</p>
<pre class="programlisting">.hero {
    width: 100%;
    height: 510px;
    background-image: url("img/grandmasters-default.jpg");
}
@media all and (-webkit-min-device-pixel-ratio: 1.5), all and (-o-min-device-pixel-ratio: 3 / 2), all and (min--moz-device-pixel-ratio: 1.5), all and (min-device-pixel-ratio: 1.5) {
    .hero {
        background-image: url("img/grandmasters-default@2x.jpg");
        background-size: 100% auto;
    }
}</pre>

<p>这是我在CodePen中为此创建的一个<a id="id479" class="indexterm"/>演示：<a class="ulink" href="http://codepen.io/ricardozea/pen/c3af015b325da6ee56cf59e660f3cc03">http://codepen.io/ricardozea/pen/c3af015b325da6ee56cf59e660f3cc03 </a></p>
<h3 class="title" id="sigil_toc_id_251"><a id="tip61"/>提示</h3>
<p>使用<code class="literal">background-size: 100% auto;</code>时，背景图像将延伸至其父容器的<a id="id480" class="indexterm"/>最大宽度。但是，如果容器较宽，图像将重复。</p>




<h1 class="title" id="sigil_toc_id_252"><a id="ch06lvl1sec43"/>制作响应性强的视频</h1>



<p>我们将要谈论的视频<a id="id481" class="indexterm"/>是来自我们的老朋友<code class="literal">&lt;iframe&gt;</code>元素的视频，比如来自YouTube、Vimeo、Dailymotion等的视频。有几种方法可以使视频更具响应性，有些方法比其他方法更具参与性。让我们把它分解一下。</p>
<h2 class="title" id="sigil_toc_id_253"><a id="ch06lvl2sec75"/>带有HTML和CSS的响应视频</h2>



<p>YouTube是一项令人惊叹的视频服务，它让每个视频作者以及网页设计师和开发者的生活变得更加轻松。YouTube负责视频的托管、流媒体以及不支持Flash（iOS）的浏览器或不支持<code class="literal">&lt;video&gt;</code>标签（传统浏览器）的浏览器的技术条件，这一事实真是太棒了。</p>
<p>我们需要做的第一件事是创建一个容器来容纳视频。这个容器是我们将要操纵的容器，在保持其纵横比的同时为视频提供我们想要的宽度：</p>
<pre class="programlisting"><strong>&lt;div class="video-container"&gt;&lt;/div&gt;</strong>
</pre>

<p>然后，我们为要嵌入的视频创建一个容器：</p>
<pre class="programlisting">&lt;div class="video-container"&gt;
   <strong>&lt;div class="embed-container"&gt;&lt;/div&gt;</strong>
&lt;/div&gt;</pre>

<p>然后我们将视频嵌入到<code class="literal">&lt;iframe&gt;</code>元素中：</p>
<pre class="programlisting">&lt;div class="video-container"&gt;
    &lt;div class="embed-container"&gt;
        <strong>&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/vpRsLPI400U" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</strong>
    &lt;/div&gt;
&lt;/div&gt;</pre>

<p>好了，我们的加价到此为止。现在，让我们从内到外处理CSS。</p>
<p>让我们给<code class="literal">&lt;iframe&gt;</code>元素一些属性：</p>
<pre class="programlisting">.embed-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}</pre>

<p>然后，让我们<a id="id483" class="indexterm"/>为<code class="literal">.embed-container</code>包装器提供一些上下文：</p>
<pre class="programlisting">.embed-container {
    position: relative;
    padding-bottom: 56.25%;
    padding-top: 35px; /* This padding is only needed for YouTube videos */
    height: 0;
    overflow: hidden;
}</pre>

<p>现在，<code class="literal">&lt;iframe&gt;</code>元素将正确定位，并占用其父容器的所有空间。父容器将确保视频可见，并且任何突出的内容都将被隐藏。</p>
<h3 class="title" id="sigil_toc_id_254"><a id="tip62"/>提示</h3>
<p>对于高宽比为16:9的视频，请使用<code class="literal">padding-bottom: 56.25%;</code>。</p>
<p>对于宽高比为4:3的视频，请使用<code class="literal">padding-bottom: 75%;</code>。</p>


<p>我们现在需要做的就是定义整个东西的宽度。我们通过向外部容器<strong>.视频容器</strong>包装器添加一个宽度来实现此目的：</p>
<pre class="programlisting">.video-container {
    width: 80%; /* This can be any width you want */
}</pre>


<h2 class="title" id="sigil_toc_id_255"><a id="ch06lvl2sec76"/>jQuery响应视频</h2>



<p>如果你是jQuery的粉丝，这个<a id="id484" class="indexterm"/>插件就是为你准备的。当你不得不更新网站上已经发布的视频时，或者如果有太多的视频无法手动更新时，它也会派上用场。</p>
<p>该插件名为FitVids.js。它是由Chris Coyer和Paravel的同事开发的。使用FitVids.js非常简单。首先，我们需要从以下URL下载FitVids JavaScript文件<a id="id485" class="indexterm"/>：<a class="ulink" href="https://github.com/davatron5000/FitVids.js/blob/master/jquery.fitvids.js">https://github.com/davatron5000/FitVids.js/blob/master/jquery.fitvids.js </a></p>
<p>然后，我们在文档的<code class="literal">&lt;head&gt;</code>中调用jQuery和FitVids.js文件。最后，我们在标记的底部添加一个脚本来调用<code class="literal">fitVids</code>函数。这差不多就是全部了。</p>
<h3 class="title" id="sigil_toc_id_256"><a id="tip63"/>提示</h3>
<p><code class="literal">FitVids.js</code>的实际文件名为<code class="literal">jquery.fitvids.js</code>。这是我们将在示例中看到的文件名。</p>


<p>以下是一个包含两个视频的<a id="id486" class="indexterm"/>HTML片段<code class="literal">&lt;iframe&gt;</code>，一个来自YouTube，另一个来自Vimeo：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;!--[if IE 8]&gt; &lt;html class="no-js ie8" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if IE 9]&gt; &lt;html class="no-js ie9" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if gt IE 9]&gt;&lt;!--&gt;&lt;html class="no-js" lang="en"&gt;&lt;!--&lt;![endif]--&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
<strong>&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;</strong>
<strong>&lt;script src="js/jquery.fitvids.js"&gt;&lt;/script&gt;</strong>
    &lt;title&gt;Responsive Videos with: jQuery Using FitVids.js&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Responsive Videos with: jQuery Using FitVids.js&lt;/h1&gt;
    &lt;main class="main-container" role="main"&gt;
        &lt;h2&gt;YouTube&lt;/h2&gt;
        <strong>&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/vpRsLPI400U" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</strong>
        &lt;h2&gt;Vimeo&lt;/h2&gt;
        <strong>&lt;iframe width="560" height="315" src="https://player.vimeo.com/video/101875373" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen&gt;&lt;/iframe&gt;</strong>
    &lt;/main&gt;
    <strong>&lt;script&gt;</strong>
<strong>        $(function(){</strong>
<strong>        //Look for all the videos inside this element and make them responsive</strong>
<strong>         $(".main-container").fitVids();</strong>
<strong>      });</strong>
<strong>   &lt;/script&gt;</strong>
&lt;/body&gt;
&lt;/html&gt;</pre>

<p>如果您对<code class="literal">FitVids.js</code>如何修改DOM以使视频响应感兴趣，下面是标记：</p>
<pre class="programlisting">&lt;div class="fluid-width-video-wrapper" style="padding-top: 56.25%;"&gt;
    &lt;iframe src="https://www.youtube.com/embed/vpRsLPI400U" frameborder="0" allowfullscreen="" id="fitvid0"&gt;&lt;/iframe&gt;
&lt;/div&gt;</pre>

<h3 class="title" id="sigil_toc_id_257"><a id="tip64"/>提示</h3>
<p><strong>文档对象模型</strong><strong>DOM</strong>：当您<a id="id487" class="indexterm"/>阅读或听到有人说<em>修改DOM</em>时，基本上是指<em>修改生成的HTML</em>。</p>


<p>这是我在代码笔<a class="ulink" href="http://codepen.io/ricardozea/pen/9e994c213c0eeb64ccd627e132778a42">中为此创建的<a id="id488" class="indexterm"/>演示http://codepen.io/ricardozea/pen/9e994c213c0eeb64ccd627e132778a42 </a>。</p>

<h2 class="title" id="sigil_toc_id_258"><a id="ch06lvl2sec77"/>带有纯JavaScript的响应视频</h2>



<p>如果您<a id="id490" class="indexterm"/>没有使用jQuery或不需要任何框架依赖项，但仍然需要一个简单的JavaScript解决方案，那么最好的选择是使用由Todd开发的脚本座右铭：<code class="literal">Fluidvids.js</code>。</p>
<p>使用它<a id="id491" class="indexterm"/>也很简单。首先，我们需要下载Fluidvids JavaScript文件：<a class="ulink" href="https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.min.js">https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.min.js </a></p>
<p>然后，我们需要在文档的<code class="literal">&lt;head&gt;</code>元素中调用<code class="literal">fluidvis.js</code>文件。一旦我们准备好了，我们就在标记的底部添加一个小脚本片段。就这样。脚本将通读标记，修改DOM，并使它发现的任何视频<em>响应</em>。</p>
<h3 class="title" id="sigil_toc_id_259"><a id="tip65"/>提示</h3>
<p>确保始终为<code class="literal">&lt;iframe&gt;</code>元素提供一个<code class="literal">width</code>和<code class="literal">height</code>值。否则，您将在页面上看到空白。</p>


<p>以下是您需要的HTML代码片段，以使其正常工作：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;!--[if IE 8]&gt; &lt;html class="no-js ie8" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if IE 9]&gt; &lt;html class="no-js ie9" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if gt IE 9]&gt;&lt;!--&gt;&lt;html class="no-js" lang="en"&gt;&lt;!--&lt;![endif]--&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;<strong>script src="js/fluidvids.min.js"&gt;&lt;/script&gt;</strong>
    &lt;title&gt;Responsive Videos with: Plain JavaScript - FluidVids.js&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Responsive Videos with: Plain JavaScript - FluidVids.js&lt;/h1&gt;
    &lt;main class="main-container" role="main"&gt;
        &lt;h2&gt;YouTube&lt;/h2&gt;
        &lt;iframe width="560" height="315" src="https://www.youtube.com/embed/vpRsLPI400U" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
        &lt;h2&gt;Vimeo&lt;/h2&gt;
        &lt;iframe width="560" height="315" src="https://player.vimeo.com/video/101875373" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen&gt;&lt;/iframe&gt;
    &lt;/main&gt;
    <strong>&lt;script&gt;</strong>
<strong>        fluidvids.init({</strong>
<strong>            selector: ['iframe'],</strong>
<strong>            players: ['www.youtube.com', 'player.vimeo.com']</strong>
<strong>        });</strong>
<strong>    &lt;/script&gt;</strong>
&lt;/body&gt;
&lt;/html&gt;</pre>

<p>以下是<a id="id492" class="indexterm"/>修改后的DOM：</p>
<pre class="programlisting">&lt;div class="fluidvids" style="padding-top: 56.2%;"&gt;
    &lt;iframe src="https://www.youtube.com/embed/vpRsLPI400U" width="560" height="315" frameborder="0" allowfullscreen class="fluidvids-item" data-fluidvids="loaded"&gt;&lt;/iframe&gt;
&lt;/div&gt;</pre>

<p>这是我在CodePen中为此创建的一个<a id="id493" class="indexterm"/>演示：<a class="ulink" href="http://codepen.io/ricardozea/pen/fda7c2c459392c934130f28cc092dbbe">http://codepen.io/ricardozea/pen/fda7c2c459392c934130f28cc092dbbe </a></p>

<h2 class="title" id="sigil_toc_id_260"><a id="ch06lvl2sec78"/>第三方服务嵌入视频</h2>



<p>我能说什么？您只需<a id="id495" class="indexterm"/>将浏览器指向<a class="ulink" href="http://embedresponsively.com/">http://embedresponsively.com/ </a>并选择要使用的视频服务的选项卡。让我们选择维梅奥。输入您想要做出响应的视频的URL，按下<strong>嵌入</strong>按钮，瞧——您需要使用的HTML和CSS显示在示例视频的正下方。</p>
<p>以下是<a class="ulink" href="http://embedresponsively.com">EmbeddeResponsive.com</a>为著名的Dan Mall关于RWD的视频制作的HTML和CSS片段（已格式化以便于阅读）：</p>
<p>HTML格式如下：</p>
<pre class="programlisting">&lt;div class='embed-container'&gt;
    &lt;iframe src='https://player.vimeo.com/video/101875373' frameborder='0' webkitAllowFullScreen mozallowfullscreen allowFullScreen&gt;&lt;/iframe&gt;
&lt;/div&gt;</pre>

<p>CSS如下所示：</p>
<pre class="programlisting">.embed-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    max-width: 100%;
}
.embed-container iframe,
.embed-container object,
.embed-container embed {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}</pre>

<p>然而，有了<a id="id496" class="indexterm"/>下面的片段，视频的容器看起来比它应该的要高得多。为了使前面的代码段正常工作，我们需要将嵌入容器包装在外部容器中。下面是修改后的标记和CSS。</p>
<p>HTML格式如下：</p>
<pre class="programlisting"><strong>&lt;div class="video-container"&gt;</strong>
    &lt;div class='embed-container'&gt;
        &lt;iframe src='https://player.vimeo.com/video/101875373' frameborder='0' webkitAllowFullScreen mozallowfullscreen allowFullScreen&gt;&lt;/iframe&gt;
   &lt;/div&gt;
<strong>&lt;/div&gt;</strong>
</pre>

<p>CSS如下所示：</p>
<pre class="programlisting"><strong>.video-container {</strong>
<strong>    width: 100%;</strong>
<strong>}</strong>
.embed-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    background: red;
}
.embed-container iframe,
.embed-container object,
.embed-container embed {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
     height: 100%;
}</pre>

<p><code class="literal">.video-container</code>包装器是我们在保持视频宽高比的同时，为了定义所需的任何宽度<a id="id497" class="indexterm"/>而进行的操作。现在，我们需要做的就是将标记放在HTML文档中，将CSS片段放在SCSS文件中。</p>
<p>这是我在CodePen中为此创建的一个<a id="id498" class="indexterm"/>演示：<a class="ulink" href="http://codepen.io/ricardozea/pen/10262216eeb01fc9d3b3bedb9f27c908">http://codepen.io/ricardozea/pen/10262216eeb01fc9d3b3bedb9f27c908 </a></p>


<h1 class="title" id="sigil_toc_id_261"><a id="ch06lvl1sec44"/>矢量格式</h1>



<p>我们将<a id="id499" class="indexterm"/>看到一些HTML和CSS/SCSS片段，以了解如何使用图标字体和<strong>SVG</strong>s，但我们不打算进行此类资产的创建，因为该过程超出了本节的范围。</p>
<h2 class="title" id="sigil_toc_id_262"><a id="ch06lvl2sec79"/>矢量或位图/光栅图像</h2>



<p>当<a id="id500" class="indexterm"/>人们问向量和位图/光栅图像之间的区别是什么时，我经常听到的答案通常围绕着这样一个想法：“如果你放大它，它不会失去质量。不用担心移动设备。”虽然是真的，但它并没有完全回答这个问题。以下是不同之处：</p>
<p><strong>矢量图像</strong>是<a id="id501" class="indexterm"/>由数学方程组成的文件。这些方程式的结果用图形（线条、形状、颜色）表示。如果图像的大小以任何方式发生变化，将重新计算这些方程的值，并再次绘制生成的图形。</p>
<p><strong>位图或光栅图像</strong>是<a id="id502" class="indexterm"/>由像素构成的文件。这些<a id="id503" class="indexterm"/>像素具有特定的/定义的宽度、高度和颜色。如果图像被放大，像素会被拉伸，这就是图像看起来模糊或像素化的原因。</p>
<p>有了这些定义，让我们来谈谈RWD使用的一些矢量格式。向量<a id="id504" class="indexterm"/>格式包括：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">网络字体</li>
<li class="listitem" style="list-style-type: disc">图标字体</li>
<li class="listitem" style="list-style-type: disc">隐静脉移植</li>
</ul>

<p>让我们看看如何快速实现图标字体和SVG；下一章将介绍web字体。</p>

<h2 class="title" id="sigil_toc_id_263"><a id="ch06lvl2sec80"/>图标字体</h2>



<p>图标字体<a id="id505" class="indexterm"/>基本上是一个字体文件，但不是像字形那样有字母，而是图标。有些人喜欢图标字体（我喜欢），有些人并不太喜欢，特别是SVG已经非常流行。</p>
<p>让我们看看图标字体的优缺点。</p>
<p>一些<a id="id506" class="indexterm"/>优点是：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">图标字体的文件大小很可能比SVG字体小。我们可以在一个字体文件中有更多的图标，它的重量比SVG精灵轻很多。</li>
<li class="listitem" style="list-style-type: disc">可以使用用于修改文本的任何属性修改图标字体的属性，例如颜色、字体系列、字体大小等。毕竟，这是一种字体。这意味着我们不必学习任何新的语法或属性。</li>
<li class="listitem" style="list-style-type: disc">它们相对容易实现。一旦所有的<code class="literal">@font-face</code>属性都设置了一次，调用图标字体就是在HTML中添加一个类，并在CSS中调用称为Unicode点的特定代码。</li>
<li class="listitem" style="list-style-type: disc">图标字体是矢量，因此它们在任何屏幕密度、屏幕大小和缩放级别上都保持最佳质量。</li>
<li class="listitem" style="list-style-type: disc">它们的设计非常通用。单个图标字体可以包装在彩色容器中，保留图标（删除），并且仍然是相同的图标，不需要单独的文件。</li>
</ul>

<p><a id="id507" class="indexterm"/>的一些缺点是：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">更新自定义设计的图标需要一些工作，因为我们必须使用第三方应用程序来生成图标字体文件。</li>
<li class="listitem" style="list-style-type: disc">图标字体只能使用单一颜色。老实说，我不认为这是一个缺点。</li>
<li class="listitem" style="list-style-type: disc">图标字体的一个主要缺点是，在字体文件没有加载的情况下实现回退有点复杂，如果你问我的话，会很冗长。图案的名称<a id="id508" class="indexterm"/>为“字体花园”。如果您<a id="id509" class="indexterm"/>想了解它，请查看Zach Leatherman的帖子<em>防弹易用图标字体</em>（<a class="ulink" href="http://www.filamentgroup.com/lab/bulletproof_icon_fonts.html">http://www.filamentgroup.com/lab/bulletproof_icon_fonts.html </a>）。GitHub回购协议可在<a class="ulink" href="https://github.com/filamentgroup/a-font-garde">找到https://github.com/filamentgroup/a-font-garde </a>。</li>
</ul>

<p>以下是我在使用图标字体时可以给你的一些建议：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">如果可能，避免将其用于关键内容。</li>
<li class="listitem" style="list-style-type: disc">始终在使用图标字体的元素中提供<code class="literal">title="" </code>属性。如果字体文件加载失败，至少可以看到标题标签中的文本。</li>
<li class="listitem" style="list-style-type: disc">如果您不介意，可以使用额外的HTML元素来保存图标。如果无法加载图标字体文件，使用或不使用辅助技术的用户仍可使用图标字体所代表的功能。</li>
<li class="listitem" style="list-style-type: disc">根据我多年的经验，我还没有看到图标字体文件无法加载，但这并不意味着它不会发生。因此，我建议您保持在服务器日志的顶部，以确定图标字体文件是否正在下载。如果不是，那么你需要尽快解决这个问题。</li>
</ul>

<p>让我们实现一个图标字体。</p>
<h3 class="title" id="sigil_toc_id_264"><a id="ch06lvl3sec45"/>实现图标字体</h3>



<p>获取图标字体文件的最快方法是使用第三方web应用程序，如IcoMoon.io或Fontello.com。您还可以获得一份Font Awesome。</p>
<h3 class="title" id="sigil_toc_id_265"><a id="tip66"/>提示</h3>
<p>考虑使用字体时要小心。使用带有十分之一图标的完整字体文件，只使用其中的一小部分，这是浪费带宽。如果您只打算使用少数图标字体，那么使用IcoMoon.io或Fontello.com进行自定义图标选择是一个更好的选择。</p>


<p>一旦您能够解压缩提供的文件，您将需要的唯一文件就是<code class="literal">.woff</code>文件。你只需要这个文件的原因是因为浏览器对<code class="literal">.woff</code>文件的支持可以追溯到IE9。除非您希望/需要支持传统浏览器（桌面和移动），否则您可以使用<code class="literal">.eot</code>、<code class="literal">.ttf</code>和<code class="literal">.svg</code>文件。</p>
<h3 class="title" id="sigil_toc_id_266"><a id="tip67"/>提示</h3>
<p>我建议您在尝试支持传统浏览器中的图标字体时，保持简单，避免不必要的麻烦。他们得到的只是文本而不是图标，或者在<code class="literal">title=""</code>属性中显示文本。</p>


<p>让我们将图标字体文件命名为<code class="literal">icon-font.woff</code>。创建一个<code class="literal">/fonts</code>文件夹并将<code class="literal">icon-font.woff</code>文件保存在其中。这就是我们要尝试实现的：一个软蓝色链接，左侧有一个图标<a id="id512" class="indexterm"/>，没有下划线，字体为40px Arial/Helvetica：</p>
<p><img src="img/B02102_06_06.jpg" alt="Implementing icon fonts"/></p>
<h4 class="title" id="sigil_toc_id_267"><a id="ch06lvl4sec22"/>使用伪元素</h4>



<p>使用伪元素的好处在于我们的源标记始终保持干净。在本例中，我们将使用<code class="literal">:before</code>伪元素，但这种技术也适用于<code class="literal">:after</code>伪元素。</p>
<p>让我们来看看构建。</p>
<p>这是HTML代码段：</p>
<pre class="programlisting">&lt;a href="#" class="icon icon-headphones" title="Headphones"&gt;Headphones&lt;/a&gt;</pre>

<p>这是SCS。我们需要的第一件事是一个mixin来处理任何自定义web字体。在这种情况下，它是一种图标字体：</p>
<pre class="programlisting">//Web font mixin
@mixin fontFace($font-family, $file-path) {
    @font-face {
        font: {
            family: $font-family;
            weight: normal;
            style: normal;
        }
    src: url('#{$file-path}.woff') format('woff');
    }
}</pre>

<h3 class="title" id="sigil_toc_id_268"><a id="tip68"/>提示</h3>
<p>注意<code class="literal">font: {…}</code>块中的嵌套属性。通过这样做，我们可以保持事物干燥，避免在以下情况下重复使用术语<em>字体</em>：<code class="literal">font-family</code>、<code class="literal">font-weight</code>和<code class="literal">font-style</code>。</p>


<p>然后，我们使用<em>属性选择器</em>创建一个规则来处理图标字体的基本样式属性：</p>
<pre class="programlisting">//Icon Font specific rule
[class^="icon-"], [class*=" icon-"] {
    font: {
        family: icon-font, Arial, "Helvetica Neue", Helvetica, sans-serif;
        weight: normal;
        style: normal;
        variant: normal;
    }
    text-transform: none;
    line-height: 1;
    speak: none;
    // Improve Font Rendering
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}</pre>

<h3 class="title" id="sigil_toc_id_269"><a id="tip69"/>提示</h3>
<p>注意属性选择器中的<code class="literal">^</code>和<code class="literal">*</code>字符。第一个表示以术语<code class="literal">icon-</code>开头的<em>选择元素，第二个<em>选择包含术语</em><code class="literal">icon-</code>的元素。</em></p>


<p>然后，我们<a id="id514" class="indexterm"/>需要调用<code class="literal">fontFace</code>mixin，以便将字体带入已编译的CSS文件中：</p>
<pre class="programlisting">@include fontFace(icon-font, '/fonts/icon-font');</pre>

<p><code class="literal">fontFace</code>mixin的好处在于，我们只需声明字体名，然后声明文件路径。不需要声明文件扩展名；这件事已经交给mixin了。</p>
<p>这将编译为：</p>
<pre class="programlisting">@font-face {
    font-family: icon-font;
    font-weight: normal;
  font-style: normal;
  src: url("/fonts/icon-font") format("woff");
}</pre>

<p>以下是使用<code class="literal">:before</code>实现魔术的规则：</p>
<pre class="programlisting">.icon-headphones:before {
    content: "\e601";
    margin-right: 10px;
}</pre>

<p>对于基本的样式增强，我们创建了另外两个规则。但是，它们不是必需的。代码如下：</p>
<pre class="programlisting">.icon { font-size: 40px; }

a {
    padding: 5px;
    text-decoration: none;
    color: #2963BD;
    transition: .3s;
    &amp;:hover { color: lighten(#2963BD,20); }
    &amp;:focus { outline: 2px solid orange; }
}</pre>

<p>最终的<a id="id515" class="indexterm"/>编译CSS如下所示：</p>
<pre class="programlisting">[class^="icon-"], [class*=" icon-"] {
    font-family: icon-font, Arial, "Helvetica Neue", Helvetica, sans-serif;
    font-weight: normal;
    font-style: normal;
    font-variant: normal;
    text-transform: none;
    line-height: 1;
    speak: none;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}
@font-face {
    font-family: icon-font;
    font-weight: normal;
    font-style: normal;
    src: url("https://s3-us-west-2.amazonaws.com/s.cdpn.io/9988/icon-font.woff") format("woff");
}

.icon-headphones:before {
    content: "\e601";
    margin-right: 10px;
}
.icon {
    font-size: 40px;
}
a {
    padding: 5px;
    text-decoration: none;
    color: #2963BD;
    -webkit-transition: .3s;
        transition: .3s;
}
a:hover {
    color: #6d9adf;
}
a:focus {
    outline: 2px solid orange;
}</pre>

<p>这是我在CodePen中为此创建的一个<a id="id516" class="indexterm"/>演示：<a class="ulink" href="http://codepen.io/ricardozea/pen/e62b201350efe7f59f91c934f9fc30fa">http://codepen.io/ricardozea/pen/e62b201350efe7f59f91c934f9fc30fa </a></p>
<p>这是我用CodePen创建的另一个<a id="id518" class="indexterm"/>演示，图标字体更高级一些：<a class="ulink" href="http://codepen.io/ricardozea/pen/5a16adffb6565312506c47ca3df69358">http://codepen.io/ricardozea/pen/5a16adffb6565312506c47ca3df69358 </a></p>

<h4 class="title" id="sigil_toc_id_270"><a id="ch06lvl4sec23"/>使用额外的HTML元素</h4>



<p>老实说，使用额外的HTML元素有点违背了将内容与样式分离的原则，因为出于样式的原因添加额外的HTML元素不是一些开发人员推荐的。然而，我们也可以说图标本身实际上是内容，而不是样式。不管是哪种情况，都是这样。</p>
<p>以下是HTML代码片段：</p>
<pre class="programlisting">&lt;a href="#" title="Headphones"&gt;&lt;i class="icon-headphones" aria-hidden="true"&gt;&lt;/i&gt;Headphones&lt;/a&gt;</pre>

<h3 class="title" id="sigil_toc_id_271"><a id="tip70"/>提示</h3>
<p>为了对屏幕阅读器隐藏不相关的内容，我们使用<code class="literal">aria-hidden="true"</code>指令。</p>


<p>上一个示例中的SCSS代码实际上是相同的，只是我们将<code class="literal">font-size: 10px;</code>声明从<code class="literal">.icon</code>类移动到<code class="literal">a</code>规则，然后完全删除<code class="literal">.icon</code>类。您还将看到一些额外的属性，但只是出于样式的原因。</p>
<p>最终的SCS如下所示：</p>
<pre class="programlisting">//Web font mixin
@mixin fontFace($font-family, $file-path) {
    @font-face {
        font: {
        family: $font-family;
        weight: normal;
        style: normal;
    }
    src: url('#{$file-path}.woff') format('woff');
    }
}
//Icon Font specific rule
[class^="icon-"], [class*=" icon-"] {
    font: {
        family: icon-font, Arial, "Helvetica Neue", Helvetica, sans-serif;
        weight: normal;
        style: normal;
        variant: normal;
    }
    text-transform: none;
    line-height: 1;
    speak: none;
    // Improve Font Rendering
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}
@include iconFont(icon-font, '/fonts/icon-font');
.icon-headphones:before {
    content: "\e601";
    margin-right: 10px;
}
a {
   <strong>font-size: 40px;</strong>
    //Styling stuff
    padding: 5px;
    text-decoration: none;
    color: #2963BD;
    transition: .3s;
    &amp;:hover { color: lighten(#2963BD,20); }
    &amp;:focus { outline: 2px solid orange; }
}</pre>

<p><a id="id520" class="indexterm"/>编译的CSS如下所示：</p>
<pre class="programlisting">[class^="icon-"], [class*=" icon-"] {
    font-family: icon-font, Arial, "Helvetica Neue", Helvetica, sans-serif;
    font-weight: normal;
    font-style: normal;
    font-variant: normal;
    text-transform: none;
    line-height: 1;
    speak: none;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

@font-face {
    font-family: icon-font;
    font-weight: normal;
    font-style: normal;
    src: url("https://s3-us-west-2.amazonaws.com/s.cdpn.io/9988/icon-font.woff") format("woff");
}
.icon-headphones:before {
    content: "\e601";
    margin-right: 10px;
}

a {
    font-size: 40px;
    padding: 5px;
    text-decoration: none;
    color: #2963BD;
    -webkit-transition: .3s;
          transition: .3s;
}
a:hover {
    color: #6d9adf;
}
a:focus {
    outline: 2px solid orange;
}</pre>

<p>这是我在<a id="id522" class="indexterm"/>代码笔<a class="ulink" href="http://codepen.io/ricardozea/pen/8ca49cb06aeb070f4643f0a8e064126c">中为此创建的<a id="id521" class="indexterm"/>演示http://codepen.io/ricardozea/pen/8ca49cb06aeb070f4643f0a8e064126c </a>。</p>



<h2 class="title" id="sigil_toc_id_272"><a id="ch06lvl2sec81"/>可缩放矢量图形</h2>



<p>SVG图形<a id="id523" class="indexterm"/>很快获得了难以置信的普及。浏览器支持率为100%，甚至Opera Mini也支持SVG图像。让我们讨论一下SVG图像的一些优缺点：</p>
<p>SVG的<a id="id524" class="indexterm"/>优点：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">可以使用文本编辑器创建和编辑它们。</li>
<li class="listitem" style="list-style-type: disc">它们是100%可访问的。</li>
<li class="listitem" style="list-style-type: disc">它们可以有多种颜色。</li>
<li class="listitem" style="list-style-type: disc">它们是SEO友好的，因为它们可以被索引。</li>
<li class="listitem" style="list-style-type: disc">因为它们是矢量，所以它们在任何屏幕密度、屏幕大小或缩放级别上都保持其质量。</li>
<li class="listitem" style="list-style-type: disc">它们<a id="id525" class="indexterm"/>可以设置动画，甚至<code class="literal">&lt;svg&gt;</code>标签内的元素也可以设置动画。</li>
<li class="listitem" style="list-style-type: disc">SVG规范是W3C开发的一个实际的开放标准。</li>
<li class="listitem" style="list-style-type: disc">可以说，它比使用字体进行图形更具语义。</li>
<li class="listitem" style="list-style-type: disc">除图标字体外，第三方在线图标工具还可以导出到SVG。</li>
<li class="listitem" style="list-style-type: disc">浏览器支持在现代浏览器中是100%可用的。</li>
</ul>

<p>SVG的<a id="id526" class="indexterm"/>缺点：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">SVG sprite文件可能比对应的图标字体更重。</li>
<li class="listitem" style="list-style-type: disc">如果需要传统浏览器支持（IE8及以下版本），则需要映像回退。</li>
<li class="listitem" style="list-style-type: disc">可以另存为SVG的软件通常会在最终文件中添加额外的不必要标记，因此我们要么手动删除它，要么使用第三方优化工具为每个文件执行此操作。这反过来又给开发工作流增加了另一层复杂性。</li>
<li class="listitem" style="list-style-type: disc">尽管SVG是用XML结构制作的，但在文本编辑器中执行编辑需要相当高级的理解。</li>
</ul>

<p>SVG文件基本上是XML格式的文件。以下是耳机图形的标记：</p>
<pre class="programlisting">&lt;svg  width="32" height="32" viewBox="0 0 32 32"&gt;
        &lt;path id="left-ear-pad" d="M9 18h-2v14h2c0.55 0 1-0.45 1-1v-12c0-0.55-0.45-1-1-1z"/&gt;
    &lt;path id="right-ear-pad" d="M23 18c-0.55 0-1 0.45-1 1v12c0 0.6 0.5 1 1 1h2v-14h-2z"/&gt;
        &lt;path id="headband" d="M32 16c0-8.837-7.163-16-16-16s-16 7.163-16 16c0 1.9 0.3 3.8 1 5.464-0.609 1.038-0.958 2.246-0.958 3.5 0 3.5 2.6 6.4 6 6.929v-13.857c-0.997 0.143-1.927 0.495-2.742 1.012-0.168-0.835-0.258-1.699-0.258-2.584 0-7.18 5.82-13 13-13s13 5.8 13 13c0 0.885-0.088 1.749-0.257 2.584-0.816-0.517-1.745-0.87-2.743-1.013v13.858c3.392-0.485 6-3.402 6-6.929 0-1.29-0.349-2.498-0.958-3.536 0.62-1.705 0.958-3.545 0.958-5.465z"/&gt;
&lt;/svg&gt;</pre>

<p>使用SVG图像的方法有很多：通过<code class="literal">&lt;img&gt;</code>、<code class="literal">&lt;object&gt;</code>、<code class="literal">&lt;use&gt;</code>或<code class="literal">&lt;svg&gt;</code>标记内联；以CSS作为背景图像；在条件类中使用Modernizer解决回退问题；或者使用jQuery或纯JavaScript，使用第三方服务，比如grumpicon.com，你可以说。</p>
<p>为了让事情变得简单，我们将重点介绍两种方法：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">通过<code class="literal">&lt;svg&gt;</code>标签内联。</li>
<li class="listitem" style="list-style-type: disc">基于<code class="literal">&lt;img&gt;</code>标记的文件。</li>
</ul>

<h3 class="title" id="sigil_toc_id_273"><a id="ch06lvl3sec46"/>通过&lt;svg&gt;标签内联</h3>



<p>内联<a id="id528" class="indexterm"/>SVG是许多web设计师和开发人员常用的方法。事实上，我们可以用CSS和JavaScript控制SVG的各个部分，这使得它对动画非常有吸引力。</p>
<p>内嵌SVG标记的<a id="id529" class="indexterm"/>缺点之一是图像不可缓存。换句话说，每次图像出现时，浏览器都必须读取SVG的XML。如果页面上有太多SVG，这些SVG可能会对页面速度和最终用户体验造成不利影响。因此，请注意页面的目标以及使用您的网站/应用程序的访问者类型。</p>
<p>以下是链接标记中内嵌的耳机SVG的HTML片段：</p>
<pre class="programlisting">&lt;a href="#"&gt;
    &lt;svg  width="32" height="32" viewBox="0 0 32 32"&gt;
        &lt;path id="left-ear-pad" d="M9 18h-2v14h2c0.55 0 1-0.45 1-1v-12c0-0.55-0.45-1-1-1z" /&gt;
    &lt;path id="right-ear-pad" d="M23 18c-0.55 0-1 0.45-1 1v12c0 0.6 0.5 1 1 1h2v-14h-2z" /&gt;
        &lt;path id="headband" d="M32 16c0-8.837-7.163-16-16-16s-16 7.163-16 16c0 1.9 0.3 3.8 1 5.464-0.609 1.038-0.958 2.246-0.958 3.5 0 3.5 2.6 6.4 6 6.929v-13.857c-0.997 0.143-1.927 0.495-2.742 1.012-0.168-0.835-0.258-1.699-0.258-2.584 0-7.18 5.82-13 13-13s13 5.8 13 13c0 0.885-0.088 1.749-0.257 2.584-0.816-0.517-1.745-0.87-2.743-1.013v13.858c3.392-0.485 6-3.402 6-6.929 0-1.29-0.349-2.498-0.958-3.536 0.62-1.705 0.958-3.545 0.958-5.465z"/&gt;
    &lt;/svg&gt;Headphones
&lt;/a&gt;</pre>

<p>为了控制其大小、与文本的距离和外观，我们添加了以下CSS：</p>
<pre class="programlisting">svg {
    width: 40px;
    height: 40px;
    margin-right: 10px;
    fill: #2963BD;
}
a {
    font-size: 40px;
    text-decoration: none;
    color:#2963BD;
}</pre>

<h3 class="title" id="sigil_toc_id_274"><a id="tip71"/>提示</h3>
<p>通过<code class="literal">&lt;img&gt;</code>标记<em>调用的SVGs文件不受CSS的</em>影响。如果要对其进行任何样式更改，必须在实际的SVG文件中进行更改，或者将SVG标记内联放置。</p>


<p>然而，这个<a id="id530" class="indexterm"/>标记有一个问题。它没有为传统浏览器，特别是IE8及以下版本提供回退。让我们试着解决这个问题。</p>
<h4 class="title" id="sigil_toc_id_275"><a id="ch06lvl4sec24"/>为内联SVG的传统浏览器提供回退图像</h4>



<p><a id="id531" class="indexterm"/>有两种方法可以为内联SVG的传统浏览器提供回退图像。</p>
<h5 class="title" id="sigil_toc_id_276"><a id="ch06lvl5sec02"/>使用&lt;外来物&gt;和&lt;img&gt;标签</h5>



<p>在<code class="literal">&lt;svg&gt;</code>标记<a id="id533" class="indexterm"/>内创建<a id="id532" class="indexterm"/>一个<code class="literal">&lt;foreignObject&gt;</code>元素，并包含一个调用回退映像的<code class="literal">&lt;img&gt;</code>标记：</p>
<pre class="programlisting">&lt;a href="#"&gt;
    &lt;svg  xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="32" height="32" viewBox="0 0 32 32"&gt;
        &lt;path d="M9 18h-2v14h2c0.55 0 1-0.45 1-1v-12c0-0.55-0.45-1-1-1z"/&gt;
        &lt;path d="M23 18c-0.55 0-1 0.45-1 1v12c0 0.6 0.5 1 1 1h2v-14h-2z"/&gt;
        &lt;path d="M32 16c0-8.837-7.163-16-16-16s-16 7.163-16 16c0 1.9 0.3 3.8 1 5.464-0.609 1.038-0.958 2.246-0.958 3.5 0 3.5 2.6 6.4 6 6.929v-13.857c-0.997 0.143-1.927 0.495-2.742 1.012-0.168-0.835-0.258-1.699-0.258-2.584 0-7.18 5.82-13 13-13s13 5.8 13 13c0 0.885-0.088 1.749-0.257 2.584-0.816-0.517-1.745-0.87-2.743-1.013v13.858c3.392-0.485 6-3.402 6-6.929 0-1.29-0.349-2.498-0.958-3.536 0.62-1.705 0.958-3.545 0.958-5.465z"/&gt;
        <strong>&lt;foreignObject&gt;</strong>
<strong>            &lt;img src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/9988/headphones.png" alt="Headphones"&gt;</strong>
<strong>        &lt;/foreignObject&gt;</strong>
    &lt;/svg&gt;Headphones
&lt;/a&gt;</pre>


<h5 class="title" id="sigil_toc_id_277"><a id="ch06lvl5sec03"/>使用&lt;图像&gt;标签</h5>



<p>正如<a id="id534" class="indexterm"/>我们都知道的，没有<code class="literal">&lt;image&gt;</code>标签……或者有？在SVG的世界里，有！此解决方案与第一种方法非常相似。两个不同之处在于我们不使用<code class="literal">&lt;foreignObject&gt;</code>元素，而是使用<code class="literal">&lt;image&gt;</code>标记。这是<code class="literal">&lt;svg&gt;</code>标签内的所有<em>：</em></p>
<pre class="programlisting">&lt;a href="#"&gt;
    &lt;svg  width="32" height="32" viewBox="0 0 32 32"&gt;
        &lt;path id="left-ear-pad" d="M9 18h-2v14h2c0.55 0 1-0.45 1-1v-12c0-0.55-0.45-1-1-1z" /&gt;
        &lt;path id="right-ear-pad" d="M23 18c-0.55 0-1 0.45-1 1v12c0 0.6 0.5 1 1 1h2v-14h-2z" /&gt;
        &lt;path id="headband" d="M32 16c0-8.837-7.163-16-16-16s-16 7.163-16 16c0 1.9 0.3 3.8 1 5.464-0.609 1.038-0.958 2.246-0.958 3.5 0 3.5 2.6 6.4 6 6.929v-13.857c-0.997 0.143-1.927 0.495-2.742 1.012-0.168-0.835-0.258-1.699-0.258-2.584 0-7.18 5.82-13 13-13s13 5.8 13 13c0 0.885-0.088 1.749-0.257 2.584-0.816-0.517-1.745-0.87-2.743-1.013v13.858c3.392-0.485 6-3.402 6-6.929 0-1.29-0.349-2.498-0.958-3.536 0.62-1.705 0.958-3.545 0.958-5.465z"/&gt;
        <strong>&lt;image src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/9988/headphones.png" xlink:href="" alt="Headphones"&gt;</strong>
    &lt;/svg&gt;Headphones
&lt;/a&gt;</pre>

<p>现在，之所以这样做是因为我们将SVG和HTML的一个特性组合到一个元素中。</p>
<p>SVG的特性是，<code class="literal">&lt;image&gt;</code>标记是SVG世界中的有效元素。现在，听起来很奇怪，所有浏览器都将<code class="literal">&lt;image&gt;</code>标记视为一个超出标准的标记，类似于HTML中的<code class="literal">&lt;img&gt;</code>标记。</p>
<p>HTML特性是，通常我们使用<code class="literal">src</code>属性来指向资产的位置。在SVG世界中，使用<code class="literal">xlink:href</code>属性调用资产。如果我们添加一个指向资产的<code class="literal">src</code>属性，并将<code class="literal">xlink:href</code>属性保留为空，那么传统浏览器将看到回退图像，而现代浏览器则不会，因为<code class="literal">xlink:href</code>属性为空。</p>
<p>我建议坚持第二种方法；它只是更简洁，更少麻烦。请记住，我们使用的不是<code class="literal">&lt;img&gt;</code>，而是<code class="literal">&lt;image&gt;</code>。此外，出于本书的目的，我在标记中保留了<code class="literal">xlink:href</code>属性，但这是可选的。如果它是空的，您可以根据需要将其全部删除。</p>
<h3 class="title" id="sigil_toc_id_278"><a id="tip72"/>提示</h3>
<p>在整本书中，我去掉了自动关闭标签上的尾随斜杠<code class="literal">/&gt;</code>，例如<code class="literal">&lt;hr&gt;</code>或<code class="literal">&lt;img&gt;</code>元素。在HTML5中，有没有都可以。但是，SVG中的<code class="literal">path</code>元素中需要结尾斜杠<strong>，这就是为什么在这些示例中可以看到它们。</strong></p>


<p>我刚才提到的这些方法中没有一种会在支持SVG的浏览器上导致双重下载。如果你问我的话，这是一个双赢的局面。</p>



<h3 class="title" id="sigil_toc_id_279">【t0【file-based with the xlink:href and src attributes</h3>



<p>SVG是<a id="id536" class="indexterm"/>一种图像<a id="id537" class="indexterm"/>文件，因此在<code class="literal">&lt;img&gt;</code>中调用它完全有效：</p>
<pre class="programlisting">&lt;img src="img/headphones.svg" alt="Headphones"&gt;</pre>

<p>我们知道SVG在现代浏览器中具有完美的支持，但以前的图像在传统浏览器（IE8及以下版本）中不显示。</p>
<p>还记得前面关于SVG和HTML中的<code class="literal">xlink:href</code>和<code class="literal">src</code>属性的解释吗？好吧，我们要做的和我们在那里做的差不多。但是，我们不需要内联SVG标记，只需要链接到一个SVG文件，同时为旧浏览器提供一个回退图像。</p>
<p>这个聪明的把戏是亚历克赛·滕发明的。以下是标记：</p>
<pre class="programlisting">&lt;a href="#"&gt;
    &lt;svg width="39" height="39"&gt;
        &lt;image <strong>xlink:href="https://s3-us-west-2.amazonaws.com/s.cdpn.io/9988/headphones.svg" src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/9988/headphones.png</strong>" width="39" height="39"&gt;
    &lt;/svg&gt;Headphones
&lt;/a&gt;</pre>

<p>这里也有一些问题。Alexey的技术不是罪魁祸首，而是浏览器，特别是IE9、10和11以及iOS 3和4。他们下载SVG和后备映像。</p>
<p>如果这种双重下载对你来说是可以接受的，并且你明白其后果，那就去做吧。尽管如此，记住在下一个项目中可以在哪些方面进行改进。</p>
<p>下面是我在CodePen中为此创建的演示：</p>
<p>T0http://codepen.io/ricardozea/pen/594e718f36976f8e77d4f9cf1640e29a T1</p>
<h4 class="title" id="sigil_toc_id_280"><a id="ch06lvl4sec25"/>了解SVG的其他来源</h4>



<p>谈到SVG，我们不能不提到当今网页设计和开发行业最引人注目的三个名字：阿米莉亚·贝拉米·罗伊斯、萨拉·苏伊丹和克里斯·科耶。Amelia和<a id="id539" class="indexterm"/>Chris创建了一本关于如何将SVG与回退一起使用的最完整的<a id="id540" class="indexterm"/>指南，我已经读过，<em>SVG回退完整指南</em>（<a class="ulink" href="https://css-tricks.com/a-complete-guide-to-svg-fallbacks/">https://css-tricks.com/a-complete-guide-to-svg-fallbacks/ </a>）。</p>
<p>Sara<a id="id541" class="indexterm"/>如果您想了解SVG的一切，Sara<a id="id541" class="indexterm"/>Soueidan的博客是必读的：<a class="ulink" href="http://sarasoueidan.com/articles/">http://sarasoueidan.com/articles/ </a>。</p>




<h1 class="title" id="sigil_toc_id_281"><a id="ch06lvl1sec45"/>总结</h1>



<p>我们在这里，看着地平线，沿着<code class="literal">srcset</code>或<code class="literal">&lt;picture&gt;</code>的思路思考一些事情？调整大小还是艺术方向？<code class="literal">Retina.js</code>还是Sass混搭？FitVids还是FluidVids？图标字体还是SVG？基于文件的SVG的内联SVG？为游客提供最佳体验的最佳方式是什么？</p>
<p>是的，我知道这种感觉。你知道吗？这是一个很好的问题。否则，我们将无法学习如何掌握RWD。</p>
<p>因为大多数时候我们只是调整图像的大小，<code class="literal">srcset</code>才是我们要做的。将我们的视频包装在一个容器中，再加上几行CSS，这些视频很快就能响应。繁荣太多的视频无法制作？没问题，<code class="literal">FitVids.js</code>通过一个jQuery函数实现了这一点。图标字体的重量比他们的老大哥SVG要轻，但要注意那些服务器日志，以防图标字体文件无法下载。即使有两次下载，使用SVG始终是一场胜利，但通过使用不同的技术并与他人分享您的发现和经验，不断升级。</p>
<p>让我们换个话题，谈谈一个可以决定你的响应性设计的迷人主题：排版。</p>
<p>我们骑吧！</p>

</body>
</html>