<html>
<head><title>Chapter 4. CSS Grids, CSS Frameworks, UI Kits, and Flexbox for RWD</title>
<link rel="stylesheet" href="epub.css" type="text/css"/>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
</head>
<body id="page">
<h1 class="title"><a id="ch04"/>第4章：用于RWD的CSS网格、CSS框架、UI工具包和Flexbox</h1>



<p><strong>响应性网页设计</strong>（<strong>RWD</strong>为每个人构建<a id="id272" class="indexterm"/>响应性网站和应用引入了一个新的工作层。当我们必须在不同的设备和不同的维度上测试我们的工作时，无论内容在哪里中断，我们都需要添加一个断点并再次测试。</p>
<p>这可能会发生很多次。因此，建立一个网站或应用程序将需要比过去更长的时间。</p>
<p>作为网页设计师和开发者，为了让事情变得更有趣，我们需要注意内容是如何在不同维度上布局的，网格如何帮助我们将内容组织到不同的布局。</p>
<p>既然我们已经提到了网格，您是否曾经问过自己，“我们使用网格到底是为了什么？”</p>
<p>借用设计行业的一些术语来回答这个问题，我们使用网格来让内容有节奏、比例和平衡。我们的目标是让那些使用我们的网站/应用程序的人对我们的内容有一个更愉快的体验，因为它更容易扫描（节奏），更容易阅读（比例）和组织（平衡）。</p>
<p>为了加快设计和构建过程，同时保持所有内容在不同维度上的正确格式，许多作者和公司创建了CSS框架和CSS网格，这些框架和CSS网格不仅包含网格，而且还包含许多其他功能和样式，这些功能和样式可以通过使用简单的类名来利用。</p>
<p>随着时间的推移，浏览器开始支持越来越多的CSS3属性，例如Flexbox，使用布局将变得更加容易。这将使得CSS框架内的网格几乎不必要。</p>
<p>让我们看看CSS网格、CSS框架、UI工具包和Flexbox都是关于什么的，以及它们如何帮助我们使用RWD。</p>
<p>在本章中，我们将介绍以下主题：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">什么是网格？</li>
<li class="listitem" style="list-style-type: disc">CSS网格</li>
<li class="listitem" style="list-style-type: disc">用于RWD的CSS网格的优缺点</li>
<li class="listitem" style="list-style-type: disc">CSS框架</li>
<li class="listitem" style="list-style-type: disc">用户界面套件</li>
<li class="listitem" style="list-style-type: disc">用于RWD的CSS框架的优缺点</li>
<li class="listitem" style="list-style-type: disc">创建自定义CSS网格</li>
<li class="listitem" style="list-style-type: disc">使用自定义CSS网格构建示例页面</li>
<li class="listitem" style="list-style-type: disc">使用Flexbox</li>
<li class="listitem" style="list-style-type: disc">使用Flexbox构建示例页面</li>
</ul>

<h1 class="title" id="sigil_toc_id_163"><a id="ch04lvl1sec25"/>什么是网格？</h1>



<p>网格是<a id="id273" class="indexterm"/>一组视觉指南（垂直、水平或两者兼有，因此术语<em>网格</em>，有助于定义元素的放置位置。一旦元素被放置好，我们就会得到一个<em>布局</em>。</p>
<p>使用网格的好处<a id="id274" class="indexterm"/>是放置在网格上的元素将沿着页面和谐流动，在易读性、布局一致性和元素之间的良好比例方面增强用户体验。</p>


<h1 class="title" id="sigil_toc_id_164"><a id="ch04lvl1sec26"/>CSS网格</h1>



<p>CSS网格<a id="id275" class="indexterm"/>基本上是组成列的垂直指南的复合。这些列的属性在CSS文件中定义。此文件包含具有特定宽度的类列表，这些类的宽度与为特定网格生成的列数相匹配。</p>
<p>我们在<a class="link" href="3.html" title="Chapter 3. Mobile-first or Desktop-first?">第三章</a>中已经看到过这一点，<em>是先移动还是先桌面？</em>当我们使用<strong>980网格系统</strong><strong>980GS</strong>对一个固定宽度的旧场地进行改造时。这是SCSS文件：</p>
<pre class="programlisting">*, *:before, *:after {
    box-sizing: border-box;
}

//Container
.container-12 {
     width: 980px;
     padding: 0 10px;
     margin: auto;
}
//Grid &gt;&gt; Global
.grid {
    &amp;-1, &amp;-2, &amp;-3, &amp;-4, &amp;-5, &amp;-6, &amp;-7, &amp;-8, &amp;-9, &amp;-10, &amp;-11, &amp;-12 {
        float: left;
        margin: 0 10px;
    }
}
//Grid &gt;&gt; 12 Columns
.container-12 {
    .grid-1  { width: 60px; }
    .grid-2  { width: 140px; }
    .grid-3  { width: 220px; }
    .grid-4  { width: 300px; }
    .grid-5  { width: 380px; }
    .grid-6  { width: 460px; }
    .grid-7  { width: 540px; }
    .grid-8  { width: 620px; }
    .grid-9  { width: 700px; }
    .grid-10 { width: 780px; }
    .grid-11 { width: 860px; }
    .grid-12 { width: 940px; }
}
//Clear Floated Elements - http://davidwalsh.name/css-clear-fix
.clear, .row {
    &amp;:before,
    &amp;:after { content: ''; display: table; }
    &amp;:after { clear: both; }
}
//Use rows to nest containers
.row { margin-bottom: 10px;
    &amp;:last-of-type { margin-bottom: 0; }
}
//Legacy IE
.clear { zoom: 1; }</pre>

<h3 class="title" id="sigil_toc_id_165"><a id="tip36"/>提示</h3>
<p>请记住<a id="id277" class="indexterm"/>我们将960GS转换为980GS，因为内容物看起来太靠近主容器的边缘，主容器的左右两侧只有10px的水槽。因此，我们在每侧增加10px，使主容器宽980px。</p>


<p>因为我们掌握了HTML5和CSS3的RWD，让我们看看同样的980GS，用百分比使其流畅。</p>
<p>RWD魔术公式为<em>（目标÷背景）x100=结果%</em>。</p>
<p>我们在<a id="id278" class="indexterm"/>这个案例中的上下文是980px，如下所示：</p>
<pre class="programlisting">//Container
.container-12 {
    width: 100%;
    max-width: 980px;
    padding: 0 1.02%;
    margin: auto;
}
//Grid &gt;&gt; Global
.grid {
    &amp;-1, &amp;-2, &amp;-3, &amp;-4, &amp;-5, &amp;-6, &amp;-7, &amp;-8, &amp;-9, &amp;-10, &amp;-11, &amp;-12 {
        float: left;
        margin: 0 1.02%;
    }
}
//Grid &gt;&gt; 12 Columns
.container-12 {
    .grid-1  { width: 6.12%; }
    .grid-2  { width: 14.29%; }
    .grid-3  { width: 22.45%; }
    .grid-4  { width: 30.61%; }
    .grid-5  { width: 38.78%; }
    .grid-6  { width: 46.94%; }
    .grid-7  { width: 55.10%; }
    .grid-8  { width: 63.27%; }
    .grid-9  { width: 71.43%; }
    .grid-10 { width: 79.59%; }
    .grid-11 { width: 87.76%; }
    .grid-12 { width: 95.92%; }
}
//Clear Floated Elements - http://davidwalsh.name/css-clear-fix
.clear, .row {
  &amp;:before,
  &amp;:after { content: ''; display: table; }
  &amp;:after { clear: both; }
}
//Use rows to nest containers
.row { margin-bottom: 10px;
  &amp;:last-of-type { margin-bottom: 0; }
}
//Legacy IE
.clear { zoom: 1; }</pre>

<p>在网页设计中，网格通常由12或16列组成。960GS几乎是最著名的，尽管它一直是一个固定宽度的网格。但其他作者已经将其移植到流体中，例如<em>流体960网格系统</em>，但没有响应性。960GS也有24列的选项，但不像12列版本那样受欢迎。</p>
<p>有<a id="id279" class="indexterm"/>其他用于网页设计的网格没有定义的框架宽度或列数，相反，这些网格可以有无限多的列，例如基于<strong>自适应网页设计</strong>（<strong>AWD</strong>的<em>无框架网格</em>。这意味着<a id="id280" class="indexterm"/>主容器<em>的宽度将</em>捕捉到一个特定的断点，该断点由适合它的列数计算得出。</p>
<h2 class="title" id="sigil_toc_id_166"><a id="ch04lvl2sec44"/>RWD CSS网格的利弊</h2>



<p>列出用于RWD的CSS网格的优缺点背后的想法<a id="id281" class="indexterm"/>是，当我们计划使用某种类型的网格时，我们应该能够做出最明智的决定。它有助于澄清客户的期望和我们的期望，因为使用特定的网格将影响时间线、设计、布局和许多用户体验因素。</p>
<p>优点如下：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">布置图元要容易得多，因为柱可以作为放置的指南。</li>
<li class="listitem" style="list-style-type: disc">如果使用预先构建的CSS网格，则无需进行任何数学运算来处理列和边沟宽度。它已经被网格的作者处理好了。</li>
<li class="listitem" style="list-style-type: disc">我们可以更快地构建，因为我们所需要做的就是将特定的类添加到HTML中的容器中，在大多数情况下，布局会立即发生。</li>
<li class="listitem" style="list-style-type: disc">在web设计中理解网格是相对简单的，因此在已经构建的项目中增强/编辑其他人的标记和代码比他们根本没有使用CSS网格要轻松。</li>
<li class="listitem" style="list-style-type: disc">如果网格是响应的或自适应的，我们就不必太担心断点。</li>
<li class="listitem" style="list-style-type: disc">如果我们使用的是第三方CSS网格，那么任何跨浏览器的问题都已经得到解决。</li>
</ul>

<p><a id="id282" class="indexterm"/>缺点如下：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">一些CSS网格的学习曲线比其他网格更陡峭。</li>
<li class="listitem" style="list-style-type: disc">对于许多CSS网格，我们被限制使用作者创建的名称约定。</li>
<li class="listitem" style="list-style-type: disc">我们可能不得不改变/调整编写HTML的方式。</li>
<li class="listitem" style="list-style-type: disc">有太多的CSS网格可供选择，这对某些人来说可能是压倒性的。</li>
<li class="listitem" style="list-style-type: disc">如果我们的<a id="id283" class="indexterm"/>内容在网格不支持的某些点中断，我们必须花时间修改原始网格以适应每种情况。</li>
</ul>



<h1 class="title" id="sigil_toc_id_167"><a id="ch04lvl1sec27"/>CSS框架</h1>



<p>CSS框架是一组预先构建的功能，基本上有助于加快Web前端开发。这些CSS框架的作者已经处理了许多小而重要的细节，因此决定使用它们的人可以专注于手头的任务，同时将许多决策留给CSS框架自己。</p>
<p>许多开发人员和设计师相信（我也这么认为），任何CSS框架的真正价值都是他们的CSS网格，有时我们会竭尽全力提取CSS网格并定制它以满足我们的需要。</p>
<p>在本书中，我们将重点介绍掌握RWD的CSS网格，而不是从CSS框架或UI工具包（如果碰巧提供的话）中剥离一个。我们很快就会谈到这个问题。</p>
<p>下面的<a id="id285" class="indexterm"/>列表描述了<a id="id286" class="indexterm"/>CSS框架的一些特性和特征：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">CSS框架只关注基于web的开发，而不是本地移动应用。</li>
<li class="listitem" style="list-style-type: disc">CSS框架总是提供CSS网格。</li>
<li class="listitem" style="list-style-type: disc">它们中的许多还提供用户界面组件（就像UI工具包），例如，以HTML和CSS的形式提供滑块、分页、导航栏、排版、按钮等。</li>
<li class="listitem" style="list-style-type: disc">CSS框架和面向web的UI工具包都可以称为<em>前端框架</em>。</li>
</ul>


<h1 class="title" id="sigil_toc_id_168"><a id="ch04lvl1sec28"/>用户界面套件</h1>



<p>与<a id="id287" class="indexterm"/>CSS框架类似，还有另一种类型的前端框架称为UI工具包。然而，UI工具包可以是它们自己的一个品种。</p>
<p>说实话，有时候区分CSS框架和UI工具包是很困难的。但是，不要过多地钻研哪一个是哪一个，重要的是要理解我们为什么首先使用它们，以及它们如何帮助我们构建更好、更快响应的网站和应用程序。</p>
<p>以下列表介绍了UI工具包的一些功能和特征：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a id="id288" class="indexterm"/>基本上有两种类型的UI工具包：一种是使用web技术（HTML和CSS）构建的，可用于基于web的应用程序原型；另一种是由（通常）Photoshop（PSD）文件构成的，用于帮助模拟和设计本机移动应用程序。</li>
<li class="listitem" style="list-style-type: disc">很少有面向web的UI工具包提供某种网格。</li>
<li class="listitem" style="list-style-type: disc">UI工具包的重点是提供用户界面组件，如滑块、分页、导航栏、对话框、覆盖图/模型、按钮、排版、工具提示、列表、手风琴、选项卡系统、旋转木马/幻灯片、表单等。</li>
<li class="listitem" style="list-style-type: disc">在面向web的UI工具包中，体系结构是非常模块化的。这意味着每个组件都可以合并到任何CSS框架中。</li>
</ul>


<h1 class="title" id="sigil_toc_id_169"><a id="ch04lvl1sec29"/>RWD CSS框架的利弊</h1>



<p>以RWD作为我们在布局与屏幕房地产方面做出的任何决定的主要驱动力，让我们来看看CSS框架的好的和不好的东西是什么：</p>
<p><a id="id290" class="indexterm"/>的优点如下：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">它们对于快速构建响应性原型非常有用，而不是显示静态线框。</li>
<li class="listitem" style="list-style-type: disc">跨浏览器问题已经得到解决。</li>
<li class="listitem" style="list-style-type: disc">它们以一种很好的方式迫使您创建基于网格的布局。</li>
<li class="listitem" style="list-style-type: disc">它们提供了一个坚实的起点，可以在此基础上进行构建。</li>
<li class="listitem" style="list-style-type: disc">模块化允许您手工挑选所需的组件。例如，您可以只使用CSS网格模块，也可以使用<code class="literal">forms</code>模块。</li>
<li class="listitem" style="list-style-type: disc">更改样式以适合您的设计相对容易。</li>
<li class="listitem" style="list-style-type: disc">如果你不太擅长CSS，你仍然可以使用CSS框架来实现你自己的设计。</li>
</ul>

<p><a id="id291" class="indexterm"/>缺点如下：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">他们可以用你永远不会使用的CSS来填充你的项目。</li>
<li class="listitem" style="list-style-type: disc">如果您决定使用整个CSS框架，那么它们的占用空间很大。</li>
<li class="listitem" style="list-style-type: disc">您可能需要改变您的习惯和编写HTML和CSS的方式，以适应您正在使用的CSS框架。</li>
<li class="listitem" style="list-style-type: disc">它们可能是固执己见的，因此，如果您不喜欢事物的命名方式，那么您几乎没有定制的选择。</li>
<li class="listitem" style="list-style-type: disc">定制CSS框架是可行的，但它可能非常耗时和危险。将一个名称更改为其他名称，几乎没有办法知道<a id="id292" class="indexterm"/>对框架的其他部分会产生什么影响。</li>
<li class="listitem" style="list-style-type: disc">如果默认样式没有改变以适合您的品牌/设计，那么您的网站或应用程序将不会是独一无二的，并且会看起来像其他人的，在用户面前失去可信度。</li>
<li class="listitem" style="list-style-type: disc">如果您需要构建一些简单的东西，那么使用CSS框架就太过分了。</li>
<li class="listitem" style="list-style-type: disc">每个网站/应用程序或项目都是不同的，因此您可能会花费大量时间更改和覆盖每个项目的属性。</li>
<li class="listitem" style="list-style-type: disc">他们试图解决每一个前端问题。</li>
</ul>

<p>现在我们已经看到了CSS网格、CSS框架和UI工具包的优缺点，是时候做出决定并回答这个问题了：哪种方法最适合RWD？</p>
<p>我承认，答案并不是最鼓舞人心的，但这是事实：这要看情况而定。</p>
<p>如果我们是自由职业者，自己做任何事情，或者在一个非常小的团队中工作，那么可能根本不需要使用任何框架。我们可以根据构建主要框架的相同原则定制一些东西。显然，我们希望自动化任何重复的过程，以便有效地利用我们的时间。</p>
<p>但是如果我们在一个大型团队中工作，一个拥有内部和离岸资源的网络专业人士的大熔炉，也许使用一个框架会有所帮助。这是因为每个人都需要遵守框架的结构，以便所有事情都是一致的。</p>

<h1 class="title" id="sigil_toc_id_170"><a id="ch04lvl1sec30"/>创建自定义CSS网格</h1>



<p>既然我们掌握了RWD，我们就有机会创建自己的CSS网格。然而，我们需要聪明地工作，而不是努力。因此，我们要做的是利用<em>可变网格系统</em>应用程序，并将其结果与我们自己的方法相结合，制作一个移动优先、流畅、定制且坚固的CSS网格，从中我们可以创建健壮的响应性设计。</p>
<p>让我们列出我们的CSS网格需求：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">它应该有12列。</li>
<li class="listitem" style="list-style-type: disc">它的宽度应为1200px，以容纳1280px的屏幕。</li>
<li class="listitem" style="list-style-type: disc">它应该是流体，具有柱和排水沟的相对单位（百分比）。</li>
<li class="listitem" style="list-style-type: disc">它应该使用移动优先的方法。</li>
<li class="listitem" style="list-style-type: disc">它应该使用SCSS语法。</li>
<li class="listitem" style="list-style-type: disc">它应该可用于其他项目。</li>
<li class="listitem" style="list-style-type: disc">它应该是易于使用和理解的。</li>
<li class="listitem" style="list-style-type: disc">它应该易于扩展。</li>
</ul>

<p>以下是我们1200像素宽、12列宽的20px网格的外观：</p>
<p><img src="img/B02102_04_00.jpg" alt="Creating a custom CSS grid"/></p>
<p>黑色的左右填充各为10px。在这个过程结束时，我们将把这些10px转换成百分比。</p>
<h2 class="title" id="sigil_toc_id_171"><a id="ch04lvl2sec45"/>做数学题</h2>



<p>我们将<a id="id295" class="indexterm"/>使用RWD魔法公式：<em>（目标÷背景）x100=结果%</em>。</p>
<p>我们的上下文将是1200px。那么让我们转换一列：<em>80÷1200 x 100=6.67%</em>。</p>
<p>对于两列，我们必须考虑排水沟，即20px。换句话说，我们不能说两列的值正好是160px。这并不完全正确。</p>
<p>两列是：【t0【80px+20px+80px=180px【t1【。</p>
<p>现在让我们转换两列：<em>180÷1200 x 100=15%</em>。</p>
<p>对于三根柱子，我们现在必须考虑两个排水沟：<em>80px+20px+80px+20px+80px=280px</em>。</p>
<p>现在让我们转换三列：<em>280÷1200 x 100=23.33%</em>。</p>
<p>你现在能看到图案了吗？每次我们添加一列时，我们所需要做的就是向值中添加100。这个值也解释了排水沟！</p>
<p>检查我们刚才看到的网格的屏幕截图，可以看到列的值增加了100。</p>
<p>因此，所有方程式如下所示：</p>
<pre class="programlisting">1   column:    80 ÷ 1200 x 100 = <strong>6.67%</strong>
2   columns:  180 ÷ 1200 x 100 = <strong>15%</strong>
3   columns:  280 ÷ 1200 x 100 = <strong>23.33%</strong>
4   columns:  380 ÷ 1200 x 100 = <strong>31.67%</strong>
5   columns:  480 ÷ 1200 x 100 = <strong>40%</strong>
6   columns:  580 ÷ 1200 x 100 = <strong>48.33%</strong>
7   columns:  680 ÷ 1200 x 100 = <strong>56.67%</strong>
8   columns:  780 ÷ 1200 x 100 = <strong>65%</strong>
9   columns:  880 ÷ 1200 x 100 = <strong>73.33%</strong>
10  columns:  980 ÷ 1200 x 100 = <strong>81.67%</strong>
11  columns: 1080 ÷ 1200 x 100 = <strong>90%</strong>
12  columns: 1180 ÷ 1200 x 100 = <strong>98.33%</strong>
</pre>

<p>让我们<a id="id296" class="indexterm"/>为12柱网格创建SCS：</p>
<pre class="programlisting">//Grid 12 Columns
.grid {
    &amp;-1  { width:6.67%; }
    &amp;-2  { width:15%; }
    &amp;-3  { width:23.33%; }
    &amp;-4  { width:31.67%; }
    &amp;-5  { width:40%; }
    &amp;-6  { width:48.33%; }
    &amp;-7  { width:56.67%; }
    &amp;-8  { width:65%; }
    &amp;-9  { width:73.33%; }
    &amp;-10 { width:81.67%; }
    &amp;-11 { width:90%; }
    &amp;-12 { width:98.33%; }
}</pre>

<h3 class="title" id="sigil_toc_id_172"><a id="tip37"/>提示</h3>
<p>在编辑代码时，使用连字符（<code class="literal">-</code>分隔单词可以更容易地选择术语。</p>



<h2 class="title" id="sigil_toc_id_173"><a id="ch04lvl2sec46"/>增加UTF-8字符集指令和信用部分</h2>



<p>不要<a id="id297" class="indexterm"/>忘记在文件顶部包含UTF-8<a id="id298" class="indexterm"/>编码指令，以让浏览器知道我们正在使用的字符集。让我们通过在顶部添加一个Credits部分来美化代码。代码如下：</p>
<pre class="programlisting"><strong>@charset "UTF-8";</strong>

<strong>/*</strong>
<strong>    Custom Fluid &amp; Responsive Grid System</strong>
<strong>    Structure: Mobile-first (min-width)</strong>
<strong>    Syntax: SCSS</strong>
<strong>    Grid: Float-based</strong>
<strong>    Created by: Your Name</strong>
<strong>    Date: MM/DD/YY</strong>
<strong>*/</strong>

//Grid 12 Columns
.grid {
    &amp;-1  { width:6.67%; }
    &amp;-2  { width:15%; }
    &amp;-3  { width:23.33%; }
    &amp;-4  { width:31.67%; }
    &amp;-5  { width:40%; }
    &amp;-6  { width:48.33%; }
    &amp;-7  { width:56.67%; }
    &amp;-8  { width:65%; }
    &amp;-9  { width:73.33%; }
    &amp;-10 { width:81.67%; }
    &amp;-11 { width:90%; }
    &amp;-12 { width:98.33%; }
}</pre>

<h3 class="title" id="sigil_toc_id_174"><a id="tip38"/>提示</h3>
<p>注意<a id="id299" class="indexterm"/>信用<a id="id300" class="indexterm"/>以CSS风格的注释进行注释：<code class="literal">/* */</code>。根据我们编译SCSS文件的方式，这些类型的注释不会被剥离。通过这种方式，信用卡始终可见，以便其他人知道文件的作者。这可能适用于团队，也可能不适用于团队。此外，如果有，显示信用对文件大小的影响是不可察觉的。</p>



<h2 class="title" id="sigil_toc_id_175"><a id="ch04lvl2sec47"/>包括箱体上浆性能和移动式首次混入</h2>



<p>包括<code class="literal">box-sizing</code>属性允许浏览器的盒子模型考虑容器内的填充<a id="id301" class="indexterm"/>；这<a id="id302" class="indexterm"/>意味着填充被减而不是加，从而保持定义的宽度。</p>
<p>由于我们的定制CSS网格的结构将首先是移动的，因此我们需要包括将处理此方面的mixin：</p>
<pre class="programlisting">@charset "UTF-8";

/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Float-based
    Created by: Your Name
    Date: MM/DD/YY
*/

<strong>*, *:before, *:after {</strong>
<strong>    box-sizing: border-box;</strong>
<strong>}</strong>

<strong>//Moble-first Media Queries Mixin</strong>
<strong>@mixin forLargeScreens($width) {</strong>
<strong>    @media (min-width: $width/16+em) { @content }</strong>
<strong>}</strong>

//Grid 12 Columns
.grid {
    &amp;-1  { width:6.67%; }
    &amp;-2  { width:15%; }
    &amp;-3  { width:23.33%; }
    &amp;-4  { width:31.67%; }
    &amp;-5  { width:40%; }
    &amp;-6  { width:48.33%; }
    &amp;-7  { width:56.67%; }
    &amp;-8  { width:65%; }
    &amp;-9  { width:73.33%; }
    &amp;-10 { width:81.67%; }
    &amp;-11 { width:90%; }
    &amp;-12 { width:98.33%; }
}</pre>


<h2 class="title" id="sigil_toc_id_176"><a id="ch04lvl2sec48"/>主容器并将10px转换为百分比值</h2>



<p>由于<a id="id303" class="indexterm"/>我们使用的是移动优先的方法，我们的主容器<a id="id304" class="indexterm"/>默认为100%宽；但我们也会给它一个最大宽度1200px，因为需要创建一个这样大小的网格。</p>
<p>我们还将把10px转换成一个百分比值，因此使用RWD神奇公式：<em>10÷1200 x 100=0.83%</em>。</p>
<p>但是，正如我们之前所看到的，10px（在本例中为0.83%）不够填充，使内容看起来太靠近主容器的边缘。所以我们要将填充增加到20px:<em>20÷1200 x 100=1.67%</em>。</p>
<p>我们还将<a id="id305" class="indexterm"/>与<code class="literal">margin: auto;</code>水平居中放置主容器<a id="id306" class="indexterm"/>。</p>
<h3 class="title" id="sigil_toc_id_177"><a id="tip39"/>提示</h3>
<p>无需将顶部和底部边距的零值声明为水平居中。换句话说，<code class="literal">margin: 0 auto;</code>是不必要的。仅仅宣布<code class="literal">margin: auto;</code>就足够了。</p>


<p>现在让我们将这些值包括在内：</p>
<pre class="programlisting">@charset "UTF-8";

/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Float-based
    Created by: Your Name
    Date: MM/DD/YY
*/

<strong>*, *:before, *:after {</strong>
<strong>    box-sizing: border-box;</strong>
<strong>}</strong>

<strong>//Moble-first Media Queries Mixin</strong>
<strong>@mixin forLargeScreens($width) {</strong>
<strong>    @media (min-width: $width/16+em) { @content }</strong>
<strong>}</strong>

<strong>//Main Container</strong>
<strong>.container-12 {</strong>
<strong>    width: 100%;</strong>
<strong>    //Change this value to ANYTHING you want, no need to edit anything else.</strong>
<strong>    max-width: 1200px;</strong>
<strong>    padding: 0 1.67%;</strong>
<strong>    margin: auto;</strong>
<strong>}</strong>

//Grid 12 Columns
.grid {
    &amp;-1  { width:6.67%; }
    &amp;-2  { width:15%; }
    &amp;-3  { width:23.33%; }
    &amp;-4  { width:31.67%; }
    &amp;-5  { width:40%; }
    &amp;-6  { width:48.33%; }
    &amp;-7  { width:56.67%; }
    &amp;-8  { width:65%; }
    &amp;-9  { width:73.33%; }
    &amp;-10 { width:81.67%; }
    &amp;-11 { width:90%; }
    &amp;-12 { width:98.33%; }
}</pre>

<h3 class="title" id="sigil_toc_id_178"><a id="tip40"/>提示</h3>
<p>在<a id="id307" class="indexterm"/>的<code class="literal">padding</code>属性中，如果我们输入<code class="literal">0.83%</code>或<code class="literal">.83%</code>是相同的。我们可以省略零。保持<a id="id308" class="indexterm"/>代码尽可能精简始终是一个好的实践。这与我们使用十六进制速记值时的原理相同：<code class="literal">#3336699</code>与<code class="literal">#369</code>相同。</p>



<h2 class="title" id="sigil_toc_id_179"><a id="ch04lvl2sec49"/>先让它移动</h2>



<p>在小的<a id="id309" class="indexterm"/>屏幕上，所有的列都将是100%宽的。因为我们使用的是单列布局，所以不使用排水沟；这意味着我们至少现在还不需要申报利润率。</p>
<p>在640px时，网格将启动并为每个列分配相应的百分比，因此我们将在<code class="literal">40em</code>（640px）媒体查询中包含这些列，并将它们浮动到左侧。在这一点上，我们需要排水沟。因此，我们在左边和右边填充<code class="literal">.83%</code>来声明边距。</p>
<h3 class="title" id="sigil_toc_id_180"><a id="tip41"/>提示</h3>
<p>我随意选择了<code class="literal">40em</code>（640px），只是作为一个起点。记住创建基于内容的断点，而不是基于设备的断点。</p>


<p>代码如下：</p>
<pre class="programlisting">@charset "UTF-8";

/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Float-based
    Created by: Your Name
    Date: MM/DD/YY
*/

*, *:before, *:after {
    box-sizing: border-box;
}

//Moble-first Media Queries Mixin
@mixin forLargeScreens($width) {
    @media (min-width: $width/16+em) { @content }
}

//Main Container
.container-12 {
    width: 100%;
    //Change this value to ANYTHING you want, no need to edit anything else.
    max-width: 1200px;
    padding: 0 1.67%;
    margin: auto;
}

<strong>//Grid</strong>
<strong>.grid {</strong>
<strong>    //Global Properties - Mobile-first</strong>
<strong>    &amp;-1, &amp;-2, &amp;-3, &amp;-4, &amp;-5, &amp;-6, &amp;-7, &amp;-8, &amp;-9, &amp;-10, &amp;-11, &amp;-12 {</strong>
<strong>        width: 100%;</strong>
<strong>    }</strong>
<strong>    @include forLargeScreens(640) { //Totally arbitrary width, it's only a starting point.</strong>
<strong>    //Global Properties - Large screens</strong>
<strong>    &amp;-1, &amp;-2, &amp;-3, &amp;-4, &amp;-5, &amp;-6, &amp;-7, &amp;-8, &amp;-9, &amp;-10, &amp;-11, &amp;-12 {</strong>
<strong>        float: left;</strong>
<strong>        margin: 0 .83%;</strong>
<strong>    }</strong>
<strong>    //Grid 12 Columns</strong>
<strong>    .grid {</strong>
<strong>        &amp;-1  { width:6.67%; }</strong>
<strong>        &amp;-2  { width:15%; }</strong>
<strong>        &amp;-3  { width:23.33%; }</strong>
<strong>        &amp;-4  { width:31.67%; }</strong>
<strong>        &amp;-5  { width:40%; }</strong>
<strong>        &amp;-6  { width:48.33%; }</strong>
<strong>        &amp;-7  { width:56.67%; }</strong>
<strong>        &amp;-8  { width:65%; }</strong>
<strong>        &amp;-9  { width:73.33%; }</strong>
<strong>        &amp;-10 { width:81.67%; }</strong>
<strong>        &amp;-11 { width:90%; }</strong>
<strong>        &amp;-12 { width:98.33%; }</strong>
<strong>    }</strong>
<strong>}</strong>
</pre>


<h2 class="title" id="sigil_toc_id_181"><a id="ch04lvl2sec50"/>增加行和浮动清算规则</h2>



<p>如果我们<a id="id310" class="indexterm"/>在HTML结构<a id="id311" class="indexterm"/>中使用行，或者将类<code class="literal">.clear</code>添加到标记中，那么我们可以使用<code class="literal">:before</code>和<code class="literal">:after</code>伪元素在单个嵌套规则中声明所有浮点清除值。</p>
<h3 class="title" id="sigil_toc_id_182"><a id="tip42"/>提示</h3>
<p>声明伪元素时使用单冒号或双冒号也是一样的。双冒号是CSS3语法，单冒号是CSS2.1语法。这个想法是为了能够一眼就将它们区分开来，这样开发人员就可以知道它们是在哪个CSS版本上编写的。但是，IE8及以下版本不支持双冒号语法。</p>


<p><a id="id312" class="indexterm"/>浮点清除技术是David Walsh的CSS片段（<a class="ulink" href="http://davidwalsh.name/css-clear-fix">的改编http://davidwalsh.name/css-clear-fix </a>。</p>
<p>我们还为底部边距为10px的行添加了一条规则，以将它们彼此分开，同时从最后一行删除该边距，以避免在底部创建不必要的额外间距。最后，我们添加了遗留IEs的清除规则。</p>
<p>现在让我们将这些规则包括在内：</p>
<pre class="programlisting">@charset "UTF-8";

/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Float-based
    Created by: Your Name
    Date: MM/DD/YY
*/

*, *:before, *:after {
    box-sizing: border-box;
}

//Moble-first Media Queries Mixin
@mixin forLargeScreens($width) {
    @media (min-width: $width/16+em) { @content }
}

//Main Container
.container-12 {
    width: 100%;
    //Change this value to ANYTHING you want, no need to edit anything else.
    max-width: 1200px;
    padding: 0 1.67%;
    margin: auto;
}

//Grid
.grid {
    //Global Properties - Mobile-first
    &amp;-1, &amp;-2, &amp;-3, &amp;-4, &amp;-5, &amp;-6, &amp;-7, &amp;-8, &amp;-9, &amp;-10, &amp;-11, &amp;-12 {
        width: 100%;
    }
    @include forLargeScreens(640) { //Totally arbitrary width, it's only a starting point.
    //Global Properties - Large screens
    &amp;-1, &amp;-2, &amp;-3, &amp;-4, &amp;-5, &amp;-6, &amp;-7, &amp;-8, &amp;-9, &amp;-10, &amp;-11, &amp;-12 {
        float: left;
        margin: 0 .83%;
    }
    //Grid 12 Columns
    .grid {
        &amp;-1  { width:6.67%; }
        &amp;-2  { width:15%; }
        &amp;-3  { width:23.33%; }
        &amp;-4  { width:31.67%; }
        &amp;-5  { width:40%; }
        &amp;-6  { width:48.33%; }
        &amp;-7  { width:56.67%; }
        &amp;-8  { width:65%; }
        &amp;-9  { width:73.33%; }
        &amp;-10 { width:81.67%; }
        &amp;-11 { width:90%; }
        &amp;-12 { width:98.33%; }
    }
}

<strong>//Clear Floated Elements - http://davidwalsh.name/css-clear-fix</strong>
<strong>.clear, .row {</strong>
<strong>    &amp;:before,</strong>
<strong>    &amp;:after { content: ''; display: table; }</strong>
<strong>    &amp;:after { clear: both; }</strong>
<strong>}</strong>

<strong>//Use rows to nest containers</strong>
<strong>.row { margin-bottom: 10px;</strong>
<strong>    &amp;:last-of-type { margin-bottom: 0; }</strong>
<strong>}</strong>

<strong>//Legacy IE</strong>
<strong>.clear { zoom: 1; }</strong>
</pre>

<p>让我们回顾一下我们的CSS网格需求：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>12列</strong>：从<code class="literal">.grid-1</code>开始<a id="id315" class="indexterm"/>到<code class="literal">.grid-12</code>。</li>
<li class="listitem" style="list-style-type: disc"><strong>1200像素宽，可容纳1280像素屏幕</strong>：<code class="literal">.container-12</code>容器有<code class="literal">max-width: 1200px;</code></li>
<li class="listitem" style="list-style-type: disc"><strong>立柱和排水沟的流体和相对单位（百分比）</strong>：百分比从6.67%到98.33%。</li>
<li class="listitem" style="list-style-type: disc"><strong>Mobile first</strong>：我们添加了Mobile first mixin（使用<code class="literal">min-width</code>），并将网格嵌套在其中。</li>
<li class="listitem" style="list-style-type: disc"><strong>SCSS语法</strong>：整个文件基于Sass。</li>
<li class="listitem" style="list-style-type: disc"><strong>可重用</strong>：只要我们使用12列，并且使用移动优先的方法，我们就可以多次使用这个CSS网格。</li>
<li class="listitem" style="list-style-type: disc"><strong>易于使用和理解</strong>：类名非常简单。<code class="literal">.grid-6</code>网格用于跨越6列的图元，<code class="literal">.grid-7</code>用于跨越7列的图元，依此类推。</li>
<li class="listitem" style="list-style-type: disc"><strong>易于扩展</strong>：如果我们想使用980px而不是1200px，我们只需更改<code class="literal">.container-12 max-width</code>属性中的值即可。由于所有元素都使用相对单位（百分比），因此所有元素都将按比例调整新宽度，以适应<em>任何</em>宽度。如果你问我的话，我觉得很甜蜜。</li>
</ul>



<h1 class="title" id="sigil_toc_id_183"><a id="ch04lvl1sec31"/>使用自定义CSS网格构建示例页面</h1>



<p>下面是<a id="id316" class="indexterm"/>我们将在<a id="id317" class="indexterm"/>示例中使用的HTML：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;title&gt;Mastering RWD with HTML5 &amp;amp; CSS3&lt;/title&gt;
    &lt;link rel="stylesheet" href="css/site-styles.css"&gt;
    &lt;!--[if lt IE 9]&gt;
    &lt;script src="//html5shiv.googlecode.com/svn/trunk/html5.js"&gt;
	&lt;/script&gt;
    &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Basic Layout Using a Custom CSS Grid&lt;/h1&gt;
    &lt;main class="container-12 clear" role="main"&gt;
    &lt;header class="grid-12" role="banner"&gt;Header (.grid-12)&lt;/header&gt;
        &lt;nav class="grid-4" role="navigation"&gt;Nav (.grid-4)&lt;/nav&gt;
        &lt;section class="grid-8"&gt;
          &lt;div class="row"&gt;
              &lt;div class="grid-6 black"&gt;.grid-6&lt;/div&gt;
              &lt;div class="grid-6 black"&gt;.grid-6&lt;/div&gt;
          &lt;/div&gt;
          &lt;div class="row"&gt;
              &lt;div class="grid-4 black"&gt;.grid-4&lt;/div&gt;
              &lt;div class="grid-4 black"&gt;.grid-4&lt;/div&gt;
              &lt;div class="grid-4 black"&gt;.grid-4&lt;/div&gt;
          &lt;/div&gt;
          &lt;div class="row"&gt;
              &lt;div class="grid-3 black"&gt;.grid-3&lt;/div&gt;
              &lt;div class="grid-3 black"&gt;.grid-3&lt;/div&gt;
              &lt;div class="grid-3 black"&gt;.grid-3&lt;/div&gt;
              &lt;div class="grid-3 black"&gt;.grid-3&lt;/div&gt;
          &lt;/div&gt;
          &lt;div class="row"&gt;
              &lt;div class="grid-2 black"&gt;.grid-2&lt;/div&gt;
              &lt;div class="grid-7 black"&gt;.grid-7&lt;/div&gt;
              &lt;div class="grid-3 black"&gt;.grid-3&lt;/div&gt;
          &lt;/div&gt;
          &lt;p&gt;Content (.grid-8)&lt;/p&gt;
        &lt;/section&gt;
    &lt;footer class="grid-12" role="contentinfo"&gt;Footer (.grid-12)&lt;/footer&gt;
    &lt;/main&gt;
&lt;/body&gt;</pre>

<h2 class="title" id="sigil_toc_id_184"><a id="ch04lvl2sec51"/>嵌套容器</h2>



<p>注意<a id="id318" class="indexterm"/>在它们自己的行中有几个嵌套的容器（黑色背景）。这里的想法是突出显示总共12列的嵌套内容部分。</p>
<p>嵌套柱是任何网格系统的主要优势。在本书中，我们利用了这种能力，因此我们不会以任何方式限制设计。</p>
<h3 class="title" id="sigil_toc_id_185"><a id="tip43"/>提示</h3>
<p>我们使用HTML5 Shiv polyfill将HTML5支持添加到IE8及以下版本。</p>


<p>在小屏幕（320像素宽）上，这是容器的外观：</p>
<p><img src="img/B02102_04_01.jpg" alt="Nested containers"/></p>
<p>在40em（640px）宽的<a id="id319" class="indexterm"/>大屏幕上，布局如下：</p>
<p><img src="img/B02102_04_02.jpg" alt="Nested containers"/></p>
<p>您<a id="id320" class="indexterm"/>可以<a id="id321" class="indexterm"/>在<a class="ulink" href="http://codepen.io/ricardozea/pen/d6ab6e0293be9b6bac2e16ad37942ed5">看到我在CodePen上创建的演示http://codepen.io/ricardozea/pen/d6ab6e0293be9b6bac2e16ad37942ed5 </a>。</p>


<h1 class="title" id="sigil_toc_id_186"><a id="ch04lvl1sec32"/>停止使用CSS网格，使用Flexbox！</h1>



<p>我打赌你<a id="id322" class="indexterm"/>没看到这一次，哈！</p>
<p>事实上，Flexbox是一个惊人的CSS属性，它为新的视野打开了布局的可能性。以下是关于Flexbox的几件事：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">它的浏览器支持在现代浏览器中是完美的。</li>
<li class="listitem" style="list-style-type: disc">IE8和IE9不支持它。但是不用担心，使用<a class="link" href="3.html" title="Chapter 3. Mobile-first or Desktop-first?">第3章</a>、<em>移动优先还是桌面优先中提到的条件类技术来处理这两个浏览器非常简单？</em></li>
<li class="listitem" style="list-style-type: disc">IE10只支持2012语法，但Autoprefixer（在Prepos中）为我们自动处理这个老供应商的前缀。</li>
<li class="listitem" style="list-style-type: disc">我们在使用Flexbox时需要小心，因为旧的<code class="literal">display: box;</code>语法会导致浏览器在布局中执行多次传递，从而降低性能。</li>
<li class="listitem" style="list-style-type: disc">相比之下，新/当前语法<code class="literal">display: flex</code>；对性能没有任何影响。从旧语法开始，浏览器性能问题已经得到解决，因此我们应该处于良好状态。</li>
</ul>

<h3 class="title" id="sigil_toc_id_187"><a id="tip44"/>提示</h3>
<p>Paul Irish<a id="id324" class="indexterm"/>和Ojan Vafai在<strong>后文</strong>中对此进行了很好的解释，Flexbox布局并不慢，可以在<a class="ulink" href="http://updates.html5rocks.com/2013/10/Flexbox-layout-isn-t-slow">中找到http://updates.html5rocks.com/2013/10/Flexbox-layout-isn-t-slow </a>。</p>


<p>我们开始吧，好吗？</p>
<h2 class="title" id="sigil_toc_id_188"><a id="ch04lvl2sec52"/>使用Flexbox构建示例页面</h2>



<p>在下面的<a id="id325" class="indexterm"/>示例中，我们将使用定制CSS网格构建相同的布局，但使用Flexbox属性。这将帮助我们更好地理解Flexbox的威力，并最终将我们从CSS网格中分离出来，同时在HTML中保留更具语义的结构。</p>
<h3 class="title" id="sigil_toc_id_189"><a id="tip45"/>提示</h3>
<p>Chris Coyer的一篇伟大的<a id="id326" class="indexterm"/>文章<strong>是Flexbox</strong>的完整指南，可在<a class="ulink" href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">找到https://css-tricks.com/snippets/css/a-guide-to-flexbox/ </a>。</p>


<p>关于示例页面，需要注意以下几点：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">我们在<code class="literal">&lt;html&gt;</code>元素中包含条件类，以支持传统浏览器，并通过使用JavaScript文件依赖项将一个请求保存到服务器。</li>
<li class="listitem" style="list-style-type: disc">因为<a id="id327" class="indexterm"/>我们没有使用CSS网格，所以嵌套的容器必须在其中显示术语<strong>内容</strong>。</li>
<li class="listitem" style="list-style-type: disc">我们将使用HTML5 Shiv polyfill来支持IE8对所有必要的HTML5标记的支持。</li>
<li class="listitem" style="list-style-type: disc">由于IE10在Flexbox中存在一些数学计算问题，因此我们需要在<code class="literal">&lt;html&gt;</code>元素中添加一个<code class="literal">.ie10</code>类。我们将通过在IE中使用Louis Lazaris创建的简单脚本来实现这一点，不包括条件注释，这样IE8/9就不会运行该脚本。关于这个脚本的所有信息<a id="id328" class="indexterm"/>都可以在<a class="ulink" href="http://www.impressivewebs.com/ie10-css-hacks/">的文章中找到http://www.impressivewebs.com/ie10-css-hacks/ </a>。</li>
</ul>

<h3 class="title" id="sigil_toc_id_190"><a id="tip46"/>提示</h3>
<p>我们用于瞄准IE10的脚本没有使用用户代理嗅探。UA嗅探被认为不是一种好的做法。脚本正在使用条件编译<a id="id329" class="indexterm"/>语句。有关<code class="literal">@cc_on</code>声明的更多信息，请参见<strong>微软开发者网络</strong>（<strong>MSDN</strong>：<a class="ulink" href="https://msdn.microsoft.com/en-us/library/8ka90k2e(v=vs.94).aspx">中的<a id="id330" class="indexterm"/>部分https://msdn.microsoft.com/en-us/library/8ka90k2e（v=vs.94）。aspx</a>。</p>


<p>这就是Flexbox布局在小屏幕（320px宽）上的外观：</p>
<p><img src="img/B02102_04_03.jpg" alt="Building a sample page with Flexbox"/></p>
<p>这就是它在大屏幕上的样子。此屏幕宽768px，但内容为<code class="literal">40em</code>（640px）：</p>
<p><img src="img/B02102_04_04.jpg" alt="Building a sample page with Flexbox"/></p>
<h3 class="title" id="sigil_toc_id_191"><a id="ch04lvl3sec35"/>HTML</h3>



<p>以下是<a id="id332" class="indexterm"/>我们将在示例页面中使用的标记：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;!--[if IE 8]&gt; &lt;html class="no-js ie8" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if IE 9]&gt; &lt;html class="no-js ie9" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if gt IE 9]&gt;&lt;!--&gt;&lt;html class="no-js" lang="en"&gt;&lt;!--&lt;![endif]--&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;Basic Layout Using Flexbox&lt;/title&gt;
    &lt;!--[if lt IE 9]&gt;
      &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;
	  &lt;/script&gt;
    &lt;![endif]--&gt;
	&lt;!--[if !IE]&gt;&lt;!--&gt;
      &lt;script&gt;
        if (/*@cc_on!@*/false &amp;&amp; document.documentMode === 10) {
          document.documentElement.className+=' ie10';
        }
      &lt;/script&gt;
    &lt;!--&lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Basic Layout Using Flexbox&lt;/h1&gt;
    &lt;main class="main-container" role="main"&gt;
        &lt;header role="banner"&gt;Header&lt;/header&gt;
        &lt;!-- Flexible elements need to be wrapped in a container --&gt;
        &lt;div class="flex-container"&gt;
            &lt;nav role="navigation"&gt;Nav&lt;/nav&gt;
            &lt;section&gt;
                &lt;div class="flex-container row-1"&gt;
                    &lt;div class="level-1"&gt;content&lt;/div&gt;
                    &lt;div class="level-1"&gt;content&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="flex-container row-2"&gt;
                    &lt;div class="level-1"&gt;content&lt;/div&gt;
                    &lt;div class="level-1"&gt;content&lt;/div&gt;
                    &lt;div class="level-1"&gt;content&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="flex-container row-3"&gt;
                    &lt;div class="level-1"&gt;content&lt;/div&gt;
                    &lt;div class="level-1"&gt;content&lt;/div&gt;
                    &lt;div class="level-1"&gt;content&lt;/div&gt;
                    &lt;div class="level-1"&gt;content&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="flex-container row-4"&gt;
                    &lt;div class="level-1 content-a"&gt;content&lt;/div&gt;
                    &lt;div class="level-1 content-b"&gt;"&gt;content&lt;/div&gt;
                    &lt;div class="level-1 content-c"&gt;content&lt;/div&gt;
                &lt;/div&gt;
                &lt;p&gt;Content&lt;/p&gt;
            &lt;/section&gt;
        &lt;/div&gt;
        &lt;footer role="contentinfo"&gt;Footer&lt;/footer&gt;
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>


<h3 class="title" id="sigil_toc_id_192"><a id="ch04lvl3sec36"/>SCSS</h3>



<p>SCSS<a id="id333" class="indexterm"/>代码有几个部分类似于CSS网格中使用的代码。然而，也有重要的区别。</p>
<p>让我们把它拆开。</p>
<p>我们将首先创建Credits部分、<code class="literal">box-sizing: border-box;</code>参数以说明容器内部而非外部的填充、移动首次混合以及主要容器属性：</p>
<pre class="programlisting">/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Flexbox-based
    Created by: Your Name
    Date: MM/DD/YY
*/
*, *:before, *:after {
  box-sizing: border-box;
}
//Moble-first Media Queries Mixin
@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content }
}
//Main container
.main-container {
    width: 100%;
    //Change this value to ANYTHING you want, no need to edit anything else
    max-width: 1200px;
    //Any value you want
    padding: 0 1.67%;
    margin: auto;
}</pre>


<h3 class="title" id="sigil_toc_id_193"><a id="ch04lvl3sec37"/>添加Flexbox容器</h3>



<p>现在，让我们为Flexbox容器添加<a id="id334" class="indexterm"/>属性，该容器的行为有点类似于CSS网格中的<code class="literal">.row</code>。代码如下：</p>
<pre class="programlisting">/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Flexbox-based
    Created by: Your Name
    Date: MM/DD/YY
*/
*, *:before, *:after {
    box-sizing: border-box;
}
//Moble-first Media Queries Mixin
@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content }
}
//Main container
.main-container {
    width: 100%;
  //Change this value to ANYTHING you want, no need to edit anything else
    max-width: 1200px;
    //Any value you want
    padding: 0 1.67%;
    margin: auto;
}
<strong>//Flexbox container</strong>
<strong>.flex-container {</strong>
<strong>    margin-bottom: 10px;</strong>
<strong>    //Remove the margin from the last flexbox container</strong>
<strong>    &amp;:last-of-type {</strong>
<strong>        margin-bottom: 0;</strong>
<strong>    }</strong>
<strong>    @include forLargeScreens(640) {</strong>
<strong>        display: flex;</strong>
<strong>    }</strong>
<strong>}</strong>
</pre>

<p>如您所见，我们正在添加<code class="literal">margin-bottom: 10px;</code>以分隔内容行。但是，我们正在删除最后一个Flexbox容器上的边距，以便它不会在末尾生成不需要的额外填充。</p>
<p>然后我们加入了<a id="id335" class="indexterm"/>第一款移动混音器，目标屏幕宽度为640像素（<code class="literal">40em</code>。这意味着我们<strong>只</strong>将在大屏幕上使用Flexbox，但在小屏幕上，我们不会使用它。</p>
<h3 class="title" id="sigil_toc_id_194"><a id="tip47"/>提示</h3>
<p>如果所有列的宽度相等，则无需使用Flexbox。在我们的示例中，小屏幕中的列是100%宽的。</p>


<h4 class="title" id="sigil_toc_id_195"><a id="ch04lvl4sec18"/>Flexbox容器内的DIVs</h4>



<p>现在，让我们在大屏幕上的列中添加<a id="id336" class="indexterm"/>左右边距。在小屏幕上，列没有边距。记住<em>10px=0.83%</em>。</p>
<p>我们将使用带有星号/星号的属性选择器，这样我们就可以将所有div作为目标，这些div至少包含一个类名中带有<code class="literal">level-</code>的值。我们还将删除第一个容器上的左边距和最后一个容器上的右边距，以便将div刷新到其父容器的边缘。代码如下：</p>
<pre class="programlisting">/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Flexbox-based
    Created by: Your Name
    Date: MM/DD/YY
*/
*, *:before, *:after {
    box-sizing: border-box;
}
//Moble-first Media Queries Mixin
@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content }
}
//Main container
.main-container {
    width: 100%;
    //Change this value to ANYTHING you want, no need to edit anything else
    max-width: 1200px;
    //Any value you want
    padding: 0 1.67%;
    margin: auto;
}
//Flexbox container
.flex-container {
    margin-bottom: 10px;
    //Remove the margin from the last flexbox container
    &amp;:last-of-type {
        margin-bottom: 0;
    }
    @include forLargeScreens(640) {
        display: flex;
    }
}
<strong>//DIVs inside the flex container</strong>
<strong>[class*="level-"] {</strong>
<strong>    width: 100%;</strong>
<strong>    @include forLargeScreens(640) {</strong>
<strong>        margin: 0 .83%;</strong>
<strong>    }</strong>
<strong>    &amp;:first-of-type { margin-left: 0; }</strong>
<strong>    &amp;:last-of-type { margin-right: 0; }</strong>
<strong>}</strong>
</pre>



<h3 class="title" id="sigil_toc_id_196"><a id="ch04lvl3sec38"/>页眉、页脚、导航和剖面容器</h3>



<p>现在，<a id="id337" class="indexterm"/>页眉和页脚部分在小<a id="id338" class="indexterm"/>和大屏幕上都是100%宽的，因此它们不需要任何特定的规则。然而，本例在页眉和页脚部分都添加了一些属性，但<a id="id339" class="indexterm"/>只是出于样式的原因，而不是布局的原因。尽管如此，导航和剖面容器确实具有特定的宽度，这取决于可用的屏幕宽度。</p>
<p>在小屏幕上，导航和分段集装箱的宽度为100%，而在大屏幕上，它们并排放置；导航容器的宽度为33%，右边距为1.67%（等于20px）的边沟。在大屏幕上，节容器的宽度为65.33%。公式如下：<em>33%+1.67%+65.33=100%</em>。</p>
<p>让我们继续为导航和剖面容器定义这些属性：</p>
<pre class="programlisting">/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Flexbox-based
    Created by: Your Name
    Date: MM/DD/YY
*/
*, *:before, *:after {
    box-sizing: border-box;
}
//Moble-first Media Queries Mixin
@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content }
}
//Main container
.main-container {
    width: 100%;
    //Change this value to ANYTHING you want, no need to edit anything else
    max-width: 1200px;
    //Any value you want
    padding: 0 1.67%;
    margin: auto;
}
//Flexbox container
.flex-container {
    margin-bottom: 10px;
    //Remove the margin from the last flexbox container
    &amp;:last-of-type {
        margin-bottom: 0;
    }
    @include forLargeScreens(640) {
        display: flex;
    }
}
<strong>//DIVs inside the flex container</strong>
<strong>[class*="level-"] {</strong>
<strong>    width: 100%;</strong>
<strong>    @include forLargeScreens(640) {</strong>
<strong>        margin: 0 .83%;</strong>
<strong>    }</strong>
<strong>    &amp;:first-of-type { margin-left: 0; }</strong>
<strong>    &amp;:last-of-type { margin-right: 0; }</strong>
<strong>}</strong>
<strong>//Nav</strong>
<strong>nav {</strong>
<strong>    width: 100%;</strong>
<strong>    @include forLargeScreens(640) {</strong>
<strong>        width: 33%;</strong>
<strong>        margin-right: 1.67%;</strong>
<strong>    }</strong>
<strong>}</strong>
<strong>//Content area</strong>
<strong>section {</strong>
<strong>    width: 100%;</strong>
<strong>    @include forLargeScreens(640) {</strong>
<strong>        width: 65.33%;</strong>
<strong>    }</strong>
<strong>}</strong>
</pre>


<h3 class="title" id="sigil_toc_id_197"><a id="ch04lvl3sec39"/>嵌套容器</h3>



<p>最后，对于<a id="id340" class="indexterm"/>这个例子，我们将为具有黑色背景的不同内容节定义宽度，这样您就可以清楚地了解如何嵌套容器。</p>
<p>我们基本上是为<code class="literal">.content-a</code>和<code class="literal">.content-c</code>分配特定但不同的宽度，这是该行的第一个和第三个内容区域。不需要为第二个内容区域指定宽度，除非我们愿意。Flexbox将使第二个容器完全占据第一个和第三个内容区域之间的所有剩余空间。</p>
<h3 class="title" id="sigil_toc_id_198"><a id="tip48"/>提示</h3>
<p>IE10在计算嵌套容器值时存在问题，因此我们需要为这些容器创建特定的宽度。我们将在为IE8和IE9创建的相同规则中包含IE10的宽度。</p>


<p>我之所以使用30%和42%这样的任意值，是为了向您展示我们可以随心所欲地使用这些值，并且只要有可用空间，Flexbox将始终尝试保持这些比例。</p>
<p>现在，让我们为不同的嵌套容器添加这些属性：</p>
<pre class="programlisting">/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Flexbox-based
    Created by: Your Name
    Date: MM/DD/YY
*/
*, *:before, *:after {
    box-sizing: border-box;
}
//Moble-first Media Queries Mixin
@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content }
}
.main-container {
    //Change this value to ANYTHING you want, no need to edit anything else.
    width: 100%;
    max-width: 1200px;
    //Any value you want
    padding: 0 1.67%;
    margin: auto;
}
//Flexbox container
.flex-container {
    margin-bottom: 10px;
    //Remove the margin from the last flexbox container
    &amp;:last-of-type {
        margin-bottom: 0;
    }
    @include forLargeScreens(640) {
        display: flex;
    }
}
<strong>//DIVs inside the flex container</strong>
<strong>[class*="level-"] {</strong>
<strong>    width: 100%;</strong>
<strong>    @include forLargeScreens(640) {</strong>
<strong>        margin: 0 .83%;</strong>
<strong>    }</strong>
<strong>    &amp;:first-of-type { margin-left: 0; }</strong>
<strong>    &amp;:last-of-type { margin-right: 0; }</strong>
<strong>}</strong>
<strong>//Nav</strong>
<strong>nav {</strong>
<strong>    width: 100%;</strong>
<strong>    @include forLargeScreens(640) {</strong>
<strong>        width: 33%;</strong>
<strong>        margin-right: 1.67%;</strong>
<strong>    }</strong>
<strong>}</strong>
<strong>//Content area</strong>
<strong>section {</strong>
<strong>    width: 100%;</strong>
<strong>    @include forLargeScreens(640) {</strong>
<strong>        width: 65.33%;</strong>
<strong>    }</strong>
<strong>}</strong>
<strong>//Different width containers</strong>
<strong>.content- {</strong>
<strong>    @include forLargeScreens(640) {</strong>
<strong>        &amp;a { width: 30%; }</strong>
<strong>        &amp;c { width: 42%; }</strong>
<strong>    }</strong>
<strong>}</strong>
</pre>


<h3 class="title" id="sigil_toc_id_199"><a id="ch04lvl3sec40"/>养老</h3>



<p>使用<a id="id341" class="indexterm"/>Flexbox并没有附带关于IE8、IE9和IE10的警告。</p>
<p>与传统浏览器一样，只需调整值和测试即可获得最佳结果。记住，网站不必在每个浏览器中都看起来完全相同。</p>
<p>让我们澄清几件事。类<code class="literal">.ie8</code>和<code class="literal">.ie9</code>来自<code class="literal">&lt;html&gt;</code>元素中的条件类。类<code class="literal">.ie10</code>来自IE中的脚本，不包括条件注释。因此，IE8和IE9无法运行此脚本。但是不用担心，解决方案很简单，你会看到的。让我们看看。</p>
<h4 class="title" id="sigil_toc_id_200"><a id="ch04lvl4sec19"/>一条规则就可以统治所有人</h4>



<p>我们要做的第一件事是为这三个方面创建一个规则：IE8、IE9和IE10。在这个规则中，我们将以百分比的形式声明嵌套容器的宽度。说实话，我们也可以用像素来表示这些宽度，但出于与所有其他响应示例一致的原因，我们将使用百分比。</p>
<p>这里有一条规则…好吧，规则他们所有人：</p>
<pre class="programlisting">/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Flexbox-based
    Created by: Your Name
    Date: MM/DD/YY
*/
*, *:before, *:after {
    box-sizing: border-box;
}
//Moble-first Media Queries Mixin
@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content }
}
.main-container {
    //Change this value to ANYTHING you want, no need to edit anything else.
    width: 100%;
    max-width: 1200px;
    //Any value you want
    padding: 0 1.67%;
    margin: auto;
}
//Flexbox container
.flex-container {
    margin-bottom: 10px;
    //Remove the margin from the last flexbox container
    &amp;:last-of-type {
        margin-bottom: 0;
    }
    @include forLargeScreens(640) {
        display: flex;
    }
}
//DIVs inside the flex container
[class*="level-"] {
    width: 100%;
    @include forLargeScreens(640) {
        margin: 0 .83%;
    }
    &amp;:first-of-type { margin-left: 0; }
    &amp;:last-of-type { margin-right: 0; }
}
//Nav
nav {
    width: 100%;
    @include forLargeScreens(640) {
        width: 33%;
        margin-right: 1.67%;
    }
}
//Content area
section {
    width: 100%;
    @include forLargeScreens(640) {
        width: 65.33%;
    }

}
//Different width containers
.content- {
    @include forLargeScreens(640) {
        &amp;a { width: 30%; }
        &amp;c { width: 42%; }
    }
}
<strong>//All IEs</strong>
<strong>.ie8, .ie9, .ie10 {</strong>
<strong>    //Exact values (desired width − 0.83% = result %) are commented, but they need tweaked to have one value for all IEs</strong>
<strong>    section {</strong>
<strong>        .row-1 .level-1 { width: 49.17%; }</strong>
<strong>        //Exact value is 32.17%</strong>
<strong>        .row-2 .level-1 { width: 32.20%; }</strong>
<strong>        //Exact value is 24.17%</strong>
<strong>        .row-3 .level-1 { width: 23.75%; }</strong>
<strong>        .row-4 {</strong>
<strong>          .content-a { width: 19.17%; }</strong>
<strong>          .content-b { width: 49.17%; }</strong>
<strong>          //Exact value is 29.17%</strong>
<strong>          .content-c { width: 28.3%; }</strong>
<strong>        }</strong>
<strong>    }</strong>
<strong>}</strong>
</pre>


<h4 class="title" id="sigil_toc_id_201"><a id="ch04lvl4sec20"/>IE8和IE9的规则</h4>



<p>现在我们将<a id="id343" class="indexterm"/>声明处理IE8和IE9值的规则。我们<a id="id344" class="indexterm"/>宣布<code class="literal">overflow: hidden;</code>清除其父容器<code class="literal">.flex-container</code>DIVs中的浮子。然后我们向左浮动到导航和内容部分，并给它们一个高度；此高度仅用于造型目的。</p>
<p>我们给导航部分一个1%的宽度和边距，以保持简单。我们还为内容部分指定了一个宽度。然后，我们使用页脚清除带有<code class="literal">clear: both;</code>和<code class="literal">zoom: 1;</code>参数的浮动导航和内容部分，以便更好地测量。</p>
<p>以下是IE8/9的SCS：</p>
<pre class="programlisting">/*
    Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Flexbox-based
    Created by: Your Name
    Date: MM/DD/YY
*/
*, *:before, *:after {
    box-sizing: border-box;
}
//Moble-first Media Queries Mixin
@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content }
}
.main-container {
    //Change this value to ANYTHING you want, no need to edit anything else.
    width: 100%;
    max-width: 1200px;
    //Any value you want
    padding: 0 1.67%;
    margin: auto;
}
//Flexbox container
.flex-container {
    margin-bottom: 10px;
    //Remove the margin from the last flexbox container
    &amp;:last-of-type {
        margin-bottom: 0;
    }
    @include forLargeScreens(640) {
        display: flex;
    }
}
//DIVs inside the flex container
[class*="level-"] {
    width: 100%;
    @include forLargeScreens(640) {
        margin: 0 .83%;
    }
    &amp;:first-of-type { margin-left: 0; }
    &amp;:last-of-type { margin-right: 0; }
}
//Nav
nav {
    width: 100%;
    @include forLargeScreens(640) {
        width: 33%;
        margin-right: 1.67%;
    }
}
//Content area
section {
    width: 100%;
    @include forLargeScreens(640) {
        width: 65.33%;
    }
}
//Different width containers
.content- {
    @include forLargeScreens(640) {
        &amp;a { width: 30%; }
        &amp;c { width: 42%; }
    }
}
//All IEs
.ie8, .ie9, .ie10 {
    //Exact values (desired width − 0.83% = result %) are commented, but they need tweaked to have one value for all IEs
    section {
        .row-1 .level-1 { width: 49.17%; }
        //Exact value is 32.17%
        .row-2 .level-1 { width: 32.20%; }
        //Exact value is 24.17%
        .row-3 .level-1 { width: 23.75%; }
        .row-4 {
          .content-a { width: 19.17%; }
          .content-b { width: 49.17%; }
          //Exact value is 29.17%
          .content-c { width: 28.3%; }
        }
    }
}
<strong>//IE8/9</strong>
<strong>.ie8, .ie9 {</strong>
<strong>    .flex-container { overflow: hidden; }</strong>
<strong>    nav, section { float: left; min-height: 440px; }</strong>
<strong>    nav { width: 29%; margin-right: 1%; }</strong>
<strong>    section { width: 70%; }</strong>
<strong>    footer { clear: both; zoom: 1; }</strong>
<strong>}</strong>
</pre>


<h4 class="title" id="sigil_toc_id_202"><a id="ch04lvl4sec21"/>IE8和IE9的具体规则</h4>



<p>最后，我们<a id="id345" class="indexterm"/>通过两条<a id="id346" class="indexterm"/>规则为传统浏览器敲定了交易：一条用于IE8，另一条用于IE9，使用属性选择器对所有嵌套容器进行选择。</p>
<p>对于IE8，我们给出嵌套容器<code class="literal">display: inline-block;</code>而不是<code class="literal">float: left;</code>，以使嵌套容器组集中在它们对应的行中。如果我们不这样做，所有行的右侧都会有奇怪的间隙。我们还将宣布左右边缘为0.2%。测试后，任何较大的值都会使嵌套容器包裹。</p>
<p>对于IE9，我们将把嵌套容器浮动到左侧。</p>
<p>让我们看看这两条规则：</p>
<pre class="programlisting">/*
  Custom Fluid &amp; Responsive Grid System
    Structure: Mobile-first (min-width)
    Syntax: SCSS
    Grid: Flexbox-based
    Created by: Your Name
    Date: MM/DD/YY
*/
*, *:before, *:after {
    box-sizing: border-box;
}
//Moble-first Media Queries Mixin
@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content }
}
.main-container {
    //Change this value to ANYTHING you want, no need to edit anything else.
    width: 100%;
    max-width: 1200px;
    //Any value you want
    padding: 0 1.67%;
    margin: auto;
}
//Flexbox container
.flex-container {
    margin-bottom: 10px;
    //Remove the margin from the last flexbox container
    &amp;:last-of-type {
        margin-bottom: 0;
    }
  @include forLargeScreens(640) {
        display: flex;
    }
}
//DIVs inside the flex container
[class*="level-"] {
    width: 100%;
    @include forLargeScreens(640) {
        margin: 0 .83%;
    }
    &amp;:first-of-type { margin-left: 0; }
    &amp;:last-of-type { margin-right: 0; }
}
//Nav
nav {
    width: 100%;
    @include forLargeScreens(640) {
        width: 33%;
        margin-right: 1.67%;
    }
}
//Content area
section {
    width: 100%;
    @include forLargeScreens(640) {
        width: 65.33%;
    }
}
//Different width containers
.content- {
    @include forLargeScreens(640) {
        &amp;a { width: 30%; }
        &amp;c { width: 42%; }
    }
}
//All IEs
.ie8, .ie9, .ie10 {
    //Exact values (desired width − 0.83% = result %) are commented, but they need tweaked to have one value for all IEs
    section {
        .row-1 .level-1 { width: 49.17%; }
        //Exact value is 32.17%
        .row-2 .level-1 { width: 32.20%; }
        //Exact value is 24.17%
        .row-3 .level-1 { width: 23.75%; }
        .row-4 {
          .content-a { width: 19.17%; }
          .content-b { width: 49.17%; }
          //Exact value is 29.17%
          .content-c { width: 28.3%; }
        }
    }
}
//IE8/9
.ie8, .ie9 {
    .flex-container { overflow: hidden; }
    nav, section { float: left; min-height: 440px; }
    nav { width: 29%; margin-right: 1%; }
    section { width: 70%; }
    footer { clear: both; zoom: 1; }
}
<strong>//IE8</strong>
<strong>.ie8 {</strong>
<strong>    [class*="level-"] {</strong>
<strong>        display: inline-block;</strong>
<strong>        margin: 0 .2%;</strong>
<strong>    }</strong>
<strong>}</strong>
<strong>//IE9</strong>
<strong>.ie9 {</strong>
<strong>    [class*="level-"] { float: left; }</strong>
<strong>}</strong>
</pre>





<h1 class="title" id="sigil_toc_id_203"><a id="ch04lvl1sec33"/>总结</h1>



<p>这一章有很多东西要消化，嗯？</p>
<p>然而，我们现在知道网格是什么，它的用途是什么，这是我们许多人以前从未真正质疑过的。我们还了解更多关于CSS网格、CSS框架和UI工具包的信息；只要您清楚它们如何帮助我们在构建响应声音的网站和应用程序时提高效率，就可以随心所欲地使用它们。</p>
<p>使用传统的<em>浮动</em>技术创建我们的定制CSS是一个识别模式的问题，其中添加一个新列就是将值增加100。现在，我们可以创建任意宽度的12列网格。</p>
<p>在Flexbox的帮助下，我们现在了解了响应性和流动性布局的未来。有了如此强大的浏览器支持，Flexbox无疑是传统CSS网格的主要竞争者。使用条件类是在传统浏览器中支持复杂布局的一个好选择。此外，对于IE10，我们需要使用只有IE10能够看到的条件编译脚本。因此，我们可以针对IE10使用一个<code class="literal">.ie10</code>特定的选择器。</p>
<p>在下一章中，当我们谈论在小屏幕上为我们的大手指构建响应性界面时，我们将深入到可用性和用户体验的世界。是时候考验一下那些大手指了！</p>

</body>
</html>