<html>
<head><title>Chapter 3. Mobile-first or Desktop-first?</title>
<link rel="stylesheet" href="epub.css" type="text/css"/>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
</head>
<body id="page">
<h1 class="title"><a id="ch03"/>第三章，手机优先还是桌面优先？</h1>



<p>在我多年的设计和构建响应式网站的经验中，我发现为了更好地查看内容和消息，在线框和设计阶段，使用桌面优先的方法更容易实现可视化。</p>
<p>由于我们能够通过桌面优先的方法在给定的布局中看到更多的内容，因此它允许我们将提供给我们的内容的层次结构转换为表示所述层次结构的布局。在320像素宽的小画布上执行此操作比需要的难度更大。</p>
<p>当您完成该层次结构时，它在小屏幕设备上将保持不变，唯一改变的是布局。</p>
<p><em>最佳实践</em>建议首先构建移动设备，但许多网络专业人士并不知道我们为什么首先构建<em>移动设备</em>。双关语。</p>
<p>所以，让我们把它弄清楚。我们之所以首先构建移动设备，是因为卢克·沃布列夫斯基（Luke Wroblewski）提到了三个原则。卢克·沃布列夫斯基在2009年创造了术语<em>移动设备优先</em>。您会注意到，这些原则都与HTML、CSS和/或JavaScript无关。换句话说，由于HTML、CSS或<a id="id167" class="indexterm"/>JavaScript的任何优势，您不会首先构建mobile。欲了解更多信息，请访问<a class="ulink" href="http://www.lukew.com/ff/entry.asp?933">http://www.lukew.com/ff/entry.asp?933 </a>。</p>
<p>考虑以下几点：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>手机正在爆炸</strong>：手机已经爆炸了。这基本上意味着<a id="id168" class="indexterm"/>人们使用移动设备访问网络更容易、更快、更方便。因此，如果您首先构建与移动设备兼容的网站，那么与仅使用桌面网站/应用程序相比，您有更好的机会提供更好的用户体验并被更多人浏览。</li>
<li class="listitem" style="list-style-type: disc"><strong>移动迫使你专注于</strong>：由于移动设备的<a id="id169" class="indexterm"/>屏幕上的空间比桌面屏幕上的空间小得多，因此必须优先考虑。这意味着最重要的任务和/或消息需要立即可见。</li>
<li class="listitem" style="list-style-type: disc"><strong>移动扩展您的功能</strong>：移动设备具有桌面<a id="id170" class="indexterm"/>设备所不具备的功能：GPS、加速度计、多点触摸输入、语音识别、前后摄像头等。首先使用移动设备时，您可以使用这些先进的技术来创造更丰富、更激动人心的体验。</li>
</ul>

<p>现在您已经有了最终的设计，现在需要将该设计实现为HTML、CSS和JavaScript。在这个阶段，您应该使用移动优先的方法，并考虑我们前面提到的三个原因：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">打造手机拳头意味着你的网站/应用程序可以被更多人看到</li>
<li class="listitem" style="list-style-type: disc">它让你对内容进行优先排序</li>
<li class="listitem" style="list-style-type: disc">如果需要，它将允许您使用移动设备的高级功能</li>
</ul>

<p>在本章中，我们将介绍以下主题：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">在桌面第一视图中创建您的设计，但首先使用移动设备实现它们。</li>
<li class="listitem" style="list-style-type: disc">Sass混合用于移动优先和桌面优先媒体查询。</li>
<li class="listitem" style="list-style-type: disc">处理遗留浏览器。</li>
<li class="listitem" style="list-style-type: disc">如何处理高密度屏幕。</li>
<li class="listitem" style="list-style-type: disc">为什么RWD有时不一定是正确的解决方案。</li>
<li class="listitem" style="list-style-type: disc">用RWD改造旧网站。</li>
</ul>

<h1 class="title" id="sigil_toc_id_119"><a id="ch03lvl1sec16"/>在桌面第一视图中创建您的设计，但首先使用移动设备实现它们</h1>



<p>让我们看看<a id="id171" class="indexterm"/>一些术语，这样我们就在同一页上了：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>线框</strong>：这是一个非常基本的布局视觉表示，仅使用轮廓，换句话说，是黑色<a id="id173" class="indexterm"/>和白色。没有颜色，没有品牌，也没有任何类型的定义样式。</li>
<li class="listitem" style="list-style-type: disc"><strong>设计/组合</strong>：这是一个<em>充实的</em>线框，有颜色、品牌和风格。它是最终页面/站点/应用程序的一个非常接近的表示（通常，比如说，95%接近最终产品），而不涉及任何类型的标记或编码。</li>
<li class="listitem" style="list-style-type: disc"><strong>HTML模型或HTML模板</strong>：这是指将设计<a id="id175" class="indexterm"/>实现为一个实际的HTML页面，其中包含CSS<a id="id176" class="indexterm"/>和JavaScript。它只能在浏览器中查看。它实际上是页面/站点/web应用程序外观和工作方式的精确表示（99%接近最终产品）。</li>
</ul>

<p><a id="id177" class="indexterm"/>术语清楚后，让我们继续。</p>
<p>一些<a id="id178" class="indexterm"/>专业人士，包括我在内，建议使用更现代、更高效的技术来创建视觉资产，以优化线框和创建设计/组合过程中花费的时间。风格瓷砖、情绪板、元素拼贴和原子设计等技术与传统的线框和设计/合成方法不同。他们提供了探索版面和风格的机会，与屏幕宽度、技术甚至内容创建无关。</p>
<p>在本书中，我们将重点介绍如何利用传统的线框和设计/comps方法，同时最大限度地利用我们在掌握HTML5和CSS3的<strong>响应性网页设计</strong>（<strong>RWD</strong>）的初始阶段的时间。</p>
<h2 class="title" id="sigil_toc_id_120"><a id="ch03lvl2sec28"/>为什么要在桌面第一视图中创建设计？</h2>



<p>在桌面第一视图中创建设计的原因很简单：房地产（空间）。</p>
<p>作为<a id="id180" class="indexterm"/>设计师，我们需要以视觉方式反映内容的层次结构。为了实现这一点，我们使用了许多设计原则，如节奏、接近、空白、模式、对比、平衡、网格、对称等。</p>
<p>当我们正在创建线框或设计/合成的画布足够大，可以尝试不同的安排和布局时，我们有必要的灵活性来探索可以表示所述内容层次结构的不同方式。</p>
<p>例如，我们使用的是一个12列的网格，提供给我们的内容决定了以下内容层次结构：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">企业希望用户能够提供他们的电子邮件ID来接收我们的新闻稿。</li>
<li class="listitem" style="list-style-type: disc">我们想展示一篇由编辑部选择的<em>专题文章</em>。</li>
</ul>

<p>使用前面的内容层次结构，我们可以立即开始绘制不同的布局，以传达此层次结构：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">为了让用户提供他们的电子邮件地址，我们将创建一个带有标题、段落、输入类型电子邮件和按钮的表单。此表单将位于页眉下方的左上角，宽度可以为三到四列。我认为也许四栏太宽了，但让我们线框一下，看看感觉如何，以及这会带来什么可用性、可访问性和易读性问题或好处。</li>
<li class="listitem" style="list-style-type: disc">对于<em>专题文章</em>，我们将使用剩余的专栏。如果电子邮件表单有三列宽，我们将使用剩下的九列；如果电子邮件表单是四列宽的，我们将只使用剩余的八列。特色文章有更多的内容，如标题、作者、日期、类别、片段、缩略图和完整文章的链接。</li>
</ul>

<p>在我们的设计/线框<a id="id182" class="indexterm"/>应用程序中有<a id="id181" class="indexterm"/>宽画布，我们可以使用这些不同的方法，最终以一个合理的布局结束，并根据业务或利益相关者的要求表示内容层次结构。</p>
<p>用一个小画布，用移动优先的方法创建这样的布局几乎是不可能的。小型房地产屏幕的限制和限制令人难以置信。但是，当事情开始发展时，每次想到一个特定的断点时，我们都需要进行这个探索过程。</p>
<h3 class="title" id="sigil_toc_id_121"><a id="tip28"/>提示</h3>
<p>实际上，我们现在不应该考虑断点（没有双关语），因为内容而不是特定的设备宽度决定了需要添加新断点的位置。</p>


<p>一旦我们定义了一个反映内容层次结构的布局，我们将处于一个良好的位置，因为当内容在较小的屏幕上重新排列时，无论哪个宽度，层次结构都将保持不变。</p>

<h2 class="title" id="sigil_toc_id_122"><a id="ch03lvl2sec29"/>为什么先用手机实施？</h2>



<p>让我们先澄清一个术语：<em>实现</em>意味着<a id="id184" class="indexterm"/>基于线框或设计/合成，使用CSS和JavaScript（如有必要）创建HTML模型。</p>
<p>本章开头提到的原因是对问题<em>的回答，为什么首先使用移动设备？</em>记住：移动设备正在爆炸（其实已经爆炸了），移动设备迫使你集中精力，移动设备扩展了你的能力。</p>
<p>除了第二个前提（这可能是一个巨大的<em>可能</em>）之外，所有这些原因都不能通过桌面优先实现来实现。</p>
<p>让我们改变<a id="id185" class="indexterm"/>档位，进入一个更具技术性的主题<a id="id186" class="indexterm"/>，这将帮助我们了解Sass mixins如何帮助我们掌握移动优先和桌面优先方法的RWD。</p>
<p>那么，让我们回顾一下。首先使用桌面创建设计和线框。拥有一个大画布可以让我们探索不同的布局，并正确安排内容的层次结构。当需要实现（创建HTML模型）时，首先使用mobile。</p>



<h1 class="title" id="sigil_toc_id_123"><a id="ch03lvl1sec17"/>移动优先和桌面优先媒体查询的Sass混合</h1>



<p>对于我们的<a id="id187" class="indexterm"/>示例，我们将在本书中使用两种类型的Sass<a id="id188" class="indexterm"/>mixin：使用<code class="literal">min-width</code>属性的mobile first mixin和使用<code class="literal">max-width</code>属性的desktop first mixin。我们已经在<a class="link" href="1.html" title="Chapter 1. Harness the Power of Sass for Responsive Web Design">第1章</a><em>中看到了以下混搭以及它们是如何工作的<em>利用Sass的力量进行响应性网页设计</em>，但这里有一个复习。</em></p>
<h2 class="title" id="sigil_toc_id_124"><a id="ch03lvl2sec30"/>手机首次混音</h2>



<p>我们将<a id="id189" class="indexterm"/>使用以下移动首次混音：</p>
<pre class="programlisting">@mixin forLargeScreens($media) {
    @media (min-width: $media/16+em) { @content; }
}</pre>

<p>我们就是这样使用它的：</p>
<pre class="programlisting">header {
   //Properties for small screens
    width: 50%;
    background: red;
    @include forLargeScreens(640) {
      //Properties for large screens
        width: 100%;
        background: blue;
    }
}</pre>

<p>这将编译为以下内容：</p>
<pre class="programlisting">header {
    width: 50%;
    background: red;
}

@media (min-width: 40em) {
    header {
        width: 100%;
        background: blue;
    }
}</pre>


<h2 class="title" id="sigil_toc_id_125"><a id="ch03lvl2sec31"/>桌面第一次混入</h2>



<p>这是我们将要使用的<a id="id190" class="indexterm"/>桌面第一个混音器：</p>
<pre class="programlisting">@mixin forSmallScreens($media) {
    @media (max-width: $media/16+em) { @content; }
}</pre>

<p>我们就是这样使用它的：</p>
<pre class="programlisting">header {
    //Properties for large screens
    width: 100%;
    background: purple;
    @include forSmallScreens(640) {
      //Properties for small screens
        width: 50%;
        background: yellow;
    }
}
<strong>@include forSmallScreens</strong>
</pre>

<p>这将编译为以下内容：</p>
<pre class="programlisting">header {
    width: 100%;
    background: purple;
}

@media (max-width: 40em) {
    header {
        width: 50%;
        background: yellow;
    }
}</pre>

<h3 class="title" id="sigil_toc_id_126"><a id="tip29"/>提示</h3>
<p>使用这些mixin的好处在于，很容易找到使用的方法，因为我们可以看到术语<code class="literal">forLargeScreens</code>或<code class="literal">forSmallScreens</code>在我们的SCSS文件中重复出现。如果其他人编辑了我们最初做的任何工作，他们只需扫描SCSS文件，就可以清楚地了解<a id="id191" class="indexterm"/>我们构建网站/应用程序的方法。</p>




<h1 class="title" id="sigil_toc_id_127"><a id="ch03lvl1sec18"/>处理遗留浏览器</h1>



<p>在<a id="id192" class="indexterm"/>问题“移动优先还是桌面优先”中，有一个领域我们需要涉及传统浏览器。每个项目、每个客户机及其相应的分析（如果他们有，他们应该有）都有不同的需求，这些需求会影响我们应该如何处理这些旧浏览器。</p>
<p>如果您使用桌面优先的方法进行构建，那么您当前的工作流程应该保持不变，因为这与RWD成为实际强制要求之前我们所做的工作基本相同。</p>
<p>这意味着您仍将使用以下内容：</p>
<pre class="programlisting">header {
    //Desktop-first declaration
    width: 50%;
    @include forSmallScreens(768) {
      //Target small screens (mobile devices)
      width: 100%; }
}</pre>

<p>这将编译为以下内容：</p>
<pre class="programlisting">header {
    width: 50%;
}

@media (max-width: 48em) {
    header {
      width: 100%;
    }
}</pre>

<p>IE7和IE8不支持媒体查询，但前面的代码可以正常工作，因为<code class="literal">header { width: 50%; }</code>规则不在媒体查询中。</p>
<p>但是，如果您首先使用移动设备，那么<code class="literal">header { width: 50%; }</code>将位于媒体查询中，这样IE7和IE8将无法看到该规则：</p>
<pre class="programlisting">.article {
    //Mobile-first declaration
    width: 100%;
    //IE7 and IE8 won't be able to see this rule.
    @include forLargeScreens(768) {
      width: 50%;
    }
}</pre>

<p>这将编译为以下内容：</p>
<pre class="programlisting">header {
    width: 100%;
}

@media (min-width: 48em) { 
    header {
      width: 50%;
    }
}</pre>

<p>那你怎么办？解决方法很简单：使用<code class="literal">Respond.js</code>脚本。</p>
<h2 class="title" id="sigil_toc_id_128"><a id="ch03lvl2sec32"/>RWD如何使用Respond.js</h2>



<p><code class="literal">Respond.js</code>是<a id="id194" class="indexterm"/>一种称为<em>polyfill</em>的脚本。根据<a id="id195" class="indexterm"/>一词的创造者雷米·夏普（Remy Sharp）的说法，polyfill是一段代码，它提供了我们网络开发人员期望浏览器本机提供的技术。</p>
<p>在web设计和开发中，PolyFill作为JavaScript实现更为丰富，在我们的例子中，Scott Jehl的<code class="literal">Respond.js</code>。但我们也可以说CSS中也存在多填充，例如，Eric Meyer的著名<code class="literal">reset.css</code>和Nicolas Gallagher和Jonathan Neal的<code class="literal">Normalize.css</code>。</p>
<p><code class="literal">Respond.js</code>脚本是一个polyfill，它使传统浏览器（IE6/7/8）支持一个他们<a id="id196" class="indexterm"/>从未支持过的特定CSS功能：媒体查询。</p>
<p>您可以从<a class="ulink" href="https://github.com/scottjehl/Respond">下载<code class="literal">Respond.js</code>https://github.com/scottjehl/Respond </a>。</p>
<h3 class="title" id="sigil_toc_id_129"><a id="tip30"/>提示</h3>
<p>虽然我建议使用polyfill，但我们需要注意站点/应用程序需要发出额外的HTTP请求才能获取此JavaScript文件。我们的网站/应用程序发出的请求越少，它们就越快创造出许多好处，如改善用户体验和积极的SEO影响。</p>


<p>因此，以下是您需要做的：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">确保对<code class="literal">Respond.js</code>的调用是在对CSS文件的调用之后的<em>（希望它只是一个CSS文件）。</em></li>
<li class="listitem" style="list-style-type: disc">调用<code class="literal">Respond.js</code>脚本。</li>
</ul>

<h3 class="title" id="sigil_toc_id_130"><a id="tip31"/>提示</h3>
<p>性能最佳实践建议将不重要的脚本放在标记底部，正好在结束<code class="literal">&lt;/body&gt;</code>标记之前。既然<code class="literal">Respond.js</code>针对的是传统浏览器，那么让我们继续这样做吧。将脚本放在标记底部的另一个好处是，它有助于避免阻塞页面的呈现。</p>


<p>下面是我们的<a id="id197" class="indexterm"/>示例HTML：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Mastering RWD with HTML5 &amp;amp; CSS3&lt;/title&gt;
    &lt;link href="styles.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;Logo goes here…&lt;/header&gt;
    &lt;article&gt;Content goes here…&lt;/article&gt;
    &lt;script src="js/respond.min.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<p>在我们的<code class="literal">styles.scss</code>文件中，我们键入以下行：</p>
<pre class="programlisting">//Mobile-first declaration
article { background: red;
    //Target screens 640px wide and larger
    @include forLargeScreens(640) {
        &amp; { background: green; }
  }
}</pre>

<p>这将编译为以下内容：</p>
<pre class="programlisting">article {
    background: red;
}

@media (min-width: 40em) {
    article {
         background: green; 
    }
}</pre>

<p>因此，当您调整IE7或IE8浏览器窗口的大小时，如果窗口宽度小于等于640像素，它将能够显示红色背景，如果窗口宽度大于等于641像素，它将能够显示绿色背景。</p>

<h2 class="title" id="sigil_toc_id_131"><a id="ch03lvl2sec33"/>IE特定样式表的时代已经过去</h2>



<p>自从我开始写CSS以来，我一直避免创建特定于IE的样式表。原因很简单：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>档案管理</strong>：投入生产时需要管理的档案越少，<a id="id199" class="indexterm"/>每道工序越顺畅；更不用说不容易出错了。</li>
<li class="listitem" style="list-style-type: disc"><strong>可伸缩性</strong>：如果您需要添加、删除或编辑样式，您和您的团队知道<a id="id200" class="indexterm"/>最终的更改需要在您的主CSS文件中完成，在我们的例子中是SCSS文件。</li>
<li class="listitem" style="list-style-type: disc"><strong>组织机构</strong>：在正确的CSS文件（在本例中为SCSS文件）中添加、删除或编辑IE特定样式时，将<a id="id201" class="indexterm"/>所有人保持在同一页面上。</li>
<li class="listitem" style="list-style-type: disc"><strong>性能</strong>：减少一个<a id="id202" class="indexterm"/>HTTP请求是一件好事，一件非常好的事。我们可以为性能做的任何事情，无论多小，都可以为获得良好的用户体验做出很大的贡献；更不用说一个快速的网站对搜索引擎优化有好处。</li>
</ul>

<h3 class="title" id="sigil_toc_id_132"><a id="ch03lvl3sec25"/>不使用IE特定样式表的其他好处</h3>



<p>在传统的<a id="id203" class="indexterm"/>浏览器中，当他们试图下载特定于IE的样式表时，页面呈现不会被阻止。此外，故障排除也更容易。那么我们用什么呢？</p>
<p>通过将所有内容保存在一个样式表中，有几种处理IE的方法：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">使用CSS黑客（不推荐）。</li>
<li class="listitem" style="list-style-type: disc">使用<code class="literal">Modernizr.js</code>。</li>
<li class="listitem" style="list-style-type: disc">在<code class="literal">&lt;html&gt;</code>标记中使用条件类。</li>
</ul>

<p>让我们进一步讨论一种流行的方法，使用条件类。</p>
<h4 class="title" id="sigil_toc_id_133"><a id="ch03lvl4sec17"/>在&lt;html&gt;标记中使用条件类</h4>



<p>保罗·爱尔兰2008年的文章（<a class="ulink" href="http://www.paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/">http://www.paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ </a>指定了我推荐的方法，原因有<a id="id204" class="indexterm"/>几个：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a id="id205" class="indexterm"/>易于实现；只需在HTML文件的顶部复制和粘贴此标记块。</li>
<li class="listitem" style="list-style-type: disc">它不是侵入性的，因为链中的任何人（用户、浏览器、服务器和我们）都不需要处理额外的文件。</li>
<li class="listitem" style="list-style-type: disc">它不需要JavaScript来工作；如果访问者的JavaScript不可用或已禁用，则一切仍将正常工作。</li>
</ul>

<p>这是我使用的一个：</p>
<pre class="programlisting">&lt;!--[if IE 8]&gt; &lt;html class="no-js ie8" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if IE 9]&gt; &lt;html class="no-js ie9" lang="en"&gt; &lt;![endif]--&gt;
&lt;!--[if gt IE 9]&gt;&lt;!--&gt;&lt;html class="no-js" lang="en"&gt;&lt;!--&lt;![endif]--&gt;</pre>

<h3 class="title" id="sigil_toc_id_134"><a id="tip32"/>提示</h3>
<p>IE10及以上版本不再支持<em>条件注释</em>，这就是为什么在条件类标记中没有提到IE10的原因。</p>


<p>有了<a id="id206" class="indexterm"/>前面的条件类，针对特定IE（本例中为IE7）的目标如下：</p>
<pre class="programlisting">.ie7 nav li {
    float: left;
}</pre>

<p>如果我们需要针对所有IEs，我们会这样做：</p>
<pre class="programlisting">.ie7, .ie8, .ie9 {
    nav li {
        float: left;
    }
}</pre>

<p>这将编译为以下内容：</p>
<pre class="programlisting">.ie7 nav li, .ie8 nav li, .ie9 nav li {
    float: left;
}</pre>

<p>对于所有其他浏览器，我们将执行以下操作：</p>
<pre class="programlisting">nav {
    display: flex;
}</pre>

<p>无论您使用哪种方法，<code class="literal">Modernizr.js</code>还是条件类，这都是个人偏好。通过使用这两种方法中的任何一种，您将做<em>正确的事情</em>。</p>
<p>记住，要不惜一切代价避免CSS攻击。作为网页设计师和网页开发者，我们有道德责任为每个人创造一个更好的网页。</p>




<h1 class="title" id="sigil_toc_id_135"><a id="ch03lvl1sec19"/>如何处理高密度屏幕</h1>



<p><a id="id207" class="indexterm"/>网上有很多文章解释了<a id="id208" class="indexterm"/>每英寸<strong>点</strong>（<strong>DPI</strong>）、<strong>每英寸像素</strong>（<strong>PPI</strong>）和<strong>密度无关像素</strong>（<strong>DP/DiP</strong>是什么。尽管理解<a id="id209" class="indexterm"/>这些技术和术语的复杂细节可能很重要，但让我们<a id="id210" class="indexterm"/>将本书的范围保持在高密度屏幕的基础是什么以及我们需要了解什么来创建声音响应<a id="id211" class="indexterm"/>设计。</p>
<h2 class="title" id="sigil_toc_id_136"><a id="ch03lvl2sec34"/>高密度屏幕的位图或矢量？</h2>



<p>SVG、图标字体或常规字体等向量是数学方程的可视化表示，因此它们无论大小都不会失去质量。</p>
<p>为了使位图图像能够在高密度<a id="id213" class="indexterm"/>屏幕上很好地显示，我们必须导出一个高分辨率版本的<em>正常质量</em>图像。这意味着我们需要为我们计划使用的每个位图图像创建两个（或更多）文件：一个用于非高密度屏幕（标准LCD显示器、旧TFT显示器、一些电视等）的正常质量图像，以及一个（或更多）用于高密度屏幕（任何<em>视网膜</em>的高质量图像例如，设备和超级AMOLED显示器）。</p>
<p>这就是好的设计判断发挥作用的地方，因为有时我们不一定每次都需要导出两个（或更多）位图图像。</p>
<p>当我们必须考虑高密度屏幕时，有几种技术可以用来处理图像。这些技术在<a class="link" href="6.html" title="Chapter 6. Working with Images and Videos in Responsive Web Design">第6章</a><em>中有详细说明，在响应式网页设计</em>中处理图像和视频。</p>


<h1 class="title" id="sigil_toc_id_137"><a id="ch03lvl1sec20"/>有时RWD不一定是正确的解决方案</h1>



<p>以<a id="id214" class="indexterm"/>为例，大多数旅游网站的预订部分。像这样的网站所管理的信息数量和类型之多，使得它很难拥有一个响应迅速的网站。当访问谷歌搜索结果<a id="id215" class="indexterm"/>中排名最高的八个旅游网站时，我看到的是：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.kayak.com/">http://www.kayak.com/ </a><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>首页</strong>：响应</li>
<li class="listitem" style="list-style-type: disc"><strong>预订页面</strong>：无响应</li>
</ul>
</li>
<li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.expedia.com/">http://www.expedia.com/ </a><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>首页</strong>：响应</li>
<li class="listitem" style="list-style-type: disc"><strong>预订页面</strong>响应</li>
</ul>
</li>
<li class="listitem" style="list-style-type: disc">T0https://www.hotwire.com/ T1<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>首页</strong>：无<a id="id216" class="indexterm"/>响应</li>
<li class="listitem" style="list-style-type: disc"><strong>预订页面</strong>响应</li>
</ul>
</li>
<li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.travelocity.com/">http://www.travelocity.com/ </a><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>首页</strong>：响应</li>
<li class="listitem" style="list-style-type: disc"><strong>预订页面</strong>响应</li>
</ul>
</li>
<li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.orbitz.com/">http://www.orbitz.com/ </a><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>首页</strong>：无响应</li>
<li class="listitem" style="list-style-type: disc"><strong>预订页面</strong>：无响应</li>
</ul>
</li>
<li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.priceline.com/">http://www.priceline.com/ </a><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>首页</strong>：无响应</li>
<li class="listitem" style="list-style-type: disc"><strong>预订页面</strong>：无响应</li>
</ul>
</li>
<li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.tripadvisor.in/">http://www.tripadvisor.in/ </a><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>首页</strong>：无响应</li>
<li class="listitem" style="list-style-type: disc"><strong>预订页面</strong>：无响应</li>
</ul>
</li>
<li class="listitem" style="list-style-type: disc">T0https://www.hipmunk.com/ T1<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>首页</strong>：无响应</li>
<li class="listitem" style="list-style-type: disc"><strong>预订页面</strong>：无响应</li>
</ul>
</li>
</ul>

<p>以下是我们调查结果的简要列表：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">自从Expedia收购Travelocity以来，它们共享同一平台。区别在于品牌；因此，我将考虑这两个站点作为一个。</li>
<li class="listitem" style="list-style-type: disc">七分之五的网站（71%）的主页没有响应。</li>
<li class="listitem" style="list-style-type: disc">七分之五的网站（71%）的预订页面没有响应。</li>
<li class="listitem" style="list-style-type: disc">七个站点中只有一个（Expedia/Travelocity）（14%）完全响应。</li>
<li class="listitem" style="list-style-type: disc">七分之四的站点（57%）没有任何RWD。</li>
</ul>

<p>我们可以得出结论，最受欢迎的旅游网站尚未完全采用RWD，但有些是固定宽度和响应性布局的混合。这就是为什么所有这些网站都有独立的移动应用程序。对他们来说，RWD可能不是一个优先事项，所以他们依靠自己的移动应用来平衡这一不足。</p>
<p>虽然现在很少见，但有时我们可能需要建立一个没有响应的站点或页面。事实上，今天有一些页面没有响应。</p>
<p>CodePen是<a id="id218" class="indexterm"/>最流行的前端沙盒之一，CodePen的编辑器没有响应能力。为什么？因为不需要这样。开发人员不太可能使用他们的手机去CodePen编写HTML、Sass和JavaScript。</p>
<p>话虽如此，如果您需要构建一个不需要响应的站点/页面，就CSS网格系统而言，有两个很好的选择：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">使用我们的<a id="id219" class="indexterm"/>老朋友，960网格系统（<a class="ulink" href="http://960.gs/">http://960.gs/ </a>。</li>
<li class="listitem" style="list-style-type: disc">使用<a id="id220" class="indexterm"/>1140网格系统（<a class="ulink" href="http://www.1140px.com/">http://www.1140px.com/ </a>。</li>
</ul>

<p>有几件事需要考虑：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">960网格系统针对1024px宽的屏幕。</li>
<li class="listitem" style="list-style-type: disc">1140网格系统针对1280px宽的屏幕。</li>
<li class="listitem" style="list-style-type: disc">默认情况下，1140网格系统包含媒体查询，因此我们需要考虑这一点，并决定是最好保留它们，还是最好删除它们，以减少IE6-IE9中的文件大小和选择器限制。</li>
</ul>

<p>因为我一直认为960网格系统左侧和右侧的10px填充使内容过于靠近主容器的边缘，所以我在每侧增加了10个像素，将填充增加到20px，从而将960网格系统变成了980网格系统。从现在起，我们称之为980GS。</p>

<h1 class="title" id="sigil_toc_id_138"><a id="ch03lvl1sec21"/>用RWD改造旧网站</h1>



<p>如果和<a id="id222" class="indexterm"/>当时机到来时，我们需要做好准备，使一个无响应或固定宽度的站点/应用程序响应。</p>
<p>有两种方法可以改造无响应或固定宽度的站点/应用程序。一种方法是使用使用绝对单位（即像素）的<strong>自适应网页设计</strong>（<strong>AWD</strong>技术）。<a id="id223" class="indexterm"/>另一种方法是使用RWD，用一个非常简单的公式将所有像素值转换为百分比。</p>
<p>无论我们使用哪种技术，我们都将不得不使用桌面优先的方法，因为我们正在处理的站点只为宽屏幕构建。这意味着我们将在媒体查询中使用<code class="literal">max-width</code>属性。</p>
<p>在我们研究这两种改造技术之前，我们需要一个基本页面。</p>
<h2 class="title" id="sigil_toc_id_139"><a id="ch03lvl2sec35"/>基准页</h2>



<p>您在这里看到的<a id="id224" class="indexterm"/>图形与12列980GS布局成比例。浏览器窗口为1024像素宽，页面为980像素宽：</p>
<p><img src="graphics/B02102_03_01.jpg" alt="The base page"/></p>
<h3 class="title" id="sigil_toc_id_140"><a id="tip33"/>提示</h3>
<p>我们主要的<a id="id225" class="indexterm"/>灰色容器，宽980px，左右两侧已经有10px的填充物。这意味着内部的部分<a id="id226" class="indexterm"/>总是需要加起来达到<strong>960px</strong>。</p>


<p>以下是容器的组件：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">灰色的主容器宽980px，左右两侧各有10px的填充物。</li>
<li class="listitem" style="list-style-type: disc">绿色的<strong>页眉</strong>和红色的<strong>页脚</strong>各为960px或12列宽：940px，左右两侧各有10px的边距。</li>
<li class="listitem" style="list-style-type: disc">蓝色的<strong>导航</strong>部分为240px或3列宽：220px，左边距和右边距分别为10px。</li>
<li class="listitem" style="list-style-type: disc">黄色的<strong>内容</strong>部分为710px或9列宽：700px，右边缘为10px。</li>
<li class="listitem" style="list-style-type: disc">白色天沟的宽度为20px，即<strong>导航</strong>的右边缘为10px，而<strong>内容</strong>的左边缘为10px。</li>
<li class="listitem" style="list-style-type: disc">所以，220px name+710px Content+20px boys+10px margins=960px。</li>
</ul>


<h2 class="title" id="sigil_toc_id_141"><a id="ch03lvl2sec36"/>HTML</h2>



<p>以下是表示我们的主页的<a id="id228" class="indexterm"/>标记：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Retrofitting with Adaptive Web Design&lt;/title&gt;
    &lt;link href="css/styles.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;main class="container_12 clear"&gt;
      &lt;header class="grid_12"&gt;Header&lt;/header&gt;
      &lt;nav class="grid_3"&gt;Nav&lt;/nav&gt;
      &lt;section class="grid_9"&gt;Content&lt;/section&gt;
      &lt;footer class="grid_12"&gt;Footer&lt;/footer&gt;
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>


<h2 class="title" id="sigil_toc_id_142">'T0'：CSS/SCSS</h2>



<p>关于<a id="id229" class="indexterm"/>我们的CSS/SCS，我们只需要创建一个部分，即包含固定宽度网格的<code class="literal">_980gs.scss</code>文件。</p>
<p>然后，我们将创建一个<code class="literal">styles.scss</code>文件，我们将使用该文件执行以下操作：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">导入<code class="literal">_980gs.scss</code>文件。</li>
<li class="listitem" style="list-style-type: disc">包括我们的简单桌面第一Sass混合来处理媒体查询。</li>
<li class="listitem" style="list-style-type: disc">使用<code class="literal">max-width</code>属性创建所有必要的媒体查询。</li>
<li class="listitem" style="list-style-type: disc">编译成<code class="literal">styles.css</code>并在我们的页面中使用。</li>
</ul>

<h3 class="title" id="sigil_toc_id_143"><a id="ch03lvl3sec26"/>创建_980gs.scss文件</h3>



<p><code class="literal">_980gs.scss</code>文件包含<a id="id230" class="indexterm"/>基本网格，如下所示：</p>
<pre class="programlisting">//Globals
*, *:before, *:after {
    box-sizing: border-box;
}

//Container
.container_12 {
    width: 980px;
    padding: 0 10px;
    margin: auto; 
}

//Grid &gt;&gt; Global
.grid {
    &amp;_1, &amp;_2, &amp;_3, &amp;_4, &amp;_5, &amp;_6, &amp;_7, &amp;_8, &amp;_9, &amp;_10, &amp;_11, &amp;_12 {
      float: left;
      margin: 0 10px;
    }
}

//Grid &gt;&gt; 12 Columns
.container_12 {
    .grid_1  { width: 60px; }
    .grid_2  { width: 140px; }
    .grid_3  { width: 220px; }
    .grid_4  { width: 300px; }
    .grid_5  { width: 380px; }
    .grid_6  { width: 460px; }
    .grid_7  { width: 540px; }
    .grid_8  { width: 620px; }
    .grid_9  { width: 700px; }
    .grid_10 { width: 780px; }
    .grid_11 { width: 860px; }
    .grid_12 { width: 940px; }
}

//Clear Floated Elements - http://davidwalsh.name/css-clear-fix
.clear, .row {
    &amp;:before,
    &amp;:after { content: ''; display: table; }
    &amp;:after { clear: both; }
}

//Use rows to nest containers
.row { margin-bottom: 10px;
    &amp;:last-of-type { margin-bottom: 0; }
}
//Legacy IE
.clear { zoom: 1; }</pre>




<h1 class="title" id="sigil_toc_id_144"><a id="ch03lvl1sec22"/>AWD改装</h1>



<p>与<a id="id231" class="indexterm"/>RWD不同，RWD的宽度是流体和弹性的（ems和百分比），因此术语<em>相对单位</em>，在AWD中，宽度是固定的（像素）。因此，我们使用术语<em>绝对单位</em>，当我们调整浏览器窗口大小时，元素将<em>捕捉</em>到这些固定宽度。</p>
<p>在AWD中，几乎每个宽度都使用像素，甚至我们的媒体查询。</p>
<h2 class="title" id="sigil_toc_id_145"><a id="ch03lvl2sec38"/>创建styles.scss文件</h2>



<p>在<code class="literal">styles.scss</code>文件中，我们要做的第一件事是导入部分<code class="literal">_980gs.scss</code>文件：</p>
<pre class="programlisting">//Retrofitting with Adaptive Web Design
<strong>@import "980gs";</strong>
</pre>

<p>然后，我们将首先包含简单的桌面mixin来处理媒体查询。但是，还记得我之前提到的mixin是如何可伸缩的，如果我们愿意，我们可以让它编译基于像素的值？我们需要做的就是从分区<code class="literal">$media/16+em</code>中删除值<code class="literal">/16+em</code>：</p>
<pre class="programlisting">//Retrofitting with Adaptive Web Design
@import "980gs";

<strong>//Desktop-first Media Query Mixin</strong>
<strong>@mixin forSmallScreens($media) {</strong>
<strong>    @media (max-width: $media) { @content; }</strong>
<strong>}</strong>
</pre>

<p>以下规则仅用于造型目的，以实现我们在之前的屏幕截图中看到的相同设计：</p>
<pre class="programlisting">//Retrofitting with Adaptive Web Design
@import "980gs";

//Desktop-first Media Query Mixin
@mixin forSmallScreens($media) {
    @media (max-width: $media) { @content; }
}

<strong>//Basic styling</strong>
<strong>.container_12 {</strong>
<strong>    background: #aaa;</strong>
<strong>    font-size: 30px;</strong>
<strong>    text-shadow: 0 1px 1px rgba(black,.5);</strong>
<strong>}</strong>
<strong>header { background: #429032; }</strong>
<strong>nav { background: #2963BD; }</strong>
<strong>section { background: #c90; }</strong>
<strong>footer { background: #c03; }</strong>

<strong>//Give heights to elements for better perception of sections</strong>
<strong>header, footer { height: 150px; }</strong>
<strong>nav, section { height: 440px; }</strong>
</pre>

<p>此时，我们的页面宽度为980px，看起来就像我们最初看到的屏幕截图。</p>
<p>让我们定义将使我们的基页<em>捕捉</em>到的宽度：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">在980px，我们将把页面捕捉到768px。</li>
<li class="listitem" style="list-style-type: disc">在768px，我们将把页面捕捉到640px。</li>
<li class="listitem" style="list-style-type: disc">在640px，我们将把页面快照到480px。</li>
<li class="listitem" style="list-style-type: disc">在480px时，我们将把页面快照到320px。</li>
</ul>

<p>这就是乐趣的开始。让我们通过为每个部分创建媒体查询来改进此页面。</p>
<h3 class="title" id="sigil_toc_id_146"><a id="ch03lvl3sec27"/>980px至768px（全轮驱动）</h3>



<p><a id="id234" class="indexterm"/>以下媒体查询针对768px：</p>
<pre class="programlisting">.container_12 {
  <strong>@include forSmallScreens(980px) {</strong>
<strong>      width: 768px;</strong>
<strong>  }</strong>
    .grid_12 { //Header and Footer sections
      <strong>@include forSmallScreens(980px) {</strong>
<strong>        width: 728px;</strong>
<strong>    }</strong>
  }
  .grid_3 { //Nav section
    <strong>@include forSmallScreens(980px) {</strong>
<strong>      width: 200px;</strong>
<strong>    }</strong>
  }
  .grid_9 { //Content section
    <strong>@include forSmallScreens(980px) {</strong>
<strong>      width: 508px;</strong>
<strong>    }</strong>
  }
}</pre>

<p>诚然，从980px到768px，很难看出书中的差异，但相信我，下面的<a id="id235" class="indexterm"/>截图完全代表了980px宽的浏览器窗口和768px宽的页面：</p>
<p><img src="graphics/B02102_03_02.jpg" alt="980px to 768px (AWD)"/></p>
<p>正如你所看到的，当屏幕是980px时，我们的主容器（<code class="literal">.container_12</code>的宽度从980px变为768px。我们的主容器左右各有10px的填充物，所以所有其他部分的宽度加起来应该与748px相匹配。</p>
<p>让我们看一看。</p>
<p>我们使用同一类<code class="literal">.grid_12</code>的<strong>页眉</strong>和<strong>页脚</strong>现在宽728px。所以如果我们加上：<em>728px+10px左边距+10px右边距=748px</em>。</p>
<p>如果我们增加我们的<strong>导航</strong>（<code class="literal">.grid_3</code>和<strong>内容</strong>（<code class="literal">.grid_9</code>段）的宽度：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">'T0'：200px导航+508px内容=708px'T1'。</li>
<li class="listitem" style="list-style-type: disc">708px+20px男孩=728px↓T1；）</li>
<li class="listitem" style="list-style-type: disc">1.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.4.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2</li>
</ul>

<p>跟我呆在一起，我保证这会很有趣。</p>

<h3 class="title" id="sigil_toc_id_147"><a id="ch03lvl3sec28"/>768px至640px（全轮驱动）</h3>



<p><a id="id237" class="indexterm"/>以下媒体查询针对640px：</p>
<pre class="programlisting">.container_12 {
    @include forSmallScreens(980px) {
      width: 768px;
  }
    <strong>@include forSmallScreens(768px) {</strong>
<strong>      width: 640px;</strong>
<strong>    }</strong>
    .grid_12 { //Header and Footer sections
      @include forSmallScreens(980px) {
        width: 728px;
      }
      <strong>@include forSmallScreens(768px) {</strong>
<strong>        width: 600px;</strong>
<strong>      }</strong>
    }
    .grid_3 { //Nav section
      @include forSmallScreens(980px) {
        width: 200px;
      }
      <strong>@include forSmallScreens(768px) {</strong>
<strong>        width: 160px;</strong>
<strong>      }</strong>
    }
    .grid_9 { //Content section
      @include forSmallScreens(980px) {
        width: 508px;
      }
      <strong>@include forSmallScreens(768px) {</strong>
<strong>        width: 420px;</strong>
<strong>      }</strong>
    }
}</pre>

<p>好的，这个<a id="id238" class="indexterm"/>布局现在是一个单列页面。我们开始看到一些结果。美好的</p>
<p><img src="graphics/B02102_03_03.jpg" alt="768px to 640px (AWD)"/></p>
<p>同样，请记住，我们的主容器左右各有10px的填充，因此所有其他部分的宽度加起来应该与620px匹配。</p>
<p>让我们确保我们的数字相加：</p>
<p>我们使用同一类<code class="literal">.grid_12</code>的<strong>页眉</strong>和<strong>页脚</strong>现在宽600像素。所以如果我们加上：<em>600px+10px左边距+10px右边距=620px</em>。</p>
<p>如果我们<a id="id239" class="indexterm"/>添加我们的<strong>导航</strong>（<code class="literal">.grid_3</code>）和<strong>内容</strong>（<code class="literal">.grid_9</code>）部分的宽度：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">“T0”（160px导航+420px内容=580px“T1”）</li>
<li class="listitem" style="list-style-type: disc">580px+20px男孩=600px↓T1；）</li>
<li class="listitem" style="list-style-type: disc">123044T001230560px+10px导航左边距+10px内容右边距=620px{12304T1至123055；</li>
</ul>

<p>让我们把这一页做得更小！</p>

<h3 class="title" id="sigil_toc_id_148"><a id="ch03lvl3sec29"/>640px至480px（全轮驱动）</h3>



<p><a id="id240" class="indexterm"/>以下媒体查询针对480px：</p>
<pre class="programlisting">.container_12 {
    @include forSmallScreens(980px) {
      width: 768px;
    }
    @include forSmallScreens(768px) {
      width: 640px;
    }
    <strong>@include forSmallScreens(640px) {</strong>
<strong>      width: 480px;</strong>
<strong>    }</strong>
    .grid_12 { //Header and Footer sections
      @include forSmallScreens(980px) {
        width: 728px;
      }
      @include forSmallScreens(768px) {
        width: 600px;
      }
    }
    .grid_3 { //Nav section
      @include forSmallScreens(980px) {
        width: 200px;
      }
      @include forSmallScreens(768px) {
        width: 160px;
      }
    }
    .grid_9 { //Content section
      @include forSmallScreens(980px) {
        width: 508px;
      }
      @include forSmallScreens(768px) {
        width: 420px;
      }
    }
    <strong>.grid_3,</strong>
<strong>    .grid_9,</strong>
<strong>    .grid_12 {</strong>
<strong>      @include forSmallScreens(640px) {</strong>
<strong>        width: 440px;</strong>
<strong>      }</strong>
<strong>    }</strong>
}</pre>

<p>我们正在取得一些当之无愧的进步！此处，浏览器窗口为640px宽，页面为480px宽：</p>
<p><img src="graphics/B02102_03_04.jpg" alt="640px to 480px (AWD)"/></p>
<p>记住<a id="id242" class="indexterm"/>我们的主容器左右各有10px的填充物，因此所有其他部分的宽度加起来应该与460px匹配。</p>
<p>现在，我们将从2列布局更改为1列布局。这意味着所有部分现在都具有完全相同的宽度。</p>
<p>这也意味着在我们的SCSS文件中，我们可以为所有三类创建一个媒体块：</p>
<pre class="programlisting">.grid_3,
.grid_9,
.grid_12 {
    @include forSmallScreens(640px) {
      width: 440px;
    }
}</pre>

<p>现在，让我们<a id="id243" class="indexterm"/>确保我们的数字相加：</p>
<p>我们的<strong>页眉</strong>、<strong>导航</strong>、<strong>内容</strong>和<strong>页脚</strong>部分现在是440px宽，一个叠在另一个上。所以如果我们加上：<em>所有部分的440px+10px左边距+10px右边距=460px</em>。</p>
<p>我们来了，这道难题的最后一块！</p>

<h3 class="title" id="sigil_toc_id_149"><a id="ch03lvl3sec30"/>480px至320px（全轮驱动）</h3>



<p><a id="id244" class="indexterm"/>以下媒体查询针对320px：</p>
<pre class="programlisting">.container_12 {
    @include forSmallScreens(980px) {
      width: 768px;
    }
    @include forSmallScreens(768px) {
      width: 640px;
    }
    @include forSmallScreens(640px) {
      width: 480px;
    }
    <strong>@include forSmallScreens(480px) {</strong>
<strong>      width: 320px;</strong>
<strong>      padding: 0;</strong>
<strong>    }</strong>
    .grid_12 { //Header and Footer sections
      @include forSmallScreens(980px) {
        width: 728px;
      }
      @include forSmallScreens(768px) {
        width: 600px;
      }
    }
    .grid_3 { //Nav section
      @include forSmallScreens(980px) {
        width: 200px;
      }
      @include forSmallScreens(768px) {
        width: 160px;
      }
      @include forSmallScreens(640px) {     
        height: 50px; //This is only for styling
      }
    }
    .grid_9 { //Content section
      @include forSmallScreens(980px) {
        width: 508px;
      }
      @include forSmallScreens(768px) {
        width: 420px;
      }
    }
    .grid_3,.grid_9,.grid_12 {
      @include forSmallScreens(640px) {
        width: 440px;
      }
<strong>      @include forSmallScreens(480px) {</strong>
<strong>        width: 300px;</strong>
<strong>      }</strong>
    }
}</pre>

<p>好了，我们走！在此屏幕截图中，浏览器窗口为320px宽，内容也为320px宽，非常适合：</p>
<p><img src="graphics/B02102_03_05.jpg" alt="480px to 320px (AWD)"/></p>
<p>我们<a id="id246" class="indexterm"/>已经知道我们的主容器左右各有10px的填充物。在本例中，我们将删除该填充以获得这20个像素，因为我们的屏幕空间现在非常小：</p>
<pre class="programlisting">@include forSmallScreens(480px) {
    width: 320px;
    <strong>padding: 0;</strong>
}</pre>

<p>现在，左侧和右侧的10px<a id="id247" class="indexterm"/>间距将由其他部分的左侧和右侧边距创建。这意味着每个部分的宽度应为300px。</p>
<p>添加新的320px断点很容易：</p>
<pre class="programlisting">.grid_3,
.grid_9,
.grid_12 {
    @include forSmallScreens(640px) {
      width: 440px;
    }
    <strong>@include forSmallScreens(480px) {</strong>
<strong>       width: 300px;</strong>
<strong>    }</strong>
}</pre>

<p>现在，让我们确保我们的数字相加：</p>
<p>我们的<strong>页眉</strong>、<strong>导航</strong>、<strong>内容</strong>和<strong>页脚</strong>部分现在是300px宽，一个叠在另一个上。所以如果我们加上：<em>所有部分的300px+10px左边距+10px右边距=320px</em>。</p>
<p>就这样。我们现在已经改装了一个固定宽度的页面，以便使用AWD技术进行响应。</p>
<p>最终SCS如下所示：</p>
<pre class="programlisting">.container_12 {
    @include forSmallScreens(980px) {
      width: 768px;
    }
    @include forSmallScreens(768px) {
      width: 640px;
    }
    @include forSmallScreens(640px) {
      width: 480px;
    }
    <strong>@include forSmallScreens(480px) {</strong>
<strong>      width: 320px; padding: 0;</strong>
<strong>    }</strong>
    .grid_12 { //Header and Footer sections
      @include forSmallScreens(980px) {
        width: 728px;
      }
      @include forSmallScreens(768px) {
        width: 600px;
      }
    }
    .grid_3 { //Nav section
      @include forSmallScreens(980px) {
        width: 200px;
      }
      @include forSmallScreens(768px) {
        width: 160px;
      }
      @include forSmallScreens(640px) {     
        height: 50px; //This is only for styling
      }
    }
    .grid_9 { //Content section
      @include forSmallScreens(980px) {
        width: 508px;
      }
      @include forSmallScreens(768px) {
        width: 420px;
      }
    }
    .grid_3, .grid_9, .grid_12 {
      @include forSmallScreens(640px) {
        width: 440px;
      }
<strong>      @include forSmallScreens(480px) {</strong>
<strong>        width: 300px;</strong>
<strong>      }</strong>
    }
}</pre>

<p>它将<a id="id248" class="indexterm"/>编译为以下CSS：</p>
<pre class="programlisting">@media (max-width: 980px) {
    .container_12 {
      width: 768px;
    }
}
@media (max-width: 768px) {
    .container_12 {
      width: 640px;
    }
}
@media (max-width: 640px) {
    .container_12 {
      width: 480px;
    }
}
@media (max-width: 480px) {
    .container_12 {
      width: 320px;
      padding: 0;
  }
}
@media (max-width: 980px) {
    .container_12 .grid_12 {
      width: 728px;
    }
}
@media (max-width: 768px) {
    .container_12 .grid_12 {
      width: 600px;
    }
}
@media (max-width: 980px) {
    .container_12 .grid_3 {
      width: 200px;
    }
}
@media (max-width: 768px) {
    .container_12 .grid_3 {
      width: 160px;
    }
}
@media (max-width: 640px) {
    .container_12 .grid_3 {
      height: 50px;
    }
}
@media (max-width: 980px) {
    .container_12 .grid_9 {
      width: 508px;
    }
}
@media (max-width: 768px) {
    .container_12 .grid_9 {
      width: 420px;
    }
}
@media (max-width: 640px) {
    .container_12 .grid_3, .container_12 .grid_9,.container_12 .grid_12 {
      width: 440px;
    }
}
@media (max-width: 480px) {
    .container_12 .grid_3,.container_12 .grid_9,.container_12 .grid_12 {
      width: 300px;
  }
}</pre>

<h3 class="title" id="sigil_toc_id_150"><a id="tip34"/>提示</h3>
<p>如您所见，在最终的CSS文件中重复了几个断点。这是Sass的一个问题。然而，这并不是一个问题，也不是我们需要担心的事情，因为当服务器对这个文件进行gzip压缩时，它将最大限度地压缩它。如果我们最小化最终输出（无论如何我们都应该这样做），我们将进一步压缩文件。重复的<code class="literal">@media</code>断点对性能几乎没有影响。</p>


<p>现在，让我们<a id="id249" class="indexterm"/>看看当使用百分比和RWD时，对同一页面进行改造会是什么样子。</p>



<h1 class="title" id="sigil_toc_id_151"><a id="ch03lvl1sec23"/>加装后轮驱动</h1>



<p>我们刚刚看到了使用AWD是如何完成的，使用像素。通过RWD和一个非常简单的等式，我们可以使用相对单位（在我们的例子中是百分比）来改造一个站点。更不用说它将比使用AWD容易得多。</p>
<h2 class="title" id="sigil_toc_id_152"><a id="ch03lvl2sec39"/>RWD魔术公式</h2>



<p>由伊桑·马科特（Ethan Marcotte）发现/创造，他创造了术语<em>响应式网页设计</em>，RWD<a id="id251" class="indexterm"/>神奇公式是一个非常简单的方程式：</p>
<p>（目标÷背景）x 100=结果%</p>
<p>在我们开始将像素转换成百分比之前，我们需要了解<em>上下文</em>的宽度。</p>

<h2 class="title" id="sigil_toc_id_153"><a id="ch03lvl2sec40"/>主容器</h2>



<p>我们的<a id="id252" class="indexterm"/>上下文将成为页面<code class="literal">.container_12</code>的主容器，其最大宽度为980px。然而，主容器和列将把980px上下文转换成960px。注意<code class="literal">.container_12</code>部分的10px左右填充和<code class="literal">.grid</code>规则中的10px左右边距：</p>
<pre class="programlisting">.container_12 {
    width: 980px;
    <strong>padding: 0 10px;</strong>
    margin: auto; 
}
.grid {
    &amp;_1, &amp;_2, &amp;_3, &amp;_4, &amp;_5, &amp;_6, &amp;_7, &amp;_8, &amp;_9, &amp;_10, &amp;_11, &amp;_12 {
      float: left;
      <strong>margin: 0 10px;</strong>
    }
}</pre>

<p><code class="literal">.grid</code>规则中的10px左右边距意味着所有列的宽度都有一个额外的20px。例如，940px宽的页眉和页脚实际上是960px宽的。<code class="literal">box-sizing: border-box;</code>属性仅用于减去盒子模型内部的内容（填充），而不是外部的内容（边距）。</p>
<p>一种解决方案是移除<code class="literal">.container_12</code>上的10px左右边距，并将<code class="literal">.grid</code>规则中的左右边距增加到20px，以保持排水沟；否则，这些柱子就会相互接触。</p>
<p>现在，排水沟变宽了，这可能不是出于设计目的，信不信由你，在最宽的容器中增加了一个额外的1px。在我们的例子中，它被添加到页眉和页脚。</p>
<p>作为一名设计师，我知道如果不需要的话，我不想处理这些问题。</p>
<p>第二种解决方案更简单：将上下文设为960px。这样，我们可以在不影响主容器和列的完整性的情况下全局删除额外的10个像素，结果值几乎相同，因为我们得到的是百分比。</p>
<p>（960px÷980px）x 100=97.95918367346939%（97.95%）</p>
<p>它实际上与：<em>（940px÷960px）x100=97.916667%（97.91%）</em>相同</p>
<p>在第二种解决方案中，1px问题确实会发生，但在调整浏览器大小时会以随机宽度发生。但是，对于第一个解决方案，1px问题是永久性的，无论浏览器的宽度如何。</p>
<p>清楚了这一部分之后，我们将使用960px作为其上下文，将所有基于像素的宽度转换为百分比。</p>

<h2 class="title" id="sigil_toc_id_154"><a id="ch03lvl2sec41"/>页眉和页脚部分</h2>



<p><strong>页眉</strong>和<strong>页脚</strong>部分的宽度相同，为940px。知道它们的上下文是<a id="id254" class="indexterm"/>960px，让我们继续使用神奇的公式来计算它们的宽度百分比：<em>（940px÷960px）x100=97.916667%</em>。</p>
<p>你可能会问自己，“需要这么多小数吗？”不是所有小数，但至少推荐两个小数。</p>
<p>所以我们最终得到了97.91%的<strong>页眉</strong>和<strong>页脚</strong>部分。</p>
<p>一些开发人员建议使用所有的小数，并让浏览器决定要使用多少。在过去，我决定挑战这一建议，只使用两个小数来查看发生了什么。自从我开始使用两个小数以来，我在任何浏览器中都没有遇到任何不必要的行为或宽度问题。</p>
<p>Firefox和IE11将多余的小数削减为2。另一方面，Chrome保留所有小数。我建议使用不少于两个小数，这是我们在书中要使用的，以保持简单和简短。然而，如果你喜欢使用所有的小数，那就一定要用！在这一点上，这是个人偏好的问题。</p>
<h3 class="title" id="sigil_toc_id_155"><a id="tip35"/>提示</h3>
<p>避免将数值四舍五入，让浏览器按原样处理小数。这样做还可以让你专注于最重要的事情：提高效率，努力为用户创造一些难忘的东西。</p>



<h2 class="title" id="sigil_toc_id_156">“T0”：导航部分</h2>



<p>为了<a id="id255" class="indexterm"/>找到<strong>导航</strong>部分的宽度百分比，我们也使用960px作为上下文：<em>（220px÷960px）x100=22.916667%</em>。</p>
<p>使用两个小数，我们得到了22.91%的<strong>Nav</strong>部分。</p>

<h2 class="title" id="sigil_toc_id_157"><a id="ch03lvl2sec43"/>内容部分</h2>



<p>为了找出<a id="id256" class="indexterm"/>以百分比表示的<strong>内容</strong>部分的宽度，我们的公式看起来几乎相同。唯一的区别是我们正在更改第一个值，该值对应于<strong>内容</strong>部分的宽度（以像素为单位）：<em>（700px÷960px）x100=72.916667%</em>。</p>
<p>仅使用两个小数，我们的最终值是72.91%的<strong>内容</strong>部分。</p>
<p>这就是我们最初改装RWD SCSS文件的样子：</p>
<pre class="programlisting">.container_12 {
    .grid_12 { //Header and Footer sections
      <strong>width: 97.91%;</strong>
    }
    .grid_3 { //Nav section
      <strong>width: 22.91%;</strong>
    }
    .grid_9 { //Content section
       <strong>width: 72.91%;</strong>
    }
}</pre>

<p>现在，在我们继续之前，让我们退一步，讨论其他一些基于像素的宽度。还记得主容器<code class="literal">.container_12</code>左右两侧的10px填充物吗？我们还需要将这些10px转换成百分比。</p>
<p>通过我们的神奇公式，我们可以这样做：</p>
<p><em>（10px÷960px）x100=1.0416667%</em>。</p>
<p>仅使用两个小数，我们的最终值是1.04%的左右填充。</p>
<p>让我们将此值添加到我们的SCS中：</p>
<pre class="programlisting">.container_12 {
    width: 980px;
    <strong>padding: 0 1.04%;</strong>
    margin: auto; 
}
.container_12 {
    .grid_12 { //Header and Footer sections
      width: 97.91%;
    }
    .grid_3 { //Nav section
      width: 22.91%;
    }
    .grid_9 { //Content section
       width: 72.91%;
    }
}</pre>

<p>此外，我们所有的列在左右两侧都有10px的边距。既然我们已经知道10px是1.04%，那么让我们将此值添加到SCS中的所有列中：</p>
<pre class="programlisting">.container_12 {
    width: 980px;
    <strong>padding: 0 1.04%;</strong>
    margin: auto; 
}
<strong>.grid {</strong>
<strong>    &amp;_1, &amp;_2, &amp;_3, &amp;_4, &amp;_5, &amp;_6, &amp;_7, &amp;_8, &amp;_9, &amp;_10, &amp;_11, &amp;_12 {</strong>
<strong>      float: left;</strong>
<strong>      margin: 0 1.04%;</strong>
<strong>    }</strong>
<strong>}</strong>
.container_12 {

    .grid_12 { //Header and Footer sections
      width: 97.91%;
    }
    .grid_3 { //Nav section
      width: 22.91%;
    }
    .grid_9 { //Content section
       width: 72.91%;
    }
}</pre>

<p>现在，我们<a id="id258" class="indexterm"/>有一个1024px宽的浏览器窗口，一个980px宽的布局，所有列都有相应的百分比值。实际上，如果不查看代码以直观地告诉固定宽度和基于百分比的布局之间的差异，这几乎是不可能的。</p>
<p>我们在这里做得很好！</p>
<p><img src="graphics/B02102_03_01.jpg" alt="The Content section"/></p>
<p>让乐趣开始吧。让我们添加第一个媒体查询。</p>
<h3 class="title" id="sigil_toc_id_158"><a id="ch03lvl3sec31"/>980px至768px（后轮驱动）</h3>



<p><a id="id260" class="indexterm"/>以下媒体查询针对768px：</p>
<pre class="programlisting">.container_12 {
    width: 980px;
    <strong>padding: 0 1.04%;</strong>
    margin: auto; 
}
.grid {
    &amp;_1, &amp;_2, &amp;_3, &amp;_4, &amp;_5, &amp;_6, &amp;_7, &amp;_8, &amp;_9, &amp;_10, &amp;_11, &amp;_12 {
<strong>      float: left;</strong>
      margin: 0 1.04%;
    }
}
.container_12 {
    <strong>@include forSmallScreens(980px) {</strong>
<strong>      width: 768px;</strong>
<strong>    }</strong>
    .grid_12 { //Header and Footer sections
      width: 97.91%;
    }
    .grid_3 { //Nav section
      width: 22.91%;
    }
    .grid_9 { //Content section
       width: 72.91%;
    }
}</pre>

<p>由于<a id="id261" class="indexterm"/>的<strong>页眉</strong>、<strong>页脚</strong>、<strong>导航</strong>和<strong>内容</strong>部分的宽度、填充和边距现在都是按百分比设置的，我们不必为它们声明任何媒体查询，至少现在还没有，因为布局没有改变。</p>
<p>当我们调整浏览器窗口的大小时，<strong>页眉</strong>、<strong>页脚</strong>、<strong>导航</strong>和<strong>内容</strong>部分会自动响应、按比例收缩、正确捕捉，并适应主容器<code class="literal">.container_12</code>的新宽度，而不会破坏布局。这显示在以下屏幕截图中：</p>
<p><img src="graphics/B02102_03_02.jpg" alt="980px to 768px (RWD)"/></p>
<p>这太棒了！</p>
<p>让我们添加另一个断点。</p>

<h3 class="title" id="sigil_toc_id_159"><a id="ch03lvl3sec32"/>768px至640px（后轮驱动）</h3>



<p>在<a id="id263" class="indexterm"/>后面的断点（640px）中，我们的布局将更改为一列。因此，我们将添加一个新的媒体查询，使<strong>导航</strong>和<strong>内容</strong>部分与<strong>页眉</strong>和<strong>页脚</strong>部分一样宽，并使它们相互堆叠。</p>
<p>以下媒体查询针对640px，将<strong>导航</strong>和<strong>内容</strong>部分全宽：</p>
<pre class="programlisting">.container_12 {
    width: 980px;
    padding: 0 1.04%;
    margin: auto;
}
.grid {
    &amp;_1, &amp;_2, &amp;_3, &amp;_4, &amp;_5, &amp;_6, &amp;_7, &amp;_8, &amp;_9, &amp;_10, &amp;_11, &amp;_12 {
        float: left;
        margin: 0 1.04%;
    }
}
.container_12 {
    @include forSmallScreens(980px) {
        width: 768px;
    }
    <strong>@include forSmallScreens(768px) {</strong>
<strong>        width: 640px;</strong>
<strong>    }</strong>
    .grid_12 { //Header and Footer sections
      width: 97.91%;
    }
    .grid_3 { //Nav section
      width: 22.91%;
    }
    .grid_9 { //Content section
      width: 72.91%;
    }
    <strong>.grid_3, .grid_9 { //Nav and Content sections</strong>
<strong>        @include forSmallScreens(640px) {</strong>
<strong>            width: 97.91%;</strong>
<strong>        }</strong>
<strong>    }</strong>
}</pre>

<p>好的，我们<a id="id264" class="indexterm"/>现在有一个单列布局。不错，不错！</p>
<p><img src="graphics/B02102_03_03.jpg" alt="768px to 640px (RWD)"/></p>

<h3 class="title" id="sigil_toc_id_160"><a id="ch03lvl3sec33"/>640px至480px（后轮驱动）</h3>



<p>我们现在的<a id="id265" class="indexterm"/>将小到480px，单列布局不会改变，只有所有容器的宽度会改变。</p>
<p>以下媒体查询针对480px：</p>
<pre class="programlisting">.container_12 {
  width: 980px;
  <strong>padding: 0 1.04%;</strong>
  margin: auto; 
}
.grid {
    &amp;_1, &amp;_2, &amp;_3, &amp;_4, &amp;_5, &amp;_6, &amp;_7, &amp;_8, &amp;_9, &amp;_10, &amp;_11, &amp;_12 {
<strong>      float: left;</strong>
      margin: 0 1.04%;
    }
}
.container_12 {
    @include forSmallScreens(980px) {
      width: 768px;
    }
    @include forSmallScreens(768px) {
      width: 640px;
    }
    <strong>@include forSmallScreens(640px) {</strong>
<strong>      width: 480px;</strong>
<strong>    }</strong>
    .grid_12 { //Header and Footer sections
      width: 97.91%;
    }
    .grid_3 { //Nav section
      width: 22.91%;
      @include forSmallScreens(640px) {     
        height: 50px; //This is only for styling
      }
    }
    .grid_9 { //Content section
       width: 72.91%;
    }
    <strong>.grid_3, .grid_9 { </strong>//Nav and Content sections
<strong>      @include forSmallScreens(640px) {</strong>
<strong>        width: 97.91%;</strong>
<strong>      }</strong>
<strong>    }</strong>
}</pre>

<p>我们的<a id="id266" class="indexterm"/>布局越来越窄，我们所需要做的就是添加一个新的媒体查询，就是这样！不需要和其他容器混在一起；它们完全适应我们定义的任何宽度。</p>
<p><img src="graphics/B02102_03_04.jpg" alt="640px to 480px (RWD)"/></p>

<h3 class="title" id="sigil_toc_id_161"><a id="ch03lvl3sec34"/>480px至320px（后轮驱动）</h3>



<p>最后，我们<a id="id267" class="indexterm"/>在不修改单列布局的情况下处理320px的宽度。我们移除<code class="literal">.container_12</code>上的填充物，以利用所有可用的屏幕空间。</p>
<p>以下媒体查询针对320px：</p>
<pre class="programlisting">.container_12 {
    width: 980px;
    <strong>padding: 0 1.04%;</strong>
    margin: auto;
}
.grid {
    &amp;_1, &amp;_2, &amp;_3, &amp;_4, &amp;_5, &amp;_6, &amp;_7, &amp;_8, &amp;_9, &amp;_10, &amp;_11, &amp;_12 {
<strong>    float: left;</strong>
    margin: 0 1.04%;  }
}
.container_12 {
    @include forSmallScreens(980px) {
      width: 768px;
    }
    @include forSmallScreens(768px) {
      width: 640px;
    }
    @include forSmallScreens(640px) {
      width: 480px;
    }
    <strong>@include forSmallScreens(480px) {</strong>
<strong>      width: 320px; padding: 0;</strong>
<strong>    }</strong>
    .grid_12 { //Header and Footer sections
      width: 97.91%;
    }
    .grid_3 { //Nav section
      width: 22.91%;
      @include forSmallScreens(640px) {     
        height: 50px; //This is only for styling
      }
    }
    .grid_9 { //Content section
       width: 72.91%;
    }
    .grid_3, .grid_9 {
      @include forSmallScreens(640px) {
        width: 97.91%;
      }
    }
}</pre>

<p>再一次<a id="id268" class="indexterm"/>我们不需要在<strong>页眉</strong>、<strong>页脚</strong>、<strong>导航</strong>和<strong>内容</strong>部分添加任何内容，因为它们现在都有97.91%的宽度。这使他们反应灵敏，我们不必担心其他任何事情。</p>
<p><img src="graphics/B02102_03_05.jpg" alt="480px to 320px (RWD)"/></p>
<p>结合所有断点和宽度的<a id="id269" class="indexterm"/>最终SCS如下所示：</p>
<pre class="programlisting">.container_12 {
    width: 980px;
    padding: 0 1.04%;
    margin: auto;
}
.grid {
    &amp;_1, &amp;_2, &amp;_3, &amp;_4, &amp;_5, &amp;_6, &amp;_7, &amp;_8, &amp;_9, &amp;_10, &amp;_11, &amp;_12 {
        float: left;
        margin: 0 1.04%;
    }
}
.container_12 {
    @include forSmallScreens(980px) {
        width: 768px;
    }
    @include forSmallScreens(768px) {
        width: 640px;
    }
    @include forSmallScreens(640px) {
        width: 480px;
    }
    @include forSmallScreens(480px) {
        width: 320px; padding: 0;
    }
    .grid_12 { //Header and Footer sections
      width: 97.91%;
    }
    .grid_3 { //Nav section
      width: 22.91%;
    }
    .grid_9 { //Content section
      width: 72.91%;
    }
    .grid_3, .grid_9 { //Nav and Content sections
        @include forSmallScreens(640px) {
            width: 97.91%;
        }
    }
}</pre>

<p>它<a id="id270" class="indexterm"/>编译成以下CSS：</p>
<pre class="programlisting">.container_12 {
    width: 980px;
    padding: 0 1.04%;
    margin: auto;
}

.grid_1, .grid_2, .grid_3, .grid_4, .grid_5, .grid_6, .grid_7, .grid_8, .grid_9, .grid_10, .grid_11, .grid_12 {
    float: left;
    margin: 0 1.04%;
}

@media (max-width: 980px) {
    .container_12 {
      width: 768px;
    }
}
@media (max-width: 768px) {
    .container_12 {
      width: 640px;
    }
}
@media (max-width: 640px) {
    .container_12 {
      width: 480px;
    }
}
@media (max-width: 480px) {
    .container_12 {
      width: 320px;
      padding: 0;
    }
}
.container_12 .grid_12 {
    width: 97.91%;
}
.container_12 .grid_3 {
    width: 22.91%;
}
.container_12 .grid_9 {
    width: 72.91%;
}
@media (max-width: 640px) {
    .container_12 .grid_3, .container_12 .grid_9 {
      width: 97.91%;
    }
}</pre>

<p>正如您所见，使用RWD改造站点的代码要比使用AWD少得多。诚然，这些例子是对站点/应用程序布局的极端简化，但现在当使用AWD或RWD的时机敲响你的大门时，你已经了解了每种技术的基本概念。</p>



<h1 class="title" id="sigil_toc_id_162"><a id="ch03lvl1sec24"/>总结</h1>



<p>当然，我们在这一章中讨论了很多有趣的东西。我们看到了使用desktop first创建设计和线框是多么有益，因为拥有一个大画布可以让我们探索不同的布局，并正确安排内容的层次结构。</p>
<p>在创建HTML模型时，使用mobile first会更好，因为对移动设备友好的网站将有更大的覆盖范围，允许重点内容，并利用移动设备的技术。</p>
<p>我们能够用魔术公式在固定宽度的场地上加装全轮驱动和后轮驱动。我们还讨论了RWD的好处，因为它需要更少的代码。然而，对旅游网站的分析清楚地表明，RWD有时不是正确的解决方案。</p>
<p>我们还了解了如果我们采用移动优先的方法构建，如何使用<code class="literal">Respond.js</code>使传统浏览器支持媒体查询。使用条件类是一种很好的技术，因为它不具有侵入性，易于实现，并且没有JavaScript依赖性。</p>
<p>在下一章中，我们将讨论RWD世界中一些最有趣的主题：CSS网格、CSS框架和Flexbox的威力。</p>
<p>让我们这样做！</p>

</body>
</html>