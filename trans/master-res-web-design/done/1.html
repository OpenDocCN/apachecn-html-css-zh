<html>
<head><title>Chapter 1. Harness the Power of Sass for Responsive Web Design</title>
<link rel="stylesheet" href="epub.css" type="text/css"/>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
</head>
<body id="page">
<h1 class="title"><a id="ch01"/>第1章利用Sass的力量进行响应性网页设计</h1>



<p>在使用HTML5和CSS3掌握响应性web设计之前，我们需要在技术方面保持一致，在我们的例子中，CSS预处理器，特别是Sass。</p>
<p>在本书中，所有CSS都将以SCSS格式用Sass编写。我们写CSS的方式已经改变；它有了巨大的改进。</p>
<p>诸如Sass、LESS和Stylus等CSS预处理器为web/移动设计人员和开发人员提供了新的超级能力。是的，我使用了<em>超级大国</em>这个词，因为这正是我第一次使用Sass几个小时后的感受，我使用的是最基本的：</p>
<pre class="programlisting">.navigation-bar {
    display: flex;
    li {
        padding: 5px 10px;
    }
}</pre>

<p>看到嵌套的<code class="literal">li</code>选择器了吗？是的，这是一种行为。编译前面的代码时，它看起来是这样的：</p>
<pre class="programlisting">.navigation-bar {
   display: flex; 
}
.navigation-bar li {
   padding: 5px 10px;
}</pre>

<h3 class="title" id="sigil_toc_id_17"><a id="tip02"/>提示</h3>
<p><strong>下载示例代码</strong></p>
<p>您可以从您的账户<a class="ulink" href="http://www.packtpub.com">下载示例代码文件http://www.packtpub.com </a>对于您购买的所有Packt出版书籍。如果您在其他地方购买了本书，您可以访问<a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support </a>并注册，将文件直接通过电子邮件发送给您。</p>


<p>让我们看看本章为我们准备了什么：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sass是如何工作的？</li>
<li class="listitem" style="list-style-type: disc">SASS的基本概念——顾虑T1的响应性网页设计</li>
</ul>

<h1 class="title" id="sigil_toc_id_18"><a id="ch01lvl1sec08"/>Sass是如何工作的？</h1>



<p>了解<a id="id1" class="indexterm"/>Sass的工作原理需要理解几个基本的技术概念：</p>
<ol class="orderedlist arabic"><li class="listitem">Sass可以基于两种不同的技术：Ruby或LibSass。在本书中，我们将使用基于Ruby的Sass。</li>
<li class="listitem">Sass是一颗红宝石。Gems是用于Ruby的包。RubyGem是只在Ruby上运行的软件。Ruby是一种编程语言，与PHP、.NET、Java等类似。</li>
<li class="listitem">我们可以通过命令行运行Sass，但是我们也可以使用第三方应用程序运行Sass，这样就不需要使用命令行了。</li>
<li class="listitem">Sass是一种用于创建CSS的编程/脚本语言。</li>
<li class="listitem">CSS是一种非常重复的语言。Sass允许作者优化那些重复的任务，并更快更有效地创建CSS。</li>
<li class="listitem">Sass工作流的一部分是当Sass在<em>监视</em>一个SCSS文件时，例如<code class="literal">book-styles.scss</code>。当它检测到该SCSS文件中的更改时，会将其编译为CSS文件<code class="literal">book-styles.css</code>。</li>
</ol>

<h3 class="title" id="sigil_toc_id_19"><a id="tip03"/>提示</h3>
<p><em>监视SCSS文件</em>表示Sass监视程序正在后台运行，查看SCSS文件是否有任何更改。</p>


<h2 class="title" id="sigil_toc_id_20"><a id="ch01lvl2sec08"/>安装Sass</h2>



<p>以下是我们将要遵循的步骤：</p>
<ol class="orderedlist arabic"><li class="listitem">下载Ruby安装程序</li>
<li class="listitem">打开命令行</li>
<li class="listitem">安装Sass gem</li>
</ol>

<h3 class="title" id="sigil_toc_id_21"><a id="ch01lvl3sec01"/>下载Ruby安装程序</h3>



<p><strong>Windows</strong>：从以下链接下载<a id="id3" class="indexterm"/>Ruby安装程序：</p>
<p>T0http://rubyinstaller.org/downloads/ T1</p>
<p><strong>Mac</strong>：Ruby<a id="id4" class="indexterm"/>预装在所有Mac上，因此无需下载任何内容。</p>

<h3 class="title" id="sigil_toc_id_22"><a id="ch01lvl3sec02"/>打开命令行</h3>



<p><strong>Windows和Mac</strong>：打开<a id="id5" class="indexterm"/>命令行。</p>
<h3 class="title" id="sigil_toc_id_23"><a id="tip04"/>提示</h3>
<p><strong>窗口提示！</strong></p>
<p>按<em>窗口</em>+<em>R</em>，输入<code class="literal">CMD</code>，然后按<em>进入</em>。</p>


<p><img src="graphics/B02102_01_01.jpg" alt="Opening the command line"/></p>

<h3 class="title" id="sigil_toc_id_24"><a id="ch01lvl3sec03"/>安装Sass gem</h3>



<p>在命令提示符中键入<a id="id6" class="indexterm"/>以下命令（无论您在哪个文件夹中）：</p>
<p>在Windows中，使用以下命令：</p>
<pre class="programlisting"><strong>gem install sass</strong>
</pre>

<p>Mac，使用以下命令：</p>
<pre class="programlisting"><strong>sudo gem install sass</strong>
</pre>

<p><img src="graphics/B02102_01_02.jpg" alt="Installing the Sass gem"/></p>
<p>安装Sass需要几秒钟的时间。</p>
<h3 class="title" id="sigil_toc_id_25"><a id="tip05"/>提示</h3>
<p>在撰写本文时，Sass的最新版本是3.4.14。该书出版时，版本/修订版可能会有所不同。</p>


<p>就这样！Sass现在已安装在您的计算机上。</p>


<h2 class="title" id="sigil_toc_id_26"><a id="ch01lvl2sec09"/>使用Sass</h2>



<p>我将要向你们展示的与任何其他Sass教程告诉你们的完全不同。这些教程中的大多数都让事情变得太复杂了。这是你读过的最简单的使用Sass的方法。</p>
<p>下面的屏幕截图在Windows上，但无论平台如何，都可以应用完全相同的过程。</p>
<p>在以下步骤中，您将看到创建必要文件夹和文件后的外观示例，而不是如何创建它们的示例：</p>
<ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">/Demo</code> folder anywhere on your drive:<p><img src="graphics/B02102_01_04.jpg" alt="Using Sass"/></p></li>
<li class="listitem">Inside<a id="id9" class="indexterm"/> that folder, create two subfolders, <code class="literal">/css</code> and <code class="literal">/scss</code>:<p><img src="graphics/B02102_01_05.jpg" alt="Using Sass"/></p></li>
<li class="listitem">Create a <code class="literal">.scss</code> file. Go into the <code class="literal">/scss</code> folder and create a file called <code class="literal">styles.scss</code>:<p><img src="graphics/B02102_01_06.jpg" alt="Using Sass"/></p><h3 class="title" id="sigil_toc_id_27"><a id="tip06"/>提示</h3>
<p>注意<a id="id10" class="indexterm"/>文件扩展名<code class="literal">.scss</code>？这是你的Sass文件。是的，现在里面什么都没有，是空的。</p>

</li>
<li class="listitem">Go back to the command line for a minute and follow these steps:<ol class="orderedlist arabic"><li class="listitem">在命令行中，键入<code class="literal">cd &lt;space&gt;</code></li>
<li class="listitem">A space after <code class="literal">cd</code> means <em>Change Directory</em>. From your file manager, drag and drop the <code class="literal">/Demo</code> folder into the command prompt/terminal window and press <em>Enter</em>.<p><img src="graphics/B02102_01_06a.jpg" alt="Using Sass"/></p></li>
<li class="listitem">您<a id="id11" class="indexterm"/>现在应该在<code class="literal">/Demo</code>文件夹中。</li>
</ol>
<p><img src="graphics/B02102_01_07.jpg" alt="Using Sass"/></p></li>
<li class="listitem">在命令行<pre class="programlisting"><strong>sass --watch scss:css­</strong>
</pre>中键入以下命令，使Sass<em>监视</em>您的<code class="literal">/scss</code>和<code class="literal">/css</code>文件夹</li>
<li class="listitem">Make Sass watch the <code class="literal">/scss</code> and <code class="literal">/css</code> folders.<p><img src="graphics/B02102_01_08.jpg" alt="Using Sass"/></p><p>就这样！您现在正在使用Sass！</p><h3 class="title" id="sigil_toc_id_28"><a id="tip07"/>提示</h3>
<p><code class="literal">--watch</code>标志告诉Sass注意<code class="literal">/scss</code>和<code class="literal">/css</code>文件夹，这样当<a id="id12" class="indexterm"/>我们对<code class="literal">.scss</code>文件（在我们的例子中为<code class="literal">styles.scss</code>文件）进行更改时，Sass将检测到更改并将SCS编译为我们将在网站或应用程序中使用的最终CSS文件。</p>

</li>
<li class="listitem">Edit the <code class="literal">.scss</code> file and watch Sass compile it into a <code class="literal">.css</code> file:<ol class="orderedlist arabic"><li class="listitem">打开文本编辑器（我使用升华文本）。</li>
<li class="listitem">打开<code class="literal">styles.scss</code>文件。</li>
<li class="listitem">添加一些CSS到它。</li>
<li class="listitem">保存<code class="literal">styles.scss</code>文件。</li>
<li class="listitem">从命令行/终端验证编译是否成功。</li>
<li class="listitem">打开你的<code class="literal">styles.css</code>文件，享受你的新创作。</li>
</ol>
<p><img src="graphics/B02102_01_09.jpg" alt="Using Sass"/></p></li>
</ol>




<h1 class="title" id="sigil_toc_id_29"><a id="ch01lvl1sec09"/>RWD用Sass的基本概念</h1>



<p>对于<a id="id13" class="indexterm"/>初学者来说，Sass是一种编程/脚本语言。我敢打赌你<a id="id14" class="indexterm"/>没想到会发生这样的事。是的，它是一种编程/脚本语言，专注于提高web设计师和web开发人员创建CSS的效率。在本书中，我们将重点介绍Sass的简单部分，它们可以帮助我们更高效地编写CSS，更重要的是，我们将从中获得乐趣。</p>
<p>实现RWD非常耗时：编码、测试、创建资产、浏览器故障排除，然后测试更多。我们的编码流程越精简，重复性工作越少，我们的效率就越高，我们为项目、团队、业务以及最终的用户增加的价值也就越大。Sass将帮助我们简化CSS的编码。</p>
<p>让我们首先讨论以下概念：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sass或SCSS</li>
<li class="listitem" style="list-style-type: disc">变量</li>
<li class="listitem" style="list-style-type: disc">混血儿</li>
<li class="listitem" style="list-style-type: disc">论据</li>
<li class="listitem" style="list-style-type: disc">筑巢</li>
<li class="listitem" style="list-style-type: disc">部分文件</li>
<li class="listitem" style="list-style-type: disc">@进口</li>
<li class="listitem" style="list-style-type: disc">源地图</li>
<li class="listitem" style="list-style-type: disc">Sass评论</li>
</ul>

<h2 class="title" id="sigil_toc_id_30"><a id="ch01lvl2sec10"/>Sass或SCSS</h2>



<p><a id="id16" class="indexterm"/>有两种方式可以编写Sass样式的CSS：Sass语法<a id="id17" class="indexterm"/>和SCSS语法。</p>
<h3 class="title" id="sigil_toc_id_31"><a id="tip08"/>提示</h3>
<p>不要搞错；Sass用大写字母S书写，其余用小写字母，SCSS全部用大写字母。</p>


<h3 class="title" id="sigil_toc_id_32"><a id="ch01lvl3sec04"/>Sass语法</h3>



<p><a id="id18" class="indexterm"/>Sass语法，也称为<em>缩进语法</em>，是编写Sass的初始和唯一方法。但它看起来与常规CSS有点太大的不同，使得学习曲线比实际需要的更陡峭。</p>
<p>此语法没有使用任何大括号或分号。在某些情况下，它使用等号代替冒号。与SCS不同，缩进是非常严格和强制性的。许多开发人员不太喜欢Sass语法的这些方面。</p>
<p>以下是一个基本示例：</p>
<pre class="programlisting">.selector-a
    float: left

        .selector-b
            background: orange</pre>

<p>这将编译为以下代码：</p>
<pre class="programlisting">.selector-a {
    float: left;
}

.selector-a, .selector-b {
    background: orange;
}</pre>


<h3 class="title" id="sigil_toc_id_33"><a id="ch01lvl3sec05"/>SCSS语法</h3>



<p>当<a id="id19" class="indexterm"/>SCSS随着Sass版本3的发布而推出时，对于我们这些不是程序员但希望利用Sass功能的人来说，事情变得容易多了。</p>
<h3 class="title" id="sigil_toc_id_34"><a id="note02"/>注</h3>
<p>SCSS<a id="id20" class="indexterm"/>代表<strong>时髦的CSS</strong>。</p>


<p>如果您已经编写了CSS，那么您已经编写了SCS。我们在编写CSS时已经使用的所有东西都与使用SCSS语法编写Sass时使用的东西相同。因此，学习曲线最初是不存在的。</p>
<p>然后，您意识到您还可以使用一些Sass来增强您已经知道的内容，使学习Sass成为一种很棒的体验，因为您可以非常快地掌握它。老实说，你感觉自己正在获得超能力。我不是开玩笑。</p>
<p>下面是我们以前使用SCSS语法看到的相同示例：</p>
<pre class="programlisting">.selector-a {
    float: left;
}

.selector-a, .selector-b {
    background: orange;
}</pre>

<p>等一下！那是CSS！是的，它也是SCSS。</p>
<p>让我们以不同的方式使用SCSS语法来查看相同的示例：</p>
<pre class="programlisting">.selector- {
    &amp;a {
        float: left;
     }
    &amp;a, &amp;b {
        background: orange;
    }
}</pre>

<p>SCSS中的符号“<code class="literal">&amp;</code>”允许我们将父选择器的名称添加到嵌套选择器中，而无需键入整个内容，从而使我们处于事物的<em>干燥</em>一侧。</p>
<h3 class="title" id="sigil_toc_id_35"><a id="note03"/>注</h3>
<p>干燥意味着<a id="id22" class="indexterm"/>不要重复你自己。</p>


<p>两个SCSS示例编译为以下代码：</p>
<pre class="programlisting">.selector-a {
    float: left;
}

.selector-a, .selector-b {
    background: orange;
}</pre>


<h3 class="title" id="sigil_toc_id_36"><a id="ch01lvl3sec06"/>Sass变量</h3>



<p>让我们先了解几件事：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">变量只是存储值以供以后使用的一种方法</li>
<li class="listitem" style="list-style-type: disc">该值通常与简单的<em>用户友好</em>字关联</li>
<li class="listitem" style="list-style-type: disc">Sass变量必须以美元符号（<code class="literal">$)</code>符号）开头</li>
<li class="listitem" style="list-style-type: disc">变量的巨大好处是，如果我们需要更改值，我们将在单个位置进行更改，而不是在整个文档中查找和替换值</li>
</ul>

<h3 class="title" id="sigil_toc_id_37"><a id="tip09"/>提示</h3>
<p>当列出多个变量时，每个变量的末尾应该有一个分号（<code class="literal">;</code>）。如果只有一个变量，则不需要分号。然而，这是一个很好的实践，总是用分号结束变量，即使它只是一个分号。</p>


<p>以下是Sass变量的示例：</p>
<pre class="programlisting">$brandBlue: #416e8e;</pre>

<h3 class="title" id="sigil_toc_id_38"><a id="tip10"/>提示</h3>
<p>我建议您使用<em>camelCase</em>样式命名变量，以区别于破折号分隔的类名和CSS属性。这在扫描SCSS文档时非常有用，因为变量更容易检测。</p>


<p>正如我们所见，我们正在存储一个颜色值。我们使用的名称<code class="literal">brandBlue</code>肯定比<code class="literal">#416e8e</code>更便于用户使用。此外，我们还使用了美元符号（<code class="literal">$</code>）并以分号（<code class="literal">;</code>结尾，以便在需要添加更多变量时进行良好的度量。现在，如果我们以后需要更改该值，我们需要做的就是在一个位置更改它。</p>
<p>变量应始终包含在SCSS文件的顶部，以便Sass知道在使用它们时要去哪里。您也可以通过部分文件包含它们，但我们将在本章后面讨论什么是部分文件。</p>
<p>以下是如何使用SCSS变量的示例：</p>
<pre class="programlisting">$brandBlue: #416e8e;
body {
    background: $brandBlue;
}</pre>

<p>上述代码编译为以下代码：</p>
<pre class="programlisting">body {
   background: #416e8e;
}</pre>


<h3 class="title" id="sigil_toc_id_39"><a id="ch01lvl3sec07"/>Sass混合物</h3>



<p>mixin是Sass最强大的功能之一。<strong>mixin</strong>是一组CSS声明（一个属性和值），存储起来供以后使用，就像一个变量一样。因此，我们不是一遍又一遍地输入所有这些CSS声明，而是输入mixin的名称。</p>
<p>关于SASS混合器需要考虑的一些事情如下：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">他们从<code class="literal">@mixin</code>指令开始</li>
<li class="listitem" style="list-style-type: disc">mixin用<code class="literal">@include</code>指令调用</li>
<li class="listitem" style="list-style-type: disc">我们可以在mixin中存储任意数量的CSS/SCSS数据</li>
<li class="listitem" style="list-style-type: disc">在创建mixin时，尝试使用<em>参数</em>，这样更具可伸缩性</li>
</ul>

<h3 class="title" id="sigil_toc_id_40"><a id="tip11"/>提示</h3>
<p>我们还没有看到<em>参数</em>是什么，但是现在提到这个词很重要，这样你就可以开始熟悉不同的Sass术语了。我们将在下一节介绍Sass参数。</p>


<p>让我们看一个mixin的示例：</p>
<pre class="programlisting">$brandBlue: #416e8e;
$supportGray: #ccc;
@mixin genericContainer {
    padding: 10px;
    border: $brandBlue 1px solid;
    background: $supportGray;
    box-shadow: 1px 1px 1px rgba(black, .3);
}</pre>

<p>我们在SCSS文件中调用mixin，如下所示：</p>
<pre class="programlisting">.selector-a {
    @include genericContainer;
}</pre>

<p>编译时，在CSS中看起来如下所示：</p>
<pre class="programlisting">.selector-a {
    padding: 10px;
    border: #416e8e 1px solid;
    background: #cccccc;
    box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3);
}</pre>

<p>让我们回顾一下我们在mixin中做了什么。</p>
<p>我们使用了<code class="literal">@mixin</code>指令：</p>
<pre class="programlisting">$brandBlue: #416e8e;
$supportGray: #ccc;
<strong>@mixin</strong> genericContainer {
    padding: 10px;
    border: $brandBlue 1px solid;
    background: $supportGray;
    box-shadow: 1px 1px 1px rgba(black, .3);
}</pre>

<p>我们<a id="id27" class="indexterm"/>使用camelCase命名约定将mixin的名称与破折号分隔的类名和CSS属性区分开来：</p>
<pre class="programlisting">$brandBlue: #416e8e;$supportGray: #ccc;
@mixin <strong>genericContainer</strong> {
    padding: 10px;
    border: $brandBlue 1px solid;
    background: $supportGray;
    box-shadow: 1px 1px 1px rgba(black, .3);
}</pre>

<p>我们在mixin中使用了Sass变量：</p>
<pre class="programlisting">$brandBlue: #416e8e;$supportGray: #ccc;
@mixin genericContainer {
    padding: 10px;
    border: <strong>$brandBlue</strong> 1px solid;
    background: <strong>$supportGray</strong>;
    box-shadow: 1px 1px 1px rgba(black, .3);
}</pre>

<p>我们在<code class="literal">box-shadow</code>颜色属性中使用关键字<code class="literal">black</code>，而不是使用十六进制<code class="literal">#000</code>或<code class="literal">rgb (0, 0, 0)</code>值：</p>
<pre class="programlisting">$brandBlue: #416e8e;$supportGray: #ccc;
@mixin genericContainer {
    padding: 10px;
    border: $brandBlue 1px solid;
    background: $supportGray;
    box-shadow: 1px 1px 1px rgba(<strong>black</strong>, .3);
}</pre>

<p>就这点而言，我们也可以这样使用变量名：</p>
<pre class="programlisting">$brandBlue: #416e8e;$supportGray: #ccc;
@mixin genericContainer {
    padding: 10px;
    border: $brandBlue 1px solid;
    background: $supportGray;
    box-shadow: 1px 1px 1px rgba(<strong>$brandBlue</strong>, .3);
}</pre>

<p>我们还在α值（<code class="literal">.3</code>中<a id="id28" class="indexterm"/>省略了<code class="literal">0</code>。这实际上不是Sass特性；这是一个CSS功能：</p>
<pre class="programlisting">$brandBlue: #416e8e;$supportGray: #ccc;
@mixin genericContainer {
    padding: 10px;
    border: $brandBlue 1px solid;
    background: $supportGray;
    box-shadow: 1px 1px 1px rgba($brandBlue, <strong>.3</strong>);
}</pre>

<h3 class="title" id="sigil_toc_id_41"><a id="tip12"/>提示</h3>
<p>对于以零开头的十进制值，可以忽略零。</p>


<p>同样，前面的mixin编译为以下CSS：</p>
<pre class="programlisting">.selector-a {
    padding: 10px;
    border: #416e8e 1px solid;
    background: #cccccc;
    box-shadow: 1px 1px 1px rgba(65, 110, 142, 0.3);
}</pre>



<h2 class="title" id="sigil_toc_id_42"><a id="ch01lvl2sec11"/>沙斯的论点</h2>



<p>在我们的第一个mixin示例中，我们没有任何参数。这并不理想，因为它不允许我们在相同的属性中使用不同的值。实际上，在mixin中不使用任何参数与每次需要时键入相同的属性和值没有什么区别。我们并不是真的在干什么。</p>
<p><em>参数</em>是混音的一部分，您可以根据自己的需要设置自己的值。参数使mixin值得创建。</p>
<p>在前面提到的mixin示例中，让我们添加一个参数：</p>
<pre class="programlisting">$brandBlue: #416e8e;$supportGray: #ccc;
@mixin genericContainer(<strong>$padding</strong>) {
    padding: $padding;
    border: $brandBlue 1px solid;
    background: $supportGray;
    box-shadow: 1px 1px 1px rgba(black, .3);
}</pre>

<p><code class="literal">padding</code>的参数允许我们设置任何想要的值。我们不是每次都被<em>强迫</em>将填充物设置为<code class="literal">10px</code>。</p>
<p>这是<a id="id30" class="indexterm"/>我们设置参数值的方式：</p>
<pre class="programlisting">.selector-a {
    @include genericContainer(10px);
}</pre>

<p>这将编译为以下内容：</p>
<pre class="programlisting">.selector-a {
    padding: <strong>10px;</strong>
    border: #416e8e 1px solid;
    background: #cccccc;
    box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3);
}</pre>

<p>然而，这个论点有一个潜在的问题；如果我们不为<code class="literal">padding</code>设置一个值，我们将在编译时得到一个错误。</p>
<p>所以这里的解决方案是设置一个<em>默认</em>值；如果出于某种原因我们没有为<code class="literal">padding</code>定义一个值，Sass将采用该默认值并在编译时使用它，而不会抛出错误。</p>
<p>下面是我们如何设置参数的默认值：</p>
<pre class="programlisting">$brandBlue: #416e8e;$supportGray: #ccc;
@mixin genericContainer($padding: <strong>8px</strong>) {
    padding: $padding;
    border: $brandBlue 1px solid;
    background: $supportGray;
    box-shadow: 1px 1px 1px rgba(black, .3);
}</pre>

<p>这就是我们如何调用mixin，而不声明任何<code class="literal">padding</code>值：</p>
<pre class="programlisting">.selector-a {
    @include genericContainer;
}</pre>

<p>已编译的CSS如下所示：</p>
<pre class="programlisting">.selector-a {
    padding: <strong>8px;</strong>
    border: #416e8e 1px solid;
    background: #cccccc;
    box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3);
}</pre>

<h3 class="title" id="sigil_toc_id_43"><a id="ch01lvl3sec08"/>如何在同一个mixin中使用多个参数</h3>



<p>在前面的mixin基础上构建<a id="id31" class="indexterm"/>，让我们再添加几个参数，使其更加健壮和可扩展：</p>
<pre class="programlisting">@mixin genericContainer <strong>($padding, $bdColor, $bgColor, $boxShdColor</strong>) {
    padding: <strong>$padding;</strong>
    border: <strong>$bdColor</strong> 1px solid;
    background: <strong>$bgColor;</strong>
    box-shadow: 1px 1px 1px <strong>$boxShdColor;</strong>
}</pre>

<p>这是我们在包含mixin时声明参数的方式：</p>
<pre class="programlisting">.selector-a {
    @include genericContainer(<strong>2%, $brandBlue, #ccc, black</strong>);
}</pre>

<p>我们可以使用相同的mixin并获得不同的样式，而无需重复键入所有属性。</p>
<p>前面的mixin及其参数编译为以下代码：</p>
<pre class="programlisting">.selector-a {
    padding: <strong>2%;</strong>
    border: <strong>#416e8e</strong> 1px solid;
    background: <strong>#cccccc;</strong>
    box-shadow: 1px 1px 1px <strong>#000000;</strong>
}</pre>


<h3 class="title" id="sigil_toc_id_44"><a id="ch01lvl3sec09"/>在多个参数中设置默认值</h3>



<p>有时，我们需要定义一些默认值，以防只需要声明一个或几个<a id="id32" class="indexterm"/>参数。换句话说，通过在参数中声明默认值，我们将始终确保创建了一个值，并且在编译SCSS文件时不会出现任何错误。</p>
<p>下面是我们如何在参数中设置默认值：</p>
<pre class="programlisting">@mixin genericContainer ($padding: <strong>5px</strong>, $bdColor: <strong>orange</strong>, $bgColor: <strong>#999</strong>, $boxShdColor: <strong>#333</strong>) {
    padding: $padding;
    border: $bdColor 1px solid;
    background: $bgColor;
    box-shadow: 1px 1px 1px $boxShdColor;
}</pre>

<p>如果我们只需要声明<em>第一个</em>属性<code class="literal">padding</code>，我们可以这样做：</p>
<pre class="programlisting">.selector-a {
    @include genericContainer(25px);
}</pre>

<p>本<a id="id33" class="indexterm"/>汇编如下：</p>
<pre class="programlisting">.selector-a {
    <strong>padding: 25px;</strong>
    border: orange 1px solid;
    background: #999999;
    box-shadow: 1px 1px 1px #333333;
}</pre>

<h3 class="title" id="sigil_toc_id_45"><a id="tip13"/>提示</h3>
<p>一些Sass编译器会将速记颜色十六进制值<code class="literal">#333</code>转换为速记颜色十六进制值<code class="literal">#333333</code>。</p>


<p>我们可以看到，只有第一个参数<code class="literal">padding</code>被声明。其他参数使用了默认值并成功编译。</p>
<p>但是假设我们仍然只想声明一个参数，而不是<code class="literal">padding</code>，它是参数列表中的第一个。假设我们要声明背景色！</p>
<p>在这种情况下，我们需要通过键入变量名称来声明值：</p>
<pre class="programlisting">.selector-a { @include genericContainer(<strong>$bgColor:</strong> $brandBlue); }</pre>

<h3 class="title" id="sigil_toc_id_46"><a id="tip14"/>提示</h3>
<p>如果我们只想声明一个与第一个不同的参数，我们需要声明整个参数名。</p>


<p>有更高级的方法来声明参数，但这对于本书的范围来说已经足够了。</p>


<h2 class="title" id="sigil_toc_id_47"><a id="ch01lvl2sec12"/>在Sass中筑巢</h2>



<p>在<a id="id34" class="indexterm"/>Sass中嵌套是使我们的SCS更具可读性的完美方式。与HTML中基于父元素嵌套标记一样，Sass使用完全相同的结构。</p>
<p>以下是导航栏的两级选择器嵌套示例：</p>
<pre class="programlisting">$brandBlue: #416e8e;nav {
<strong>    ul {</strong>
<strong>        display: flex;</strong>
<strong>        margin: 0;</strong>
<strong>        padding: 0;</strong>
<strong>        list-style: none;</strong>
<strong>    }</strong>

<strong>    li {</strong>
<strong>        margin: 5px;</strong>
<strong>        background: #000;</strong>
<strong>    }</strong>
<strong>    a {</strong>
<strong>        display: block;</strong>
<strong>        padding: 5px 15px;</strong>
<strong>        text-decoration: none;</strong>
<strong>        color: $brandBlue;</strong>
<strong>    }</strong>
}</pre>

<h3 class="title" id="sigil_toc_id_48"><a id="tip15"/>提示</h3>
<p>小心深巢！最佳实践建议最多嵌套三个级别。否则，我们将遇到选择器专用性和可维护性问题。</p>


<p>您<a id="id35" class="indexterm"/>注意到我再次使用<code class="literal">$brandBlue</code>颜色变量了吗？导航栏前面的SCS编译为以下CSS：</p>
<pre class="programlisting">nav ul {
    display: flex;
    margin: 0;
    padding: 0;
    list-style: none;
}
nav li {
    margin: 5px;
    background: #000;
}
nav a {
    display: block;
    padding: 5px 15px;
    text-decoration: none;
    color: #416e8e;
}</pre>


<h2 class="title" id="sigil_toc_id_49"><a id="ch01lvl2sec13"/>Sass中的部分文件（partials）</h2>



<p>部分文件<a id="id36" class="indexterm"/>是我们创建用来存放SCSS片段的SCSS文件。Partials允许我们对文件进行模块化，例如，<code class="literal">_variables.scss</code>。分部词以下划线符号（<code class="literal">_</code>开头，以扩展名<code class="literal">.scss</code>结尾。下划线符号告诉编译器该文件及其内容不需要编译成单独的CSS文件。</p>
<p>使用<code class="literal">@import</code>指令调用分部，就像在CSS中一样。主要区别在于<a id="id37" class="indexterm"/>不需要指定下划线符号和文件扩展名。</p>
<p>让我们创建一个局部文件，并将这些颜色变量放入其中。我们将把这个部分文件称为<code class="literal">_variables.scss</code>。<code class="literal">_variables.scss</code>部分中的变量（片段）如下：</p>
<pre class="programlisting">$brandBlue: #416e8e;
$brandRed: #c03;
$brandYellow: #c90;</pre>

<p>让我们假设我们的主SCSS文件名为<code class="literal">styles.scss</code>。我们现在有两个文件：<code class="literal">styles.scss</code>和<code class="literal">_variables.scss</code>。</p>
<h3 class="title" id="sigil_toc_id_50"><a id="tip16"/>提示</h3>
<p>项目的主SCSS文件不以下划线符号开头。</p>


<p>我们使用<code class="literal">@import</code>指令将<code class="literal">_variables.scss</code>称为<code class="literal">styles.scss</code>：</p>
<pre class="programlisting">@import "variables";</pre>

<p>请注意，在引用分部时，不需要下划线符号和文件扩展名；它们可以省略。但是，如果您想添加它们，也可以。省略它们可以使代码更干净。</p>

<h2 class="title" id="sigil_toc_id_51"><a id="ch01lvl2sec14"/>Sass扩展/继承功能</h2>



<p>许多专业人士说，扩展或继承是Sass最有用的特性之一。其他人实际上建议远离它。本书的建议是：尽可能多地使用Sass，并尝试不同的特性，这样你就可以创建自己的观点。当你有足够的经验时，你可以决定加入哪一方。</p>
<p>Sass<a id="id39" class="indexterm"/>中的<strong>扩展</strong>意味着我们可以在另一个选择器中使用选择器的属性<a id="id40" class="indexterm"/>，而无需再次键入所有这些属性。这被称为<strong>继承</strong>。我们使用<code class="literal">@extend</code>指令进行此操作。</p>
<p>例如，考虑下面的选择器：</p>
<pre class="programlisting">$brandBlue: #416e8e; .generic-container {
    padding: 10px;
    border: $brandBlue 1px solid;
    background: #ccc;
    box-shadow: 1px 1px 1px rgba(black, .3);
}</pre>

<p>假设我们希望在另一个选择器上继承该选择器的所有属性。我们还将修改一个属性，因为它们几乎相同，使用<code class="literal">@extend</code>指令<a id="id41" class="indexterm"/>重用第二个选择器中第一个选择器的样式：</p>
<pre class="programlisting">.box-customer-service {
    <strong>@extend .generic-container;</strong>
    padding: 25px;
}</pre>

<p>这将编译为以下内容：</p>
<pre class="programlisting">.generic-container, .box-customer-service {
    padding: 10px;
    border: #416e8e 1px solid;
    background: #cccccc;
    box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3);
}

.box-customer-service {
    padding: 25px;
}</pre>

<p>注意<code class="literal">.generic-container</code>和<code class="literal">.box-customer-service</code>在同一条规则中；这意味着<code class="literal">.box-customer-service</code>继承了<code class="literal">.generic-container</code>的所有属性和值。然后，<code class="literal">.box-customer-service</code>有一个单独的规则，其中只声明<code class="literal">padding</code>属性，因为这是两个容器之间的唯一区别。</p>

<h2 class="title" id="sigil_toc_id_52"><a id="ch01lvl2sec15"/>Sass评论</h2>



<p>由于<a id="id42" class="indexterm"/>我们知道CSS文档是有效的SCSS文档，因此使用CSS注释语法也是有效的：</p>
<pre class="programlisting">/* This is a traditional CSS comment */</pre>

<p>在Sass中，还有另一种方式。我们可以在开头用双斜杠（<code class="literal">//</code>注释）：</p>
<pre class="programlisting">// This is a Sass-style comment</pre>

<p>这两种风格的区别在于，使用<code class="literal">/**/</code>语法的传统CSS注释会添加到编译文件中，而使用<code class="literal">//</code>的Sass注释不会添加到编译文件中。</p>
<p>带有Sass语法的注释对于记录我们的SCSS文件非常有帮助，而不必担心所有这些注释被编译并使最终的CSS文件膨胀。未编译以下示例中的Sass注释：</p>
<pre class="programlisting">$brandBlue: #416e8e; <strong>//Mixin for generic container across the app</strong>
.generic-container {
    padding: 10px;
    border: $brandBlue 1px solid;
    background: #ccc;
    box-shadow: 1px 1px 1px rgba(black, .3);
}</pre>

<p>然而，<a id="id43" class="indexterm"/>传统CSS注释确实会被编译：</p>
<pre class="programlisting">$brandBlue: #416e8e;
<strong>/* Mixin for generic container across the app */</strong>
.generic-container {
    padding: 10px;
    border: $brandBlue 1px solid;
    background: #ccc;
    box-shadow: 1px 1px 1px rgba(black, .3);
}</pre>

<h3 class="title" id="sigil_toc_id_53"><a id="tip17"/>提示</h3>
<p>现在，根据编译器上设置的选项，最终的CSS可以最小化。因此，为了优化文件大小，传统的CSS注释将被剥离。</p>



<h2 class="title" id="sigil_toc_id_54"><a id="ch01lvl2sec16"/>供应商前缀</h2>



<p>供应商<a id="id44" class="indexterm"/>前缀基本上是向CSS3属性或值添加一个特定的<em>标记</em>，该属性或值未被web开发行业和社区广泛使用，也未最终确定并包含在CSS3规范中。</p>
<p><em>供应商</em>部分是指代表创建浏览器的公司名称的缩写标记：Mozilla、Opera和Microsoft。</p>
<p>不过有一个例外，苹果。尽管苹果创建了Safari，但供应商前缀基于浏览器的布局引擎，而不是公司名称。</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mozilla:<code class="literal">-moz-</code></li>
<li class="listitem" style="list-style-type: disc">歌剧：<code class="literal">-o-</code></li>
<li class="listitem" style="list-style-type: disc">微软：<code class="literal">-ms-</code></li>
<li class="listitem" style="list-style-type: disc">网络工具包（苹果）：<code class="literal">-webkit-</code></li>
</ul>

<p><em>前缀</em>部分是指在CSS属性或CSS值之前添加供应商标签<em>的说明。每个供应商前缀仅在其自己的浏览器中工作，因此对于前面的列表，以下是它们所属的浏览器：</em></p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mozilla：这个前缀<code class="literal">-moz-</code>在Firefox中有效</li>
<li class="listitem" style="list-style-type: disc">歌剧：这个前缀<code class="literal">-o-</code>在歌剧中起作用</li>
<li class="listitem" style="list-style-type: disc">微软：这个前缀<code class="literal">-ms-</code>在Internet Explorer中有效</li>
<li class="listitem" style="list-style-type: disc">Webkit（苹果）：这个前缀<code class="literal">-webkit-</code>在Safari中起作用</li>
</ul>

<p>如果你想知道Google Chrome在这一切中的地位，这里有一个简单的解释。</p>
<p>尽管<a id="id45" class="indexterm"/>谷歌创建了Chrome，但Chrome没有特定的前缀。起初，Chrome使用的布局引擎与Safari:Webkit相同。因此，基于Webkit的前缀不仅影响Safari，还影响Chrome和其他基于Chrome的产品。</p>
<p>然而，谷歌Chrome不再使用Webkit；它现在使用自己的布局引擎Blink。然而，为了保持兼容性和避免网络进一步碎片化，Chrome仍然支持<code class="literal">-webkit-</code>前缀。</p>
<p>Opera也有类似的故事，他们有自己的布局引擎Presto，然后切换到Webkit。它现在使用闪烁。除了前面提到的浏览器供应商之外，还有其他浏览器供应商，他们也使用自己的前缀，例如带有前缀<code class="literal">-k-</code>的Konqueror浏览器。</p>
<p>以下是供应商前缀CSS属性的示例：</p>
<pre class="programlisting"><strong>-moz</strong>-box-sizing: border-box;</pre>

<p>下面是一个带前缀的CSS值示例：</p>
<pre class="programlisting">background-image: <strong>-webkit-</strong>linear-gradient(red, blue);</pre>

<h3 class="title" id="sigil_toc_id_55"><a id="ch01lvl3sec10"/>供应商前缀的顺序</h3>



<p><a id="id46" class="indexterm"/>现实是，我们可以列出供应商前缀的顺序并不重要；重要的是，我们总是将非endor前缀的版本放在末尾。</p>
<p>以线性渐变属性为例，我们应该这样做：</p>
<pre class="programlisting">*, *:before, *:after {
    background-image: -webkit-linear-gradient(red, blue);
    background-image: -moz-linear-gradient(red, blue);
    background-image: -ms-linear-gradient(red, blue);
    background-image: -o-linear-gradient(red, blue);
    background-image: linear-gradient(red, blue);
}</pre>

<h3 class="title" id="sigil_toc_id_56"><a id="tip18"/>提示</h3>
<p>如果您愿意，也可以使用<code class="literal">background: linear-gradient(red, blue);</code>。</p>


<p>nonvendor前缀声明应始终为last的原因是，如果浏览器供应商修改其前缀或放弃对其的支持，则由于级联，最后一行将始终覆盖其上方的任何内容。这使得整个CSS规则更加经得起未来的考验。此外，我们不必每次供应商更改某些内容时都重写样式表。</p>
<p>现在，许多<a id="id47" class="indexterm"/>CSS3属性和值不需要所有供应商前缀。大多数情况下，它们只需要几个厂商前缀，而其他情况下，不带前缀的属性或值就足够了。</p>
<p>但是，我们如何知道哪些CSS3属性和值可以加前缀或不加前缀，这样我们就可以创建某些传统浏览器支持的样式，而不必记住那么多信息？</p>
<p>答案是<em>自动</em>供应商前缀流程。</p>

<h3 class="title" id="sigil_toc_id_57"><a id="ch01lvl3sec11"/>自动供应商前缀</h3>



<p><a id="id48" class="indexterm"/>供应商前缀有几个问题，如果我们想让我们的一些CSS3属性在当前浏览器和/或某些旧浏览器中工作，我们就无法摆脱这些问题。供应商前缀是肮脏的工作，我们<em>不</em>必须这样做。</p>
<p>那么，我们如何在尽可能保持工作干爽的同时自动化供应商前缀的过程呢？有几种方法。</p>
<h4 class="title" id="sigil_toc_id_58"><a id="ch01lvl4sec01"/>使用罗盘</h4>



<p>Compass是一个Sass框架，可以帮助我们更高效地编写CSS。Compass有一个庞大的混合库，我们可以利用它来处理供应商前缀。</p>
<p>Compass的安装不在本书的范围之内，因此我们将重点介绍处理供应商前缀的基本用法，并假设您的计算机上已经安装了Compass。有关如何安装罗盘的详细说明，请参考<a id="id50" class="indexterm"/>罗盘现场（<a class="ulink" href="http://compass-style.org/">http://compass-style.org/ </a>。</p>
<p>安装Compass后，我们需要导入包含所需混音的特定模块。</p>
<p>继续前面使用的线性渐变示例，让我们将Compass'<code class="literal">images</code>模块导入到我们的SCSS文件中。将此文件放在主SCSS文件的顶部：</p>
<pre class="programlisting">@import "compass/css3/images";</pre>

<p>然后，我们可以使用相应的mixin：</p>
<pre class="programlisting">header {
    @include background-image(linear-gradient(red, blue));
}</pre>

<p>这将编译为以下内容：</p>
<pre class="programlisting">header {
    background-image: url('data:image/svg+xml;base64,…');
    background-size: 100%;
    background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, red), color-stop(100%, blue));
    background-image: -moz-linear-gradient(red, blue);
    background-image: -webkit-linear-gradient(red, blue);
    background-image: linear-gradient(red, blue);
}</pre>

<p>这里有一些新事物。</p>
<p>第一个声明使用base64嵌入式SVG文件。这是因为传统IEs和旧版本的Opera在渲染渐变时存在问题，因此SVG是它们的备用方案。按照今天的标准，处理这些类型的问题是完全没有必要的：</p>
<pre class="programlisting">header {
    <strong>background-image: url('data:image/svg+xml;base64,…');</strong>
    background-size: 100%;
    background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, red), color-stop(100%, blue));
    background-image: -moz-linear-gradient(red, blue);
    background-image: -webkit-linear-gradient(red, blue);
    background-image: linear-gradient(red, blue);
}</pre>

<p>使用<code class="literal">background-size: 100%;</code>参数，以便嵌入式SVG覆盖整个容器。同样，处理这样的事情只是浪费时间。此外，为了支持旧技术，我们的代码不断膨胀。考虑下一个代码块：</p>
<pre class="programlisting">header {
    background-image: url('data:image/svg+xml;base64,…');
    <strong>background-size: 100%;</strong>
    background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, red), color-stop(100%, blue));
    background-image: -moz-linear-gradient(red, blue);
    background-image: -webkit-linear-gradient(red, blue);
    background-image: linear-gradient(red, blue);
}</pre>

<p>第三个声明是只有Webkit浏览器才支持的旧CSS线性渐变语法；文件中更多不必要的代码膨胀：</p>
<pre class="programlisting">header {
    background-image: url('data:image/svg+xml;base64,…');
    background-size: 100%;
    <strong>background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, red), color-stop(100%, blue));</strong>
    background-image: -moz-linear-gradient(red, blue);
    background-image: -webkit-linear-gradient(red, blue);
    background-image: linear-gradient(red, blue);
}</pre>

<p>第四个<a id="id52" class="indexterm"/>和第五个声明基本上是针对旧的Firefox、Chrome和Safari版本的：</p>
<pre class="programlisting">header {
    background-image: url('data:image/svg+xml;base64,…');
    background-size: 100%;
    background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, red), color-stop(100%, blue));
    <strong>background-image: -moz-linear-gradient(red, blue);</strong>
<strong>    background-image: -webkit-linear-gradient(red, blue);</strong>
    background-image: linear-gradient(red, blue);
}</pre>

<p>最后一个声明是不带任何供应商前缀的建议语法：</p>
<pre class="programlisting">header {
    background-image: url('data:image/svg+xml;base64,…');
    background-size: 100%;
    background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, red), color-stop(100%, blue));
    background-image: -moz-linear-gradient(red, blue);
    background-image: -webkit-linear-gradient(red, blue);
<strong>    background-image: linear-gradient(red, blue);</strong>
}</pre>

<p>正如我们所看到的，Compass是一个非常方便的工具，它允许我们自定义输出。然而，这最终可能会超出必要的工作量。</p>
<p>在总结罗盘是否是我们最好的解决方案之前，需要考虑一些事情：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">需要安装指南针。这通常通过命令行完成。</li>
<li class="listitem" style="list-style-type: disc">一旦安装了Compass，我们就不必再使用命令行来使用它的mixin了。</li>
<li class="listitem" style="list-style-type: disc">Compass有一个庞大的mixin库，可以帮助处理供应商前缀和许多其他事情。</li>
<li class="listitem" style="list-style-type: disc">每次我们需要处理特定的CSS3属性或值时，我们都必须使用<code class="literal">@import</code>指令在主SCSS文件中导入相应的模块。这意味着我们必须花大量时间找到我们需要的模块，并学习如何使用它们。</li>
<li class="listitem" style="list-style-type: disc">使用指南针的学习曲线是中等的，我们需要在其他技术方面有点知识，才能使用指南针，即使是最基本的。</li>
<li class="listitem" style="list-style-type: disc">Compass<a id="id54" class="indexterm"/>拥有大量文档，是一个不断开发的项目。</li>
<li class="listitem" style="list-style-type: disc">有一个<a id="id55" class="indexterm"/>类似的、著名的mixin库，名为Bourbon:<a class="ulink" href="http://bourbon.io/">http://bourbon.io/ </a>。</li>
</ul>


<h4 class="title" id="sigil_toc_id_59"><a id="ch01lvl4sec02"/>使用-无前缀</h4>



<p><code class="literal">-prefix-free</code>是Lea Verou创建的JavaScript文件。当<a id="id56" class="indexterm"/>浏览器调用该脚本时，它会检测到该脚本，然后将该浏览器的特定前缀添加到CSS中。<code class="literal">-prefix-free</code>文件足够智能，可以确定需要哪些前缀，并且只注入这些前缀。</p>
<p>使用<code class="literal">-prefix-free</code>很简单。只需在JavaScript文件中添加一个调用。根据Lea Verou的建议，<a id="id57" class="indexterm"/>最好在样式表之后包含此脚本，以减少未样式内容（<strong>FOUC</strong>的<strong>闪烁。</strong></p>
<p>您可以<a id="id58" class="indexterm"/>在<a class="ulink" href="http://leaverou.github.io/prefixfree/">参观<code class="literal">-prefix-free</code>项目http://leaverou.github.io/prefixfree/ </a>。</p>
<p>由于我们的HTML很短，我们可以遵循前面提到的提示：</p>
<pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;title&gt;Page Title&lt;/title&gt;
    &lt;link href="css/styles.css" rel="stylesheet"&gt;
    <strong>&lt;script src="js/prefixfree.min.js"&gt;&lt;/script&gt;</strong>
&lt;/head&gt;
&lt;body&gt;
    Site content...
&lt;/body&gt;
&lt;/html&gt;</pre>

<p>使用这种方法当然很有诱惑力，因为调用一个简单的JavaScript文件来处理供应商前缀的自动化听起来是有史以来最好的主意。</p>
<p>让我们在决定使用Tyt T0:</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">它非常容易使用。</li>
<li class="listitem" style="list-style-type: disc">这是一个额外的HTTP请求。我们的站点/页面请求越少，请求速度就越快，因此我们为用户提供的用户体验就越好。这也有利于搜索引擎优化。</li>
<li class="listitem" style="list-style-type: disc">这是一个需要管理的额外文件。是的，一旦我们上传JavaScript文件，我们可能不需要返回到它，除非我们正在更新它，这意味着我们需要在本地运行广泛的测试，以便在生产中不会破坏任何东西。</li>
<li class="listitem" style="list-style-type: disc">由于一切都是在浏览器中发生的，因此这会给用户的浏览器带来更大的负担。</li>
<li class="listitem" style="list-style-type: disc">它在使用<code class="literal">@import</code>指令调用的文件中不起作用。这也可能被视为一件好事，因为如果我们使用<a id="id61" class="indexterm"/>导入文件，我们将面临一个不同甚至更大的问题。</li>
<li class="listitem" style="list-style-type: disc">如果我们提供的样式表来自与主站点不同的域，<code class="literal">-prefix-free</code>将无法处理这些外部CSS文件。</li>
<li class="listitem" style="list-style-type: disc">Chrome和Opera在允许<code class="literal">-prefix-free</code>在本地工作方面存在问题。尽管这很容易修复，但它只是给我们的工作流程增加了另一层复杂性。</li>
<li class="listitem" style="list-style-type: disc">如果有内联样式，一些不固定的CSS值和属性将无法在IE中工作。</li>
</ul>

<p>有了这个列表，我们现在可以更好地做出更明智的决定，这将使项目、我们自己和我们的用户受益。</p>

<h4 class="title" id="sigil_toc_id_60"><a id="ch01lvl4sec03"/>使用自动刷新器</h4>



<p>Autoprefixer是一个<em>CSS后处理器</em>，它使用CanIUse.com数据库将供应商<a id="id62" class="indexterm"/>前缀附加到已编译的CSS文件中。</p>
<p>术语<em>后处理器</em>表示在创建（post）后处理CSS<em>。换句话说，如果我们有一个名为<code class="literal">styles.scss</code>的SCSS文件，这个文件在保存后会被编译成<code class="literal">styles.css</code>。此时，Autoprefixer获取生成的<code class="literal">styles.css</code>文件，打开它，为每个属性和值添加所有必要的供应商前缀，保存文件，然后关闭它。此外，还可以将其配置为创建新的单独文件。完成后，我们可以在网站/应用程序中使用此文件。</em></p>
<p>与任何其他自动供应商前缀方法相比，此方法的主要优点<a id="id63" class="indexterm"/>是它使用CanIUse.com数据库；这意味着，一旦浏览器供应商不再需要CSS属性或值的前缀，我们所需要做的就是通过Autoprefixer运行CSS文件，它将在几秒钟内更新。</p>
<p>Autoprefixer的主要缺点是，它有太多的使用方法，对某些人来说可能有点难以承受。举几个例子，我们可以通过命令行使用它，但我们需要先安装<code class="literal">Node.js</code>：</p>
<pre class="programlisting">npm install --global autoprefixer
autoprefixer *.css</pre>

<p>我们也可以将Autoprefixer与Compass一起使用，但我们需要先安装Ruby：</p>
<pre class="programlisting">gem install autoprefixer-rails</pre>

<p>我们可以在Mac上使用CodeKit，在Windows/Mac/Linux上使用Prepos或考拉应用程序。我们还可以为Sublime文本、方括号或Atom编辑器安装插件。还有咕噜和咕噜的插件。</p>
<p>让我们在决定使用Autoprefixer之前先看一小部分要考虑的事情：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">事实上，它使用CanIUse.com数据库是迄今为止与任何其他自动供应商前缀应用程序相比的最佳功能和优势，因为我们始终可以确保我们的CSS文件具有最新的前缀，或者如果浏览器供应商删除了任何前缀，则没有前缀。</li>
<li class="listitem" style="list-style-type: disc">它可以集成到许多应用程序中。</li>
<li class="listitem" style="list-style-type: disc">对于新的web设计师或开发人员来说，安装它可能有点让人望而生畏。</li>
<li class="listitem" style="list-style-type: disc">Autoprefixer预装在其他应用程序中，所以我们只需运行这些应用程序，就可以自动使用Autoprefixer，而无需进行任何设置。</li>
</ul>

<p>Autoprefixer<a id="id66" class="indexterm"/>可从<a class="ulink" href="https://github.com/postcss/autoprefixer">下载https://github.com/postcss/autoprefixer </a>。</p>

<h4 class="title" id="sigil_toc_id_61"><a id="ch01lvl4sec04"/>使用Pleeease</h4>



<p>是的，是<em>请用</em>加上三个<em>e</em>。Pleease也是一个类似于Autoprefixer的CSS后处理器，它还依赖于安装了<code class="literal">Node.js</code>。它只通过命令行运行，但实际上非常简单。Pleease使用Autoprefixer，这意味着它还使用CanIUse.com数据库来定义哪些CSS属性和/或值需要前缀。</p>
<p>安装Pleease后，我们需要创建一个配置文件（JSON文件），其中最重要的是定义源CSS文件和目标CSS文件：</p>
<pre class="programlisting">{
    "in": "style.css",
    "out": "styles.fixed.css"
}</pre>

<p>一旦设置了该配置文件，我们将在命令行中运行：</p>
<pre class="programlisting">pleeease compile</pre>

<p>请获取<code class="literal">style.css</code>文件，添加所有必要的供应商前缀，并创建<code class="literal">styles.fixed.css</code>，这是我们在生产中使用的文件。</p>
<p>在这一点上，Pleease还做了其他重要的事情：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">将相同的媒体查询编译成一个<code class="literal">@media</code>块</li>
<li class="listitem" style="list-style-type: disc">Inlines<code class="literal">@import</code>样式表（这很好，因为我们最终只有一个CSS文件用于生产）</li>
<li class="listitem" style="list-style-type: disc">缩小/压缩最终文件</li>
</ul>

<p>如果您对使用命令行和JSON文件感到满意，Pleease将是您的武器库中非常有用的一部分。如果您喜欢远离命令行，那也没关系；还有其他更友好的方法可以自动为供应商添加前缀。</p>
<p>这里有一些事情要考虑，然后再决定席是否是自动化厂商前缀的方法：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">安装和使用它需要使用命令行，但是命令非常简单。</li>
<li class="listitem" style="list-style-type: disc">它使用JSON文件来配置其设置。</li>
<li class="listitem" style="list-style-type: disc">它使用Autoprefixer，这意味着它也使用CanIUse.com数据库。这使得它在了解哪些属性和/或值需要或不需要前缀时具有难以置信的强大功能。</li>
<li class="listitem" style="list-style-type: disc">它对最终的CSS文件进行了其他一些改进，例如将相同的媒体查询打包到一个<code class="literal">@media</code>规则中，缩小结果，等等。</li>
<li class="listitem" style="list-style-type: disc">它可以与Grunt、Gulp、Brunch和Node.js工作流集成。</li>
</ul>

<p>您可以<a id="id70" class="indexterm"/>从<a class="ulink" href="http://pleeease.io/">下载http://pleeease.io/ </a>。</p>

<h4 class="title" id="sigil_toc_id_62"><a id="ch01lvl4sec05"/>使用Emmet</h4>



<p>Emmet允许我们更快地编写CSS和HTML。它是一个用于文本编辑器的插件，如Sublime text、Coda、TextMate，甚至Dreamweaver。</p>
<p>Emmet还帮助我们为CSS3属性和值添加供应商前缀，这是我们将在下面的示例中重点关注的内容。</p>
<h3 class="title" id="sigil_toc_id_63"><a id="tip19"/>提示</h3>
<p>埃米特过去被称为<em>禅宗编码</em>。</p>


<p>在我们最喜欢的文本编辑器中安装Emmet插件后，我们在SCSS文件中键入以下内容：</p>
<pre class="programlisting">.selector-a {
    -trf
}</pre>

<h3 class="title" id="sigil_toc_id_64"><a id="tip20"/>提示</h3>
<p><code class="literal">-trf</code>是CSS3属性<em>转换</em>的缩写。</p>


<p>然后我们按下键盘上的<em>键</em>，代码自动变为：</p>
<pre class="programlisting">.selector-a {
    -webkit-transform:;
    -ms-transform:;
    -o-transform:;
    transform:;
}</pre>

<p>我们<a id="id72" class="indexterm"/>只需在缩写词开头加上破折号（<code class="literal">-</code>即可添加供应商前缀。这告诉Emmet，当点击<em>键</em>时，需要添加必要的供应商前缀。</p>
<h3 class="title" id="sigil_toc_id_65"><a id="tip21"/>提示</h3>
<p>在前面的示例中未定义变换值，因为我们希望显示使用Emmet的结果。显然，我们最终必须添加这些值。</p>


<p>这里有几个席要考虑的问题，然后决定使用Emmet自动化供应商前缀：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">由我们来定义什么加前缀，什么不加前缀，所以我们可能最终会给不再需要加前缀的属性和值加前缀。因此，我们最终会使CSS文件膨胀。</li>
<li class="listitem" style="list-style-type: disc">如果我们忘记在属性/值的开头添加破折号，那么它就不会加前缀，而且可能该属性/值确实需要加前缀。因此，我们将花费更多的时间进行故障排除。</li>
<li class="listitem" style="list-style-type: disc">Emmet与最流行的文本编辑器一起工作，所以我们有可能使用它。</li>
<li class="listitem" style="list-style-type: disc">使用Emmet的学习曲线非常低。</li>
<li class="listitem" style="list-style-type: disc">Emmet不依赖于命令行的使用。</li>
<li class="listitem" style="list-style-type: disc">Emmet<a id="id74" class="indexterm"/>拥有大量文档，并在不断开发中。</li>
</ul>

<p>您可以<a id="id75" class="indexterm"/>从<a class="ulink" href="http://emmet.io/">下载Emmethttp://emmet.io/ </a>。</p>

<h4 class="title" id="sigil_toc_id_66"><a id="ch01lvl4sec06"/>使用第三方应用程序</h4>



<p>正如我们<a id="id76" class="indexterm"/>所看到的，以前用于自动供应商前缀的方法到处都是，从通过命令行使用的方法到让您在能够使用JavaScript解决方案之前找到要导入的特定模块的方法。</p>
<p>提到的所有功能中最重要的是Autoprefixer使用CanIUse.com数据库。这正是我们想要使用的，因为我们所需要做的就是编写CSS3属性和值，完全忘记供应商前缀，让AutoRefixer和CanIUse.com为我们添加它们。</p>
<p>幸运的是，有一些第三方应用程序已经安装了Autoprefixer。这意味着我们不必通过命令行设置任何东西，也不必安装插件或类似的东西。只需安装应用程序，激活Autoprefixer复选框，然后我们就可以开始了！</p>
<p>我们之前提到过几个应用程序：CodeKit、Prepos和考拉应用程序。他们基本上都做相同的事情，但他们擅长两件事：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">他们可以<em>观看</em>我们的SCSS文件并为我们编译它们。</li>
<li class="listitem" style="list-style-type: disc">他们可以通过Autoprefixer自动添加供应商前缀。</li>
</ul>

<p>这两个特性对我们的工作流程有着巨大的影响，使我们能够将精力集中在重要的事情上，比如RWD和更好的用户体验。</p>
<p>然而，在决定第三方应用席是否是厂商前缀的最佳解决方案之前，有一些事情要考虑：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Prepos和CodeKit是付费应用程序。考拉是免费的，但支持作者的一小笔捐款表明了对他的工作的赞赏。但是，它们无论如何都不昂贵；当我们第一次编译一个文件时，它的好处是我们的几十倍。</li>
<li class="listitem" style="list-style-type: disc">它们非常容易设置。</li>
<li class="listitem" style="list-style-type: disc">他们有很好的文档、社区，并且由作者不断开发。</li>
<li class="listitem" style="list-style-type: disc">对于许多使用CSS和HTML的非前端开发人员来说，这些应用程序允许他们专注于其他重要的事情，如用户体验、设计、可用性和SEO，而不必担心JSON文件、命令行、插件等。</li>
</ul>


<h4 class="title" id="sigil_toc_id_67"><a id="ch01lvl4sec07"/>推荐的供应商前缀方法</h4>



<p>这本<a id="id78" class="indexterm"/>书建议您使用CodeKit、Prepos或Koala应用程序来处理供应商前缀。这些应用程序不仅编译SCSS文件，而且在保存这些SCSS文件时，还会通过Autoprefixer自动运行这些文件。</p>
<p>让我们看看PROPROs，它可以运行在最流行的操作系统，如Windows、Linux和MAC。</p>



<h2 class="title" id="sigil_toc_id_68"><a id="ch01lvl2sec17"/>使用第三方程序编译</h2>



<p>使用<a id="id79" class="indexterm"/>命令行编译我们的SCSS文件其实并不难：</p>
<pre class="programlisting"><strong>--sass watch scss:css</strong>
</pre>

<p>这就是我们在命令行中需要做的，让Sass监视<code class="literal">/scss</code>文件夹中的SCSS文件，并将它们编译到<code class="literal">/css</code>文件夹中。其实就是这么简单。</p>
<p>前一种情况的问题是，每次我们必须处理不同的项目时，都需要运行此命令。尽管我们可以通过许多不同的方式实现自动化，但有些人发现命令行的使用要么令人望而生畏，要么根本没有必要。</p>
<h3 class="title" id="sigil_toc_id_69"><a id="ch01lvl3sec12"/>Prepos应用程序</h3>



<p>Prepos是一款面向web设计师和开发人员的工具，用于处理常规工作流的许多部分：编译、CSS前缀、实时刷新、JavaScript连接、文件缩小、优化图像、浏览器测试同步、编译文件的源地图创建、内置服务器、FTP等。</p>
<p>在本书中，我们将重点介绍它如何帮助我们编译SCSS文件，同时自动添加供应商前缀。</p>
<p>您可以<a id="id81" class="indexterm"/>从<a class="ulink" href="https://prepros.io/">下载https://prepros.io/ </a>。Prepos是一种付费应用程序。然而，花29美元并不会让银行破产。我向您保证，在第一次编译之后，这个应用程序将自行付费。</p>
<p>还有一种方法可以免费使用Prepos并享受应用程序的所有功能。然而，这是以每5分钟关闭<em>购买应用程序</em>弹出窗口为代价的。</p>
<p>这是Prepos当前的欢迎屏幕（现在可能已更改）：</p>
<p><img src="graphics/B02102_01_10.jpg" alt="The Prepros app"/></p>
<p>还记得<a id="id82" class="indexterm"/>安装Sass的步骤吗？我们在其中创建了一个<code class="literal">/Demo</code>文件夹并创建了两个子文件夹<code class="literal">/scss</code>和<code class="literal">/css</code>？我们将把<code class="literal">/Demo</code>文件夹拖放到Prepos界面上：</p>
<p><img src="graphics/B02102_01_11.jpg" alt="The Prepros app"/></p>
<p>一张悲伤的脸出现了，让我们知道这个项目是空的。这是真的，因为我们没有向<code class="literal">/scss</code>文件夹添加任何文件：</p>
<p><img src="graphics/B02102_01_12.jpg" alt="The Prepros app"/></p>
<p>那么，让我们<a id="id84" class="indexterm"/>创建一个。<code class="literal">/scss</code>文件夹中的<code class="literal">scss</code>文件：</p>
<p><img src="graphics/B02102_01_13.jpg" alt="The Prepros app"/></p>
<p>prepos<a id="id85" class="indexterm"/>会自动检测新的<code class="literal">styles.scss</code>文件并编译生成<code class="literal">styles.css</code>文件，保存在<code class="literal">/css</code>文件夹中。</p>
<p><img src="graphics/B02102_01_14.jpg" alt="The Prepros app"/></p>
<p>点击<code class="literal">styles.scss</code>文件上的<a id="id86" class="indexterm"/>按钮将显示该文件的默认设置：</p>
<p><img src="graphics/B02102_01_15.jpg" alt="The Prepros app"/></p>
<p>让我们修改<a id="id87" class="indexterm"/>其中的一些设置，以便Prepos可以自动执行以下操作：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">添加供应商前缀。</li>
<li class="listitem" style="list-style-type: disc">创建源地图。</li>
<li class="listitem" style="list-style-type: disc">不压缩我们编译的CSS（至少现在是这样）。</li>
</ul>

<h3 class="title" id="sigil_toc_id_70"><a id="tip22"/>提示</h3>
<p><code class="literal">source map</code>是一个扩展名为<code class="literal">.map</code>的文件，它与我们的CSS文件一起生成。此映射文件包含必要的信息，这些信息将CSS文件的每一行链接到SCSS文件和部分中相应的行。当我们需要通过任何现代web浏览器的开发工具检查元素的样式时，这一点至关重要。</p>


<p>在<strong>输出样式</strong>部分，我们将把设置保留为<strong>扩展</strong>。</p>
<p><img src="graphics/B02102_01_16.jpg" alt="The Prepros app"/></p>
<p>四种输出风格之间的<a id="id88" class="indexterm"/>差异很简单：</p>
<h4 class="title" id="sigil_toc_id_71"><a id="ch01lvl4sec08"/>扩大产量</h4>



<p>这是<a id="id89" class="indexterm"/>传统的CSS样式，其中每个选择器、属性和值位于单独的行中：</p>
<pre class="programlisting">header {
    background: blue;
}
header .logo {
    float: left;
}
.container {
    float: right;
}</pre>


<h4 class="title" id="sigil_toc_id_72"><a id="ch01lvl4sec09"/>嵌套输出</h4>



<p>您可以看到<a id="id90" class="indexterm"/>第二条规则是缩进的，这意味着它属于<code class="literal">header</code>选择器：</p>
<pre class="programlisting">header {
    background: blue;
}
    header .logo {
       float: left;
  }
.container {
    float: right;
}</pre>


<h4 class="title" id="sigil_toc_id_73"><a id="ch01lvl4sec10"/>紧凑型输出</h4>



<p>所有规则都驻留在<a id="id91" class="indexterm"/>一行中，如下所示：</p>
<pre class="programlisting">header { background: blue; }
header .logo { float: left; }
.container { float: right; }</pre>


<h4 class="title" id="sigil_toc_id_74"><a id="ch01lvl4sec11"/>压缩输出</h4>



<p>此<a id="id92" class="indexterm"/>为缩小版，是我们在生产中应该使用的版本：</p>
<pre class="programlisting">header{background:blue;}header .logo{float:left;}.container{float:right;}</pre>

<p>就这样。我们现在让prepos运行。它将添加所有供应商前缀，并在每次保存时编译SCSS文件。让我们看看这一行动。</p>

<h4 class="title" id="sigil_toc_id_75"><a id="ch01lvl4sec12"/>添加一些CSS，让Prepos应用程序完成剩下的工作！</h4>



<p>每次<a id="id93" class="indexterm"/>点击<strong>保存</strong>时，预印本将在屏幕右下角显示以下任一对话框。</p>
<p><strong>成功</strong>将为我们提供以下输出：</p>
<p><img src="graphics/B02102_01_17.jpg" alt="Add some CSS and let the Prepros app do the rest!"/></p>
<p><strong>错误</strong>将给我们以下输出：</p>
<p><img src="graphics/B02102_01_18.jpg" alt="Add some CSS and let the Prepros app do the rest!"/></p>
<p>让我们以<a id="id94" class="indexterm"/>我们的<code class="literal">styles.scss</code>文件为例，添加一个简单的CSS规则，它需要一些供应商前缀。</p>
<p><img src="graphics/B02102_01_19.jpg" alt="Add some CSS and let the Prepros app do the rest!"/></p>
<p>当我们保存<code class="literal">styles.scss</code>文件时，Prepos会显示绿色/成功对话框，并将我们的SCSS文件编译为<code class="literal">styles.css</code>。</p>
<p>这是编译文件的外观，所有前缀都自动添加：</p>
<p><img src="graphics/B02102_01_20.jpg" alt="Add some CSS and let the Prepros app do the rest!"/></p>

<h4 class="title" id="sigil_toc_id_76"><a id="ch01lvl4sec13"/>定义要支持多少传统浏览器版本作为前缀</h4>



<p>随着浏览器的发展，CSS3属性和值被标准化，其中较少的属性和值需要<a id="id95" class="indexterm"/>供应商前缀。我们的CSS文件应该反映这一点，这样我们就不会用不必要的前缀填充样式表。</p>
<p>Prepos允许我们定义在应用前缀时要支持多少传统浏览器版本。步骤如下：</p>
<ol class="orderedlist arabic"><li class="listitem">Click on the <strong>MORE OPTIONS</strong> menu at the top:<p><img src="graphics/B02102_01_21.jpg" alt="Defining how many legacy browser versions to support for prefixing"/></p></li>
<li class="listitem">Click on <strong>Project Options</strong> from the drop-down menu:<p><img src="graphics/B02102_01_22.jpg" alt="Defining how many legacy browser versions to support for prefixing"/></p></li>
<li class="listitem">Click <a id="id96" class="indexterm"/>on the <strong>CSS</strong> menu option:<p><img src="graphics/B02102_01_23.jpg" alt="Defining how many legacy browser versions to support for prefixing"/></p></li>
<li class="listitem">Scroll <a id="id97" class="indexterm"/>all the way to the bottom and type the number <code class="literal">2</code> in the <strong>AutoPrefixer</strong> field:<p><img src="graphics/B02102_01_24.jpg" alt="Defining how many legacy browser versions to support for prefixing"/></p></li>
<li class="listitem">Once this<a id="id98" class="indexterm"/> is done, save the <code class="literal">styles.scss</code> file. We'll see that the CSS3 linear gradient property doesn't really need to be prefixed after Prepros compiles the CSS file:<p><img src="graphics/B02102_01_25.jpg" alt="Defining how many legacy browser versions to support for prefixing"/></p></li>
</ol>

<h3 class="title" id="sigil_toc_id_77"><a id="tip23"/>提示</h3>
<p>如果无法看到开头前缀为“线性渐变”的属性，请尝试将该值更改为非常高的值，例如<code class="literal">40</code>，使其显示为<em>最后40个版本的</em>。保存SCSS文档并再次检查CSS文件。</p>


<p>就这些。</p>


<h3 class="title" id="sigil_toc_id_78"><a id="ch01lvl3sec13"/>仅一个编译器</h3>



<p>在我们继续之前，有一个非常重要的注意事项。到目前为止，我们已经讨论过通过<code class="literal">--watch</code>标志使用命令行，以及使用预处理程序编译我们的SCSS文件。请注意，<em>在任何给定时间只需要运行一个编译器</em>。不需要让CMD和PREPO编译相同的SCSS文件。</p>


<h2 class="title" id="sigil_toc_id_79"><a id="ch01lvl2sec18"/>Sass加入我们的媒体询问</h2>



<p>有很多方法可以创建Sass mixin来容纳媒体查询：只有变量的mixin，不支持媒体查询的旧浏览器的<em>无查询的mixin，以及断点等插件（用于Compass）。还有其他技术，例如命名媒体查询。另一种技术是简单的三线混音，它可以为我们想要的任何东西工作。</em></p>
<p>他们都很好，而且非常强大。然而，在本书的范围内，我们将重点介绍两种简单的方法，它们将使我们变得高效、简单，并利用mixin的强大功能。</p>
<p>到目前为止，您对Sass的所有了解，特别是关于mixin的部分，最终将创建一个部分文件，用于存储我们对RWD的媒体查询。</p>
<p>请记住，部分文件是我们创建用来存放SCSS代码段的SCSS文件。它们的文件名以下划线符号开头，以扩展名<code class="literal">.scss</code>结尾。</p>
<h3 class="title" id="sigil_toc_id_80"><a id="ch01lvl3sec14"/>媒体查询混入方式</h3>



<p><a id="id102" class="indexterm"/>命名媒体查询和断点的方法与web设计师和前端开发人员的方法一样多。每个人都有自己的方式和风格。</p>
<p>无论您使用何种方法，重要的是开始使用Sass mixin来自动化此过程。当我们建立网站或应用程序并成为更好的网页设计师/前端开发人员时，我们会发现其他解决方案可能工作得更好。</p>
<p>有几种方法可以命名媒体查询混合：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">让内容定义断点。换句话说，当您在测试期间调整浏览器窗口的大小时，您会看到内容中断或无法以理想、清晰的方式显示bam！创建断点（这是推荐的方法）。</li>
<li class="listitem" style="list-style-type: disc">使用抽象名称（如<code class="literal">small</code>、<code class="literal">medium</code>和<code class="literal">large</code>或<code class="literal">s</code>、<code class="literal">m</code>和<code class="literal">l</code>进行媒体名称查询。</li>
<li class="listitem" style="list-style-type: disc">使用特定于设备的名称（我不建议使用此方法）。</li>
</ul>

<p>在这本书中，我们将只关注前面列表中提到的第一种和第二种方法。</p>
<h4 class="title" id="sigil_toc_id_81"><a id="ch01lvl4sec14"/>让内容定义断点</h4>



<p>因为<a id="id104" class="indexterm"/>我们不知道我们的内容会在哪里被破坏，我们需要一个初始的混合，我们可以在构建我们的响应性网站/应用时为其添加价值，我们将从一些已知的、宽度特定的价值开始。了解这些值可能会发生很大的变化，许多其他值将添加到此mixin中。</p>
<p>我们将把这个文件命名为<code class="literal">_mediaqueries.scss</code>。媒体查询mixin如下所示：</p>
<pre class="programlisting">//Mobile-first
@mixin minw($point) {
    @if $point == 320 {
      @media (min-width:  20em) { @content; }
    }
    @else if $point == 640 {
      @media (min-width:  40em) { @content; }
    }
    @else if $point == 768 {
      @media (min-width:  47.5em) { @content; }
    }
}</pre>

<p>这是我们在主SCSS文件中使用mixin的方式：</p>
<pre class="programlisting">header {
    width: 50%; //Properties for small screens
    background: red;
      <strong>@include minw(640) {</strong>
<strong>          width: 100%; //Properties for large screens</strong>
<strong>          background: blue;</strong>
<strong>  }</strong>
}</pre>

<p>这就是mixin编译的目的：</p>
<pre class="programlisting">header {
    width: 50%;
    background: red;
}
<strong>@media (min-width: 40em) {</strong>
<strong>    header {</strong>
<strong>      width: 100%;</strong>
<strong>      background: blue;</strong>
<strong>    }</strong>
<strong>}</strong>
</pre>

<p>在本书的<a id="id105" class="indexterm"/>媒体查询示例中，我们将以<code class="literal">em</code>单位而不是像素来声明宽度值。这是因为使用<code class="literal">em</code>有助于更好地缩放所有值，与屏幕密度无关。让我们看看这里发生了什么。</p>
<h5 class="title" id="sigil_toc_id_82"><a id="ch01lvl5sec01"/>混合</h5>



<p>首先，我们<a id="id106" class="indexterm"/>看到了Sass风格的评论，其中描述了此mixin用于移动优先的方法：</p>
<pre class="programlisting">//Mobile-first</pre>

<p>然后，我们有了开放<code class="literal">@mixin</code>指令。本指令包含mixin的名称<code class="literal">minw</code>，是<em>最小宽度</em>的缩写。我们将保持这个名称的简单性，因为我们将大量地键入它，因此在保持一个有意义的术语的同时，键入<code class="literal">minw</code>比键入<em>最小宽度</em>更快。</p>
<p>在括号中，我们有一个<code class="literal">($point)</code>参数，它将存储我们在定义要使用的断点时指定的值：</p>
<pre class="programlisting">@mixin minw($point)</pre>

<p>然后，我们有一个开场白。还记得我们说过Sass是一种编程/脚本语言吗？有什么比<code class="literal">if-else</code>语句更能代表编程语言？</p>
<p><code class="literal">@if</code>语句后面跟着<code class="literal">$point</code>变量，该变量等于（<code class="literal">==</code>320像素宽。两个等号（<code class="literal">==</code>表示绝对等于该值，即<code class="literal">320</code>：</p>
<pre class="programlisting">@if $point == 320</pre>

<p>在那之后，我们有了CSS<code class="literal">@media</code>指令，我们已经见过很多次了。在本指令中，我们在<code class="literal">em</code>中指定宽度，在第一种情况下为<code class="literal">20em</code>。</p>
<pre class="programlisting">@media (min-width:  20em)</pre>

<p>然后，我们有<code class="literal">@content</code>指令，允许我们将任何内容放在括号之间：</p>
<pre class="programlisting">@media (min-width:  20em) { @content; }</pre>

<p>后面是带有<code class="literal">$point</code>变量的<code class="literal">@else</code>语句、两个等号（<code class="literal">==</code>符号）和<code class="literal">640</code>值。如果定义的值是<code class="literal">640</code>而不是<code class="literal">320</code>，那么mixin可以继续使用这个特定的媒体查询640像素的宽度。</p>
<pre class="programlisting">@else if $point == 640</pre>

<p>这意味着640像素为<code class="literal">40em</code>：</p>
<pre class="programlisting">@media (min-width:  40em) { @content; }</pre>

<p>最后，对于768像素的宽度，我们有相同的媒体查询结构。768像素与<code class="literal">47.5em</code>相同。</p>
<p>在选择允许内容定义断点的方法之前，请考虑以下几点：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">使用特定宽度值（记住，这些值是基于内容的）作为媒体查询名称（320、640或768）的好处在于，当我们使用mixin时，我们真正知道我们的目标是什么特定宽度。</li>
<li class="listitem" style="list-style-type: disc">这意味着无论我们有多少个断点，我们总是知道我们的目标宽度。</li>
<li class="listitem" style="list-style-type: disc">我们可以根据需要设置任意多的断点，而且我们永远不必返回mixin来提醒我们哪个名称属于哪个宽度。</li>
</ul>



<h4 class="title" id="sigil_toc_id_83"><a id="ch01lvl4sec15"/>命名媒体查询</h4>



<p>这是许多前端开发人员的最爱。这个混音几乎和我们刚才看到的一样；不同之处在于，该mixin使用设备特定宽度的抽象名称，而不是使用特定宽度，并且知道这些宽度将发生变化，其他宽度将被添加，并且通常有一个已定义的断点列表。</p>
<p>下面是这个mixin的样子：</p>
<pre class="programlisting">//Mobile-first
@mixin breakpoint($point) {
    @if $point == small {
        @media (min-width:  20em) { @content; }
    }
    @else if $point == medium {
        @media (min-width:  40em) { @content; }
    }
    @else if $point == large {
        @media (min-width:  48em) { @content; }
    }
}</pre>

<p>我们就是这样使用它的：</p>
<pre class="programlisting">header {
    width: 50%; //Properties for small screens
    background: red;
    <strong>@include breakpoint(medium) {</strong>
<strong>        width: 100%; //Properties for large screens</strong>
<strong>        background: blue;</strong>
<strong>    }</strong>
}</pre>

<p>这是<a id="id109" class="indexterm"/>它看起来的样子：</p>
<pre class="programlisting">header {
    width: 50%;
    background: red;
}
<strong>@media (min-width: 40em) {</strong>
<strong>    header {</strong>
<strong>        width: 100%;</strong>
<strong>        background: blue;</strong>
<strong>    }</strong>
<strong>}</strong>
</pre>

<p>在选择命名媒体查询方法之前，请考虑以下几点：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">如果有许多断点，则抽象名称的使用可能会令人困惑。</li>
<li class="listitem" style="list-style-type: disc">在某个时刻，你要么会用完抽象名称，要么有太多的抽象名称，以至于你无法真正记住哪个名称属于哪个宽度。</li>
</ul>


<h4 class="title" id="sigil_toc_id_84"><a id="ch01lvl4sec16"/>基本混合物</h4>



<p>这是<a id="id110" class="indexterm"/>在处理媒体查询时推荐使用的mixin，它<a id="id111" class="indexterm"/>具有以下优点：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">它允许我们在定义宽度时以像素为单位进行思考，但输出是以相对单位（<code class="literal">em</code>。</li>
<li class="listitem" style="list-style-type: disc">它很容易理解和扩展。</li>
<li class="listitem" style="list-style-type: disc">如果我们使用桌面优先的方法，我们需要做的就是将mixin名称从<code class="literal">mobileFirst</code>更改为<code class="literal">desktopFirst</code>，并将<code class="literal">min-width</code>关键字更改为<code class="literal">max-width</code>。</li>
<li class="listitem" style="list-style-type: disc">如果我们想使用基于像素的宽度，我们只需要从分区中删除<code class="literal">16</code>：<code class="literal">/16+em</code>。</li>
<li class="listitem" style="list-style-type: disc">因为它不使用命名变量来表示不同的宽度，所以不需要记住哪个命名变量对应于哪个宽度。</li>
<li class="listitem" style="list-style-type: disc">我们永远不会用完命名变量，因为它不使用它们。</li>
</ul>

<p>现在，考虑到我们的建议是让内容定义断点，这里是mixin：</p>
<pre class="programlisting">@mixin mobileFirst($media) {
    @media (min-width: $media/16+em) { @content; }
}</pre>

<p>就这样，仅仅是三线混音。我们就是这样使用它的：</p>
<pre class="programlisting">header {
    width: 50%; //Properties for small screensbackground: red;
    <strong>@include mobileFirst(640) {</strong>
<strong>        width: 100%; //Properties for large screensbackground: blue;</strong>
<strong>   }</strong>
}</pre>

<p>这就是它编译的目的：</p>
<pre class="programlisting">header {
    width: 50%;background: red;
}
@media (min-width: 40em) {
    header {
      width: 100%;background: blue;
  }
}</pre>

<p>现在，你可能会问自己，<code class="literal">em</code>值从何而来</p>
<p>很简单。我们把所需的宽度除以16。我们除以16的原因是因为<code class="literal">16px</code>是所有浏览器的默认字体大小。通过这样做，我们得到的值以<code class="literal">em</code>为单位。</p>
<p>如果您想使用Endot0}作为默认字体大小，请考虑以下示例：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>320px/16px=20em</em></li>
<li class="listitem" style="list-style-type: disc"><em>640px/16px=40em</em></li>
<li class="listitem" style="list-style-type: disc"><em>768px/16px=47.5em</em></li>
</ul>

<p>如果您决定您的默认字体大小不是<code class="literal">16px</code>，而是<code class="literal">18px</code>，那么同样的过程也适用。将所需宽度除以<code class="literal">18px</code>：</p>
<ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>320px/18px=17.77em</em></li>
<li class="listitem" style="list-style-type: disc"><em>640px/18px=35.55em</em></li>
<li class="listitem" style="list-style-type: disc"><em>768px/18px=42.66em</em></li>
</ul>

<p>选择权在你。</p>
<h3 class="title" id="sigil_toc_id_85"><a id="tip24"/>提示</h3>
<p>我们所有的<a id="id113" class="indexterm"/>示例都将基于<code class="literal">16px</code>默认字体大小。</p>






<h1 class="title" id="sigil_toc_id_86"><a id="ch01lvl1sec10"/>总结</h1>



<p>这一章我们讲了很多，但最好的还在后面。我们学习了如何安装Sass以及如何让它<em>监视</em>我们的SCSS文件。我们还了解到有两种不同的语法：Sass和SCSS。我们现在知道任何CSS文件都是有效的SCSS文件，如果我们现在知道如何编写CSS，我们也知道如何编写SCSS。我们讨论了Sass的不同基本概念，如变量、混合、参数、嵌套、部分文件、<code class="literal">@import</code>指令、源映射和Sass注释。</p>
<p>我们还了解了什么是供应商前缀，以及有助于自动化此过程的不同方法。我们决定使用prepos来完成以下任务：监视、编译SCSS文件和自动化前缀。我们学会了创建一个名为<code class="literal">_mediaqueries.scss</code>的部分文件来容纳我们的媒体查询。我们还学习了使用基本mixin命名媒体查询的不同方法，它向我们展示了在坚持让内容定义断点的最佳实践的同时处理媒体查询是多么简单。</p>
<p>在下一章中，我们将深入研究HTML5，以及如何标记我们的内容，为RWD做准备。准备好你的通气管！</p>

</body>
</html>