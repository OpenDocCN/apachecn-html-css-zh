# 附录 b .帆布安全

为了保护您网站上的图像、视频和画布的像素数据，HTML5 画布规范有适当的保护措施来防止来自其他域的脚本访问这些媒体，操纵它们，然后创建新的图像、视频或画布。

在画布上绘制任何东西之前，画布标签有一个设置为 true 的原点清除标志。这基本上意味着画布是“干净”的。如果您在画布上绘制一个图像，该图像与运行它的代码驻留在同一个域中，那么 origin-clean 标志仍然为真。但是，如果您在另一个域的画布上绘制图像，那么 origin-clean 标志将设置为 false，画布现在是“脏”的。

根据 HTML5 画布规范，在以下任何动作发生时，画布都被认为是脏的:

*   元素的 2D 上下文的 `drawImage()`方法是用 `HTMLImageElement`或 `HTMLVideoElement`调用的，它们的来源与拥有画布元素的文档对象的来源不同。
*   元素的 2D 上下文的 `drawImage()`方法是用一个 `HTMLCanvasElement`调用的，它的原点-干净标志是假的。
*   元素的 2D 上下文的 `fillStyle`属性被设置为从 `HTMLImageElement`或 `HTMLVideoElement`创建的 `CanvasPattern`对象，其原点与创建图案时拥有画布元素的文档对象的原点不同。
*   元素的 2D 上下文的 `fillStyle`属性被设置为一个 `CanvasPattern`对象，该对象是从一个 `HTMLCanvasElement`创建的，当创建模式时，该对象的原点清除标志为假。
*   元素的 2D 上下文的 `strokeStyle`属性被设置为从 `HTMLImageElement`或 `HTMLVideoElement`创建的 `CanvasPattern`对象，其原点与创建图案时拥有画布元素的文档对象的原点不同。
*   元素的 2D 上下文的 `strokeStyle`属性被设置为一个 `CanvasPattern`对象，该对象是从一个 `HTMLCanvasElement`创建的，当创建模式时，该对象的原点清除标志为假。
*   调用元素的 2D 上下文的 `fillText()`或 `strokeText()`方法，并考虑使用与拥有画布元素的文档对象的字体不同的字体。(字体甚至不用；所有重要的是字体是否被考虑用于任何绘制的字形。)

此外，如果您在本地计算机(不是 web 服务器)上执行这些操作中的任何一个，那么 origin-clean 标志将自动设置为 false，因为资源将被视为来自不同的来源。

接下来，根据规范，如果这些动作中的任何一个发生在脏画布上，将引发 `SECURITY_ERR`异常:

*   `toDataURL()`法称为
*   `getImageData()`法称为
*   `measureText()`方法用于原点与文档对象不同的字体

尽管 canvas 安全规范是出于良好的意图而创建的，但它可能会让我们更加头疼。举个例子，假设您想要创建一个绘图应用程序，该应用程序与 Flickr API 挂钩，从公共域中提取图像添加到您的绘图中。如果您希望您的应用程序能够使用 `toDataURL()`方法将该绘图保存为图像，或者希望您的应用程序使用 `getImageData()`方法拥有精美的像素操作算法，那么您就有麻烦了。在脏画布上执行这些操作会抛出一个 JavaScript 错误，并阻止应用程序正常工作。

规避这个问题的一种方法是创建一个代理，从另一个域获取图像，然后将其传递回客户端，使其看起来好像图像来自您的域。如果您曾经使用过跨域 AJAX 应用程序，您会感觉很好