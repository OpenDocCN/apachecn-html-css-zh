# 第一章。多人游戏编程入门

如果你正在读这本书，很有可能你已经是一个游戏开发者了。既然如此，那么你已经知道自己编写游戏程序是多么令人兴奋了，无论是专业的，还是作为一个非常令人满足的爱好，这都是非常耗时的。现在，您已经准备好将您的游戏编程技能提升到一个新的水平——也就是说，您已经准备好在您的基于 JavaScript 的游戏中实现多人游戏功能。

如果您已经开始使用 HTML5 和 JavaScript 为**开放网络平台**创建多人游戏，那么您可能已经意识到个人台式计算机、笔记本电脑或移动设备不是与另一个人类玩家共享两个或更多玩家同时共享同一游戏世界的游戏的最合适设备。因此，为了用 JavaScript 创建令人兴奋的多人游戏，需要某种形式的网络技术。

在本章中，我们将讨论以下原则和概念:

*   网络基础和网络编程范例
*   用 HTML5 进行套接字编程
*   对游戏服务器和游戏客户端进行编程
*   基于回合的多人游戏

# 了解网络基础知识

据说，如果不首先了解计算机网络和网络编程的所有知识，就无法编程利用网络的游戏。尽管对任何主题有深刻的理解只会对从事该主题工作的人有益，但我不认为你必须了解游戏网络的所有知识，才能编写一些非常有趣和吸引人的多人游戏。说是这样就像说一个人需要成为西班牙语的学者才能做一个简单的墨西哥卷饼。因此，让我们来看看网络最基本的概念。在本节结束时，您将对计算机网络有足够的了解，可以开始使用，并且您会觉得在游戏中添加多人游戏方面很舒服。

要记住的一点是，尽管网络游戏远没有单人游戏那么古老，但计算机网络实际上是一个非常古老且研究得很好的课题。一些最早的计算机网络系统可以追溯到 20 世纪 50 年代。尽管一些技术在过去几年里有所改进，但基本思想保持不变:两台或多台计算机连接在一起，在机器之间建立通信。我说的通信，是指数据交换，比如机器之间来回发送消息，或者一台机器只发送数据，另一台只接收数据。

通过对网络概念的简单介绍，你现在已经对网络这个主题有了足够的了解，可以知道网络游戏需要什么——两台或多台计算机尽可能接近实时地相互交流。

到目前为止，应该很清楚这个简单的概念是如何让我们将多个玩家连接到同一个游戏世界的。本质上，我们需要一种方法在所有连接到游戏会话的玩家之间共享全局游戏数据，然后继续更新每个玩家关于其他每个玩家的信息。有几种不同的技术通常用于实现这一点，但最常见的两种方法是对等和客户端-服务器。这两种技术提供了不同的机会，包括优点和缺点。一般来说，两者都不是特别好，但是不同的情况和用例可能更适合这种或那种技术。

## 对等网络

将玩家连接到同一个虚拟游戏世界的一个简单方法是通过对等架构。尽管名称可能暗示只涉及两个对等体(“节点”)，但根据定义对等网络系统是两个或更多节点直接相互连接而没有集中系统协调连接或信息交换的网络系统。

在典型的对等设置中，每一个对等体都提供与其他对等体相同的功能——也就是说，它们都使用相同的数据，并共享它们产生的任何数据，以便其他对等体能够保持同步。在对等游戏的情况下，我们可以用一个简单的*井字游戏*来说明这个架构。

![Peer-to-peer networking](../Images/image00131.jpeg)

一旦两个玩家在他们之间建立了联系，无论是谁开始游戏，都要在游戏板上标记一个单元格。这些信息通过网络传递给另一方，后者现在知道对手的决定，因此可以更新自己的游戏世界。一旦第二个玩家接收到由第一个玩家的最新移动导致的游戏的最新状态，第二个玩家就能够通过检查棋盘上的一些可用空间来进行他们自己的移动。然后，这些信息被复制到第一个玩家那里，第一个玩家可以更新自己的世界，并通过进行下一步想要的移动来继续这个过程。

过程继续进行，直到其中一个对等方断开连接，或者满足基于游戏自身业务逻辑的某些条件时，游戏结束。在*井字游戏*的情况下，一旦一个玩家在棋盘上标记了三个空格形成一条直线，或者如果所有九个单元格都被填满，但是两个玩家都没有成功地将三个单元格连接成一条直线，游戏就会结束。

点对点联网游戏的一些好处如下:

*   **快速数据传输**:这里，数据直接到达预定目标。在其他体系结构中，数据可以首先到达某个集中式节点，然后中央节点(或“服务器”，我们将在下一节中看到)联系另一个对等节点，发送必要的更新。
*   **更简单的设置**:你只需要考虑你的游戏的一个实例，一般来说，它处理自己的输入，将其输入发送给其他连接的对等体，并将它们的输出作为自己系统的输入。这在回合制游戏中尤其方便，例如*井字游戏*等大多数棋盘游戏。
*   **更高的可靠性**:这里，一个离线的对等体通常不会影响任何其他对等体。然而，在两人游戏的简单情况下，如果其中一名玩家无法继续游戏，该游戏将很可能不再可玩。然而，想象一下，这个游戏有几十个或几百个相互连接的对等体。如果其中一小撮人突然失去互联网连接，其他人可以继续玩。但是，如果有一个服务器正在连接所有节点，并且服务器关闭，那么其他玩家都不知道如何相互交谈，也没有人知道发生了什么。

另一方面，对等架构的一些更明显的缺点如下:

*   **传入数据不可信**:这里不确定发送方是否修改了数据。输入到游戏服务器中的数据也将遭受同样的挑战，但是一旦数据被验证并广播给所有其他对等体，您就可以更加确信每个对等体从服务器接收的数据将至少已经被净化和验证，并且将更加可信。
*   **容错可能非常低**:我们之前讨论过的*点对点网络*的“好处”部分提出了相反的论点；如果有足够多的玩家共享游戏世界，一次或多次崩溃不会让游戏对其他玩家不可玩。现在，如果我们考虑一下许多情况，其中任何一个玩家突然退出游戏会对其他玩家产生负面影响，我们可以看到服务器是如何从崩溃中轻松恢复的。
*   **向其他同伴广播时的数据重复**:想象一下你的游戏是一个简单的 2D 侧滚，很多其他玩家都在和你分享那个游戏世界。每当其中一名玩家向右移动时，你会从该玩家那里获得新的(x，y)坐标，并且你可以更新自己的游戏世界。现在，假设你把你的播放器向右移动了几个像素；您必须将数据发送到系统中的所有其他节点。

总的来说，点对点是一种非常强大的网络架构，目前仍被业内许多游戏广泛使用。由于当前的对等网络技术仍处于初级阶段，大多数以 JavaScript 为动力的游戏现在都没有利用对等网络。由于这个原因以及其他一些很快就会变得明显的原因，我们将把本书的其余部分几乎完全集中在另一个流行的网络模式上，即客户机-服务器体系结构。

## 客户端-服务器联网

**客户端-服务器联网**架构背后的想法非常简单。如果你把眼睛眯得足够大，你几乎可以看到一个点对点的图表。它们之间最明显的区别是不是每个节点都是平等的对等体，而是其中一个节点是特殊的。也就是说，不是每个节点都连接到其他节点，而是每个节点(*客户端*)都连接到名为*服务器*的主集中式节点。

虽然客户端-服务器网络的概念看起来足够清晰，但也许一个简单的比喻可能会让您更容易理解这种网络格式中每种类型节点的作用，并将其与对等网络区分开来(*麦康奈尔*、*史蒂夫*、 *(2004)* *代码完成*。，*微软出版社*。在对等网络中，你可以把它想象成一群朋友(*同辈*)在聚会上聊天。他们都可以访问参与对话的所有其他对等方，并且可以直接与他们交谈。另一方面，客户机-服务器网络可以被看作是一群朋友在餐馆吃饭。如果餐馆的顾客希望从菜单上点某个项目，他或她必须与服务员交谈，服务员是那群人中唯一能接触到想要的产品并有能力向顾客提供产品的人。

简而言之，服务器负责向一个或多个客户端提供数据和服务。在游戏开发的上下文中，最常见的场景是两个或多个客户端连接到同一个服务器；服务器将跟踪游戏以及分布式玩家。因此，如果两个玩家要交换仅与他们两个相关的信息，通信将从第一个玩家到并通过服务器，并且将在另一端与第二个玩家结束。

![Client-server networking](../Images/image00132.jpeg)

以我们在对等部分看到的*井字游戏*中的两个玩家为例，我们可以看到在客户端-服务器模型中事件流是多么相似。还是那句话，主要的区别是玩家彼此不知道，只知道服务器告诉他们什么。

虽然您可以通过使用服务器仅连接两个玩家来非常容易地模仿对等模型，但通常服务器的使用要比这积极得多。在网络游戏中，有两种方法可以让服务器参与进来，即以权威和非权威的方式。也就是说，您可以让服务器严格执行游戏逻辑，或者让客户端处理游戏逻辑、输入验证等等。如今，大多数使用客户端-服务器架构的游戏实际上使用了两者的混合(权威和非权威服务器，我们将在本书后面讨论)。然而，就所有意图和目的而言，服务器在生活中的目的是接收来自每个客户端的输入，并将该输入分布在连接的客户端池中。

现在，无论您是否决定使用权威服务器而不是非权威服务器，您都会注意到客户端-服务器游戏的挑战之一是您需要对堆栈的两端进行编程。即使您的客户端除了从用户那里获取输入、将其转发到服务器，并呈现它们从服务器接收的任何数据之外什么也不做，您也必须这样做；如果你的游戏服务器只是把它从每个客户端收到的输入转发给其他客户端，那么你仍然需要编写一个游戏客户端和一个游戏服务器。

我们将在本章后面讨论游戏客户端和服务器。目前，我们真正需要知道的是，这两个组件使这种网络模式区别于对等网络。

客户端-服务器联网游戏的一些优势如下:

*   **关注点分离**:如果你对软件开发有所了解，你就知道这是你应该一直追求的目标。也就是说，好的、可维护的软件被写成离散的组件，每个组件做一件“事情”，并且做得很好。编写单独的专门组件可以让你一次专注于执行一个单独的任务，使游戏更容易设计、编码、测试、推理和维护。
*   **集中化**:虽然这一点既可以反对也可以赞成，但是拥有一个所有通信都必须流经的中央场所，可以更容易地管理此类通信、执行任何必需的规则、控制访问等等。
*   **客户端工作更少**:客户端可以专注于只做其中的几件事，而不是让一个客户端(对等端)负责接收用户以及其他对等端的输入，验证所有的输入，在其他对等端之间共享数据，渲染游戏等等，允许服务器卸载其中的一些工作。当我们谈论移动游戏，以及微妙的分工能在多大程度上影响整体玩家体验时，这一点尤其方便。例如，想象一个游戏，10 个玩家在同一个游戏世界中。在点对点设置中，每次一名玩家采取行动时，他或她需要将该行动发送给其他九名玩家(换句话说，需要九次网络呼叫，归结为更多的移动数据使用)。另一方面，在客户机-服务器配置中，一个玩家只需要将他或她的动作发送给其中一个对等体，即服务器，然后服务器负责将该数据发送给其余九个玩家。

无论服务器是否权威，客户机-服务器体系结构的常见缺点如下:

*   **通信需要更长的时间来传播**:在可以想象的最好的情况下，从第一个玩家发送到第二个玩家的每条消息的传递时间是对等连接的两倍。也就是说，消息将首先从第一个玩家发送到服务器，然后从服务器发送到第二个玩家。今天有许多技术被用来解决这个场景中面临的延迟问题，其中一些我们将在[第 4 章](4.html#aid-10DJ41 "Chapter 4. Reducing Network Latency")、*减少网络延迟*中更深入地讨论。然而，潜在的困境将一直存在。
*   **更多运动部件带来更多复杂性**:披萨怎么切其实并不重要；你需要写的代码越多(相信我，当你为一个游戏构建两个独立的模块时，你会写更多的代码)，你的心智模型就必须越大。虽然您的大部分代码可以在客户机和服务器之间重用(尤其是如果您使用成熟的编程技术，如面向对象编程)，但归根结底，您需要管理更高层次的复杂性。
*   **单点故障和网络拥塞**:到目前为止，我们讨论最多的是只有极少数玩家参与同一个游戏的情况。然而，更常见的情况是少数几组玩家同时玩不同的游戏。

用*井字游戏*的双人游戏的同一个例子，想象一下单人游戏中有成千上万的玩家面对面。在对等设置中，一旦几个玩家直接配对，就好像没有其他玩家喜欢这个游戏。唯一阻止这两个玩家继续游戏的是他们自己与对方的联系。

另一方面，如果同样的成千上万的玩家通过位于两者之间的服务器相互连接，那么两个被挑选出来的玩家可能会注意到消息之间的严重延迟，因为服务器忙于处理来自和去往所有玩孤立游戏的其他人的所有消息。更糟糕的是，这两个玩家现在需要担心通过服务器保持他们自己与对方的连接，但他们也希望他们与对手之间的服务器连接保持活跃。

总而言之，客户端-服务器联网中涉及的许多挑战都已经得到了很好的研究和理解，并且您在多人游戏开发过程中可能面临的许多问题已经被其他人解决了。客户端-服务器是一个非常流行和强大的游戏网络模型，它所需的技术通过 HTML5 和 JavaScript 提供给我们，已经得到了很好的开发和广泛的支持。

## 网络协议——UDP 和 TCP

通过讨论一些的方式，你的玩家可以通过某种形式的网络互相交流，我们还只是浏览了一下这种交流是如何实际完成的。然后让我们描述什么是协议，以及它们如何应用于网络，更重要的是，多人游戏开发。

协议这个词可以定义为*一套惯例*或者一个程序的*详细计划*【引用【定义】。3,4].(未注明日期)。韦氏在线，检索自 2015 年 2 月 12 日，http://www.merriam-webster.com/dictionary/protocol。在计算机网络中，一种协议向消息的接收者描述数据是如何组织的，以便能够被解码。例如，假设你有一个多人对战游戏，你想告诉游戏服务器你的玩家刚刚发出了一个踢腿命令，向左移动了 3 个单位。你到底给服务器发什么？您是否发送一个值为“kick”的字符串，后跟数字 3？否则，您是否先发送数字，然后发送大写字母“K”，表示采取的动作是踢腿？我想说的是，如果没有一个好的理解和一致同意的协议，就不可能成功和可预测地与另一台计算机通信。

我们将在本节中讨论的两个网络协议，也是多人网络游戏中使用最广泛的两个协议，是**传输控制协议** ( **TCP** )和**用户数据报协议** ( **UDP** )。两种协议都在网络系统中的客户端之间提供通信服务。简而言之，它们是允许我们以可预测的方式发送和接收数据包，从而以识别和解释数据的协议。

当通过 TCP 发送数据时，运行在源机器上的应用程序首先与目标机器建立连接。一旦建立了连接，数据就以包的形式传输，这样接收应用程序就可以按照适当的顺序将数据放回一起。TCP 还提供了内置的错误检查机制，这样，如果数据包丢失，目标应用程序可以通知发送方应用程序，任何丢失的数据包都会被再次发送，直到收到整个消息。

简而言之，TCP 是一种基于连接的协议，保证以正确的顺序传递完整的数据。这种行为可取的用例就在我们身边。例如，当您从网络服务器下载游戏时，您希望确保数据输入正确。你要确保在你的用户开始玩你的游戏之前，你的游戏资产将被正确和完整地下载。虽然这种交付保证听起来非常令人放心，但也可以认为是一个缓慢的过程，正如我们将简要看到的，这有时可能比知道数据将全部到达更重要。

相比之下，UDP 不使用预先建立的连接来传输数据包(称为*数据报*)。该协议的主要目标是成为向某个目标应用程序发送数据的非常快速和无摩擦的方式。本质上，你可以把 UDP 想象成勇敢的员工，他们打扮成公司的吉祥物，站在店外挥舞着一面大旗，希望至少有一部分开车经过的人会看到他们，把生意交给他们。

虽然起初，UDP 看起来像是一个鲁莽的协议，但使 UDP 如此理想和有效的用例包括许多情况，当你比几次丢失数据包更关心速度时，获得重复的数据包，或者使它们无序。当你不在乎接收方的回复时，你可能也想选择 UDP 而不是 TCP。有了 TCP，无论你是否需要从你的消息的接收者那里得到某种形式的确认或回复，回复你仍然需要时间，至少要确认消息已经收到。有时，您可能不关心服务器是否收到了数据。

![Networking protocols – UDP and TCP](../Images/image00133.jpeg)

一个更具体的例子是当你需要客户端的心跳让服务器知道玩家是否还在的时候，UDP 是一个比 TCP 好得多的选择。如果您需要让您的服务器知道会话仍然经常处于活动状态，并且您不在乎其中一个心跳是否不时丢失，那么使用 UDP 将是明智的。简而言之，对于任何非关键任务且您可以承受损失的数据，UDP 可能是最佳选择。

最后，请记住，正如对等和客户端-服务器模型可以并行构建，同样，您的游戏服务器可以是权威和非权威的混合，您的多人游戏绝对没有理由只使用 TCP 或 UDP。使用特定情况要求的任何协议。

## 网络插座

还有一个协议，我们将简要介绍，但只是为了让你能看到游戏开发中对网络插座的需求。作为一名 JavaScript 程序员，你无疑熟悉**超文本传输协议** ( **HTTP** )。这是应用层的协议，网络浏览器用它从网络服务器上获取游戏。

虽然 HTTP 是一个可靠地从网络服务器上检索文档的伟大协议，但它并不是为实时游戏而设计的；因此，这并不理想。HTTP 的工作方式非常简单:客户端向服务器发送请求，然后服务器将响应返回给客户端。响应包括完成状态代码，向客户端指示请求正在处理中，需要转发到另一个地址，或者成功完成，或者错误地(*超文本传输协议(HTTP/1.1):认证*、*(1999 年 6 月)*。[https://tools.ietf.org/html/rfc7235](https://tools.ietf.org/html/rfc7235)

关于 HTTP，有几件事需要注意，这将表明客户端和服务器之间的实时通信需要更好的协议。首先，在请求者收到每个响应后，连接被关闭。因此，在发出每一个请求之前，必须与服务器建立新的连接。大多数情况下，HTTP 请求将通过 TCP 发送，正如我们所看到的，相对而言，这可能会很慢。

其次，HTTP 是通过设计一个无状态协议实现的。这意味着，每次您向服务器请求资源时，服务器都不知道您是谁以及请求的上下文是什么。(它不知道这是你第一次请求还是经常请求。)这个问题的一个常见解决方案是在服务器跟踪的每个 HTTP 请求中包含一个唯一的字符串，从而可以持续提供每个客户端的信息。你可能会认为这是一个标准的*会话*。这种解决方案的主要缺点是，至少在实时游戏方面，将会话 cookie 映射到用户的会话需要额外的时间。

最后，使 HTTP 不适合多人游戏编程的主要因素是通信是单向的——只有客户端可以连接到服务器，服务器通过相同的连接进行回复。换句话说，游戏客户端可以告诉游戏服务器用户已经输入了打孔命令，但是游戏服务器不能将该信息传递给其他客户端。把它想象成一台自动售货机。作为机器的客户，我们可以要求我们希望购买的特定项目。我们通过将钱插入自动售货机来正式确定这个请求，然后我们按下适当的按钮。

在任何情况下，自动售货机都不会向站在旁边的人发出命令。这就像等待自动售货机分发食物，然后期待人们把钱存进去。

HTTP 中这种功能缺失的答案非常简单。网络套接字是允许客户端和服务器之间双向通信的连接中的端点。把它想象成一个电话，而不是自动售货机。在电话中，任何一方都可以在任何给定的时间说任何他们想说的话。最重要的是，在整个谈话过程中，双方之间的联系保持开放，使沟通过程非常高效。

![Network sockets](../Images/image00134.jpeg)

**网络套接字**是建立在 TCP 之上的协议，允许基于网络的应用程序与服务器进行双向通信(*网络套接字协议*，*(2011 年 12 月)*。[http://tools.ietf.org/html/rfc6455 RFC 6455](http://tools.ietf.org/html/rfc6455%20RFC%206455)。创建网络套接字的方式包括几个步骤，包括从 HTTP 到网络套接字的协议升级。谢天谢地，所有的繁重工作都是在幕后由浏览器和 JavaScript 完成的，我们将在下一节中看到。目前，这里的关键要点是，有了 TCP 套接字(是的，还有其他类型的套接字，包括 UDP 套接字)，我们可以可靠地与服务器通信，服务器可以根据需要与我们进行对话。

# JavaScript 中的套接字编程

现在，让我们结束关于网络连接、协议和套接字的对话，谈谈将一切结合在一起的工具——JavaScript 和网络套接字，让我们能够用开放网络的语言编写令人敬畏的多人游戏。

## 网络套接字协议

现代浏览器和其他 JavaScript 运行时环境已经在 JavaScript 中实现了 WebSocket 协议。不要错误地认为仅仅因为我们可以用 JavaScript 创建网络套接字对象，网络套接字就是 JavaScript 的一部分。定义 WebSocket 协议的标准是语言无关的，可以用任何编程语言实现。因此，在您开始部署使用网络套接字的 JavaScript 游戏之前，请确保运行您的游戏的环境使用同样实现网络套接字的**【ECMA】**标准的实现。换句话说，当你请求一个网络套接字连接时，并不是所有的浏览器都知道该做什么。

然而，在很大程度上，截至本文撰写之时，当今最流行的浏览器(即谷歌浏览器、Safari、Mozilla Firefox、Opera 和互联网浏览器)的最新版本实现了 RFC 6455 的最新版本。以前版本的网络套接字(如协议版本- 76、7 或 10)正在慢慢被弃用，并且已经被前面提到的一些浏览器删除。

### 注

关于 WebSocket 协议，最令人困惑的可能是协议每个版本的命名方式。第一稿(可追溯到 2010 年)被命名为*draft-hixie-thewbsocketprotocol-75*。下一个版本被命名为*draft-hixie-thewbsocketprotocol-76*。有些人将这些版本称为 75 和 76，这可能会相当混乱，尤其是因为协议的第四个版本被命名为*草案-IETF-hybi-thewbsocketprotocol-07*，该草案被命名为 WebSocket Version 7。协议的当前版本( *RFC 6455* )是 13。

让我们快速了解一下我们将在 JavaScript 代码中用来与网络套接字服务器交互的编程接口。请记住，我们需要编写使用网络套接字消费数据的 JavaScript 客户端以及使用网络套接字但扮演服务器角色的网络套接字服务器。当我们复习一些例子时，这两者之间的区别会变得很明显。

### 创建客户端网络套接字

下面的代码片段创建了一个新的 WebSocket 类型的对象，它将客户端连接到某个后端服务器。构造函数接受两个参数；第一个是必需的，表示运行 WebSocket 服务器并期望连接的 URL。第二个 URL 是服务器可能实现的子协议的可选列表，在本书中我们不会用到它。

```
var socket = new WebSocket('ws://www.game-domain.com');
```

虽然这一行代码看起来简单无害，但还是要记住以下几点:

*   我们已经不在 HTTP 领域了。你的网络套接字服务器的地址现在以`ws://`开始，而不是`http://`。类似地，当我们使用安全(加密)套接字时，我们会将服务器的 URL 指定为`wss://`，就像在`https://`中一样。
*   对您来说，这似乎是显而易见的，但是那些开始使用网络套接字的人会陷入的一个常见陷阱是，在您可以与前面的代码建立连接之前，您需要一个运行在该域上的网络套接字服务器。
*   WebSockets implement the same-origin security model. As you may have already seen with other HTML5 features, the same-origin policy states that you can only access a resource through JavaScript if both the client and the server are in the same domain.

    ### 类型

    对于那些不熟悉同域(也称为**同源**)策略的人来说，构成了一个域，在这种情况下，是被访问资源的协议、主机和端口。在前面的示例中，协议、主机和端口号分别是`ws`(而不是`wss`、`http`或`ssh`)、`www.game-domain.com`(任何子域，如`game-domain.com`或`beta.game-domain.com`都将违反同源策略)和 80(默认情况下，WebSocket 连接到端口 80，使用`wss`时连接到端口 443)。

    由于前面例子中的服务器绑定到端口 80，我们不需要明确指定端口号。但是，如果服务器被配置为在不同的端口上运行，比如 2667，那么 URL 字符串将需要包含一个冒号，后跟需要放在主机名末尾的端口号，例如`ws://www.game-domain.com:2667`。

与 JavaScript 中的其他东西一样，WebSocket 实例试图异步连接到后端服务器。因此，在您确定服务器已经连接之前，您不应该尝试在新创建的套接字上发出命令；否则，JavaScript 将抛出一个错误，可能会使您的整个游戏崩溃。这可以通过在套接字的`onopen`事件上注册回调函数来实现，如下所示:

```
var socket = new WebSocket('ws://www.game-domain.com');
socket.onopen = function(event) {
   // socket ready to send and receive data
};
```

一旦套接字准备好发送和接收数据，您可以通过调用套接字对象的`send`方法向服务器发送消息，该方法将字符串作为要发送的消息。

```
// Assuming a connection was previously established
socket.send('Hello, WebSocket world!');
```

然而，大多数情况下，您会希望向服务器发送更有意义的数据，例如对象、数组和其他本身更有意义的数据结构。在这些情况下，我们可以简单地将数据序列化为 JSON 字符串。

```
var player = {
   nickname: 'Juju',
   team: 'Blue'
};

socket.send(JSON.stringify(player));
```

现在，服务器可以接收该消息，并通过 JSON 对象的解析方法运行它，将其作为客户端发送的相同对象结构来使用。

```
var player = JSON.parse(event.data);
player.name === 'Juju'; // true
player.team === 'Blue'; // true
player.id === undefined; // true
```

如果你仔细看前面的例子，你会注意到我们从某个事件对象的`data`属性中提取通过套接字发送的消息。你问，那个事件对象是从哪里来的？问得好！我们从套接字接收消息的方式在套接字的客户端和服务器端都是相同的。我们只需在套接字的`onmessage`事件上注册一个回调函数，每当接收到新消息时，回调就会被调用。传入回调函数的参数将包含一个名为 data 的属性，该属性将包含原始字符串对象和发送的消息。

```
socket.onmessage = function(event) {
   event instanceof MessageEvent; // true

   var msg = JSON.parse(event.data);
};
```

### 类型

**下载示例代码**

您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载您购买的所有 Packt Publishing 书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您

可以注册回调的 socket 对象上的其他事件包括`onerror`，每当发生与 socket 相关的错误时触发`onerror`，每当 socket 状态变为 *CLOSED* 时触发`onclose`；换句话说，每当服务器因为任何原因关闭与客户端的连接或者连接的客户端关闭其连接时。

如前所述，套接字对象还将有一个名为`readyState`的属性，其行为方式类似于 AJAX 对象(或更恰当地说，`XMLHttpRequest`对象)中的同名属性。此属性表示连接的当前状态，并且在任何时间点都可以有四个值之一。该值是 0 到 3 之间的无符号整数，包括两个数字。为了清楚起见，在网络套接字类上有四个附带的常量，它们映射到实例的`readyState`属性的四个数值。常数如下:

*   `WebSocket.CONNECTING`:值为 0，表示客户端和服务器之间的连接尚未建立。
*   `WebSocket.OPEN`:值为 1，表示客户端和服务器之间的连接已经打开，可以使用了。每当对象的`readyState`属性从 CONNECTING 变为 OPEN 时(这在对象的生命周期中只会发生一次)，就会调用`onopen`回调。
*   `WebSocket.CLOSING`:值为 2，表示连接正在关闭。
*   `WebSocket.CLOSED`:该值为 3，表示连接现在已关闭(或无法打开)。

一旦`readyState`变为新值，它将永远不会返回到套接字对象的同一实例中的先前状态。因此，如果插座对象正在关闭或已经成为*关闭*，它将永远不会再*打开*。在这种情况下，如果您想继续与服务器通信，您将需要一个新的 WebSocket 实例。

总而言之，让我们将之前讨论过的简单的 WebSocket API 特性集合在一起，创建一个方便的函数，在与游戏服务器通信时简化数据序列化、错误检查和错误处理:

```
function sendMsg(socket, data) {
   if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(data));

      return true;
   }

   return false;
};
```

# 游戏客户端

在本章的前面，我们讨论了基于客户端-服务器模式的多人游戏的架构。由于这是我们将在整本书中开发的游戏所采用的方法，让我们定义一些游戏客户端将扮演的主要角色。

从更高的层面来看，游戏客户端将是人类玩家和游戏世界其他部分(包括游戏服务器和与之相连的其他人类玩家)之间的接口。因此，游戏客户端将负责接收来自玩家的输入，将其传送给服务器，从服务器接收任何进一步的指令和信息，然后再次将最终输出呈现给人类玩家。根据所使用的游戏服务器的类型(我们将在下一节和以后的章节中讨论)，客户端可以比仅仅呈现从服务器接收的静态数据的输入应用程序更复杂。例如，客户端可以很好地模拟游戏服务器将会做什么，并且在服务器执行真实计算并将结果告诉客户端的同时，将该模拟的结果呈现给用户。这种技术的最大卖点是，游戏对用户来说看起来更加动态和实时，因为客户端几乎可以立即响应输入。

# 游戏服务器

游戏服务器主要负责将所有玩家连接到同一个游戏世界，并保持他们之间的通信。然而，正如你很快会意识到的，可能有些情况下你会希望服务器比路由应用程序更复杂。例如，仅仅因为其中一个玩家正在告诉服务器通知其他参与者游戏已经结束，而发送消息的玩家是赢家，我们可能仍然希望在决定游戏实际上已经结束之前确认信息。

考虑到这个想法，我们可以将游戏服务器标记为两种类型之一:权威或非权威。在权威的游戏服务器中，游戏的逻辑实际上一直在内存中运行(尽管它通常不会像游戏客户端那样呈现任何图形输出)。当每个客户端通过其对应的套接字发送消息向服务器报告信息时，服务器更新当前游戏状态，并将更新发送回所有玩家，包括原始发送者。通过这种方式，我们可以更确定来自服务器的任何数据都已经过验证并且是准确的。

在非权威服务器中，客户端在游戏逻辑执行中承担了更多的角色，这给了客户端更多的信任。如前所述，我们可以做的是取两者之长，将两种技术结合起来。我们在这本书里要做的是有一个严格权威的服务器，但是客户端是聪明的，可以自己做一些工作。然而，由于服务器在游戏中拥有最终的发言权，客户端从服务器收到的任何消息都被视为最终的真相，并取代它自己得出的任何结论。

# 综合起来——井字游戏

在我们对网络、网络套接字和多人游戏架构的新知识着迷之前，让我们以最简单的方式应用这些原则，创建一个非常令人兴奋的网络游戏*井字游戏*。我们将使用普通的网络套接字与服务器通信，我们将用纯 JavaScript 编写。由于这个 JavaScript 将在服务器环境中运行，我们将使用 **Node.js** (参考[https://nodejs.org/](https://nodejs.org/))，在这一点上您可能熟悉也可能不熟悉。暂时不要太担心 Node.js 特有的细节。我们专门用了整整一章来介绍 Node.js 及其相关的生态系统。现在，试着关注这个游戏的网络方面。

![Putting it all together – Tic-tac-toe](../Images/image00135.jpeg)

当然，你对*井字游戏*很熟悉。两个玩家轮流在 9x9 的格子上标记一个正方形，谁用相同的标记在棋盘上标记三个空格，这样形成一条直线，无论是水平的、垂直的还是对角的，谁就赢了。如果所有九个方块都被标记，并且前面提到的规则没有得到满足，那么游戏以平局结束。

## node . js——宇宙的中心

正如承诺的那样，我们将在下一章深入讨论 Node.js。现在，只要知道 Node.js 是我们开发策略的一个基本部分，因为整个服务器将在 Node 中编写，所有其他支持工具将利用 Node 的环境。我们将在第一个演示游戏中使用的设置包含三个主要部分，即 **网络服务器****游戏服务器**和**客户端文件**(游戏客户端所在的)。

![Node.js – the center of the universe](../Images/image00136.jpeg)

目前我们需要担心六个主要文件。其余的由 Node.js 和相关工具自动生成。至于我们的六个脚本，这是他们每个人都做的。

### /Player . js 类

这是一个非常简单的类，主要用来描述游戏客户端和服务器都期望什么。

```
/**
 *
 * @param {number} id
 * @param {string} label
 * @param {string} name
 * @constructor
 */
var Player = function(id, label, name) {
    this.id = id;
    this.label = label;
    this.name = name;
};

module.exports = Player;
```

最后一行将在我们谈论 Node.js 的基础知识时进行更详细的解释。目前，您需要知道的是，它使`Player`类可用于服务器代码以及发送到浏览器的客户端代码。

此外，我们可以很好地在整个游戏中使用一个对象文字来表示我们抽象出的对象`player`。我们甚至可以使用一个包含这三个值的数组，其中每个元素的顺序将代表该元素是什么。在此过程中，我们甚至可以使用逗号分隔的字符串来表示所有三个值。

正如你所看到的，创建一个全新的类来存储三个简单的值所引起的稍微冗长使得代码更容易阅读，就像我们现在知道的由游戏在请求`Player`时建立的契约一样。它希望名为`id`、`label`和`name` 的属性出现在那里。

在这种情况下，`id`可以认为有点多余，因为它的唯一目的是识别和区分玩家。重要的是这两个玩家有唯一的 ID。标签属性是每个玩家将在棋盘上打印的内容，这恰好是两个玩家之间的唯一值。最后，名称属性用于以人类可读的方式打印每个玩家的姓名。

### boardserver . js 类

这个类抽象了*井字游戏*的一个表示，定义了一个界面，在这个界面中我们可以创建和管理一个有两个玩家和一个棋盘的游戏世界。

```
var EventEmitter = require('events').EventEmitter;
var util = require('util');

/**
 *
 * @constructor
 */
var Board = function() {
    this.cells = [];
    this.players = [];
    this.currentTurn = 0;
    this.ready = false;

    this.init();
};

Board.events = {
    PLAYER_CONNECTED: 'playerConnected',
    GAME_READY: 'gameReady',
    CELL_MARKED: 'cellMarked',
    CHANGE_TURN: 'changeTurn',
    WINNER: 'winner',
    DRAW: 'draw'
};

util.inherits(Board, EventEmitter);
```

因为这段代码只打算在服务器上运行，所以它充分利用了 Node.js。脚本的第一部分导入了两个核心 Node.js 模块，我们将利用它们，而不是重新发明轮子。第一个，`EventEmitter`，将允许我们在他们占据的位置时广播关于我们游戏的事件。其次，我们导入了一个实用程序类，让我们可以轻松地利用面向对象编程。最后，我们定义了一些与`Board`类相关的静态变量，以简化事件注册和传播。

```
Board.prototype.mark = function(cellId) {
    // …
    if (this.checkWinner()) {
        this.emit(Board.events.WINNER, {player: this.players[this.currentTurn]});
    }
};
```

`Board`类公开了驱动程序应用程序可以调用的几种方法，以便向其中输入数据，并且当某些情况发生时，它会发出事件。如前面提到的方法所示，每当玩家成功地在棋盘上标记了一个可用的方块，游戏就广播该事件，以便驱动程序知道游戏中发生了什么；然后，它可以通过相应的套接字联系每个客户端，并让他们知道发生了什么。

### /server . js 类

这里，我们有驱动程序，它使用我们之前描述的`Board`类来执行游戏规则。它还使用网络套接字来维护连接的客户端，并处理它们与游戏的个人交互。

```
var WebSocketServer = require('ws').Server;
var Board = require('./BoardServer');
var Player = require('./Player');

var PORT = 2667;
var wss = new WebSocketServer({port: PORT});
var board = new Board();

var events = {
    incoming: {
        JOIN_GAME: 'csJoinGame',
        MARK: 'csMark',
        QUIT: 'csQuit'
    },
    outgoing: {
        JOIN_GAME: 'scJoinGame',
        MARK: 'scMark',
        SET_TURN: 'scSetTurn',
        OPPONENT_READY: 'scOpponentReady',
        GAME_OVER: 'scGameOver',
        ERROR: 'scError',
        QUIT: 'scQuit'
    }
};

/**
 *
 * @param action
 * @param data
 * @returns {*}
 */
function makeMessage(action, data) {
    var resp = {
        action: action,
        data: data
    };

    return JSON.stringify(resp);
}

console.log('Listening on port %d', PORT);
```

这个 Node.js 服务器脚本的第一部分导入了我们的定制类(`Board`和`Player`)以及一个名为`ws`的方便的第三方库，它帮助我们实现了 WebSocket 服务器。该库处理诸如初始连接的设置、协议升级等事情，因为这些步骤不包括在 JavaScript WebSocket 对象中，而该对象仅用于作为客户端。在几个便利对象之后，我们有了一个等待`ws://localhost:2667`上连接的工作服务器。

```
wss.on('connection', function connection(ws) {
    board.on(Board.events.PLAYER_CONNECTED, function(player) {
        wss.clients.forEach(function(client) {
            board.players.forEach(function(player) {
                client.send(makeMessage(events.outgoing.JOIN_GAME, player));
            });
        });
    });

    ws.on('message', function incoming(msg) {
        try {
            var msg = JSON.parse(msg);
        } catch (error) {
            ws.send(makeMessage(events.outgoing.ERROR, 'Invalid action'));
            return;
        }

        try {
            switch (msg.action) {
                case events.incoming.JOIN_GAME:
                    var player = new Player(board.players.length + 1, board.players.length === 0 ? 'X' : 'O', msg.data);
                    board.addPlayer(player);
                    break;
                // ...
            }
        } catch (error) {
            ws.send(makeMessage(events.outgoing.ERROR, error.message));
        }
    });
});
```

该服务器的其余重要部分发生在中间。为了简洁起见，我们只包含了每种情况的一个例子，其中包括由`Board`类发出的事件的事件处理程序注册，以及由套接字接收的事件的`callback`函数的注册。(你认出`ws.on('message', function(msg){})`函数调用了吗？这相当于我们前面讨论的客户端 JavaScript `socket.onmessage = function(event){}`。)

这里最重要的是我们处理来自游戏客户端的消息的方式。既然客户端只能给我们发送一个字符串作为消息，我们怎么知道消息是什么呢？由于客户端可以向服务器发送多种类型的消息，我们在这里所做的是创建我们自己的小协议。也就是说，每个消息将是一个序列化的`JSON`对象(也称为对象文字)，具有两个属性。第一个键的值为`action`，第二个键的值为`data`，根据指定的动作可以有不同的值。从这里，我们可以看到`msg.action`的价值，并做出相应的回应。

例如，每当客户端连接到游戏服务器时，它都会发送具有以下值的消息:

```
{
    action: events.outgoing.JOIN_GAME,
    data: "<player nickname>"
};
```

一旦服务器接收到该对象作为`onmessage`事件的有效载荷，它就可以知道消息的含义和玩家昵称的期望值。

### 公共/js/Board.js 类

这个类与`BoardServer.js`非常相似，主要区别在于它还处理 DOM(意思是浏览器渲染和管理的 HTML 元素)，因为游戏需要渲染给人类玩家。

```
/**
 *
 * @constructor
 */
var Board = function(scoreBoard) {
    this.cells = [];
    this.dom = document.createElement('table');
    this.dom.addEventListener('click', this.mark.bind(this));
    this.players = [];
    this.currentTurn = 0;
    this.ready = false;

    this.scoreBoard = scoreBoard;

    this.init();
};

Board.prototype.bindTo = function(container) {
    container.appendChild(this.dom);
};

Board.prototype.doWinner = function(pos) {
    this.disableAll();
    this.highlightCells(pos);
};
```

同样，为了简洁起见，我们选择不显示游戏的大部分逻辑。这里需要注意的重要事情是，这个版本的棋盘类非常了解 DOM，它对游戏决策和游戏规则的执行非常被动。因为我们使用的是权威服务器，所以这个类会做服务器告诉它的任何事情，比如用表示某个参与者赢得了游戏的方式来标记自己。

### 公共/js/app.js 类

类似`server.js`，这个脚本是我们游戏的驱动程序。它做两件事:从驱动服务器的用户获取输入，并使用从服务器接收的输入来驱动主板。

```
var socket = new WebSocket('ws://localhost:2667');

var scoreBoard = [
    document.querySelector('#p1Score'),
    document.querySelector('#p2Score')
];

var hero = {};
var board = new Board(scoreBoard);

board.onMark = function(cellId){
    socket.send(makeMessage(events.outgoing.MARK, {playerId: hero.id, cellId: cellId}));
};

socket.onmessage = function(event){
    var msg = JSON.parse(event.data);

    switch (msg.action) {
        case events.incoming.GAME_OVER:
            if (msg.data.player) {
                board.doWinner(msg.data.pos);
            } else {
                board.doDraw();
            }

            socket.send(makeMessage(events.outgoing.QUIT, hero.id));
            break;

        case events.incoming.QUIT:
            socket.close();
            break;
    }
};

socket.onopen = function(event) {
    startBtn.removeAttribute('disabled');
    nameInput.removeAttribute('disabled');
    nameInput.removeAttribute('placeholder');
    nameInput.focus();
};
```

同样，值得注意的是客户机服务器是如何以 DOM 为中心的。还要观察客户端对从服务器接收到的消息的服从程度。如果服务器在它发送给客户端的消息中指定的动作是`GAME_OVER`，客户端清理干净，告诉玩家游戏结束，要么是因为有人赢了游戏，要么是游戏以平局结束，然后它告诉服务器它准备断开连接。同样，客户端等待服务器告诉它下一步要做什么。在这种情况下，它等待服务器清理，然后告诉客户端断开连接。

# 总结

在本章中，我们讨论了网络和网络编程范例的基础。我们看到了网络套接字如何使在 HTML5 中开发实时多人游戏成为可能。最后，我们使用广泛支持的网络技术实现了一个简单的游戏客户端和游戏服务器，并构建了一个有趣的游戏*井字游戏*。

在下一章中，我们将了解 JavaScript 开发领域的当前技术水平，包括通过 Node.js 在服务器中的 JavaScript。这一章将教您使用工作流和资源管理工具(如 NPM、Bower、Grunt 等)在 JavaScript 中管理开发周期的当前技术。