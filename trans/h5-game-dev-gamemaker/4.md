# 五、平台的乐趣

现在，我们已经在构建游戏的基础上打下了良好的基础，我们已经准备好创建更复杂、更高效的项目。在本章中，我们将开发一款经典的平台游戏，其中包含一场史诗般的 boss 战斗。我们将专注于构建系统和利用可重用脚本来简化代码和节省时间。这也将减少游戏的总大小，使下载速度更快。

游戏本身将由一个玩家角色组成，该角色可以在世界各地奔跑，跳上平台，并向多个方向射击。玩家将需要击败一个巨大的机器老板，这将有三个不同的阶段。在第一阶段，玩家将需要炸毁三门威力强大的大炮，这些大炮会暴露很短时间。第二阶段需要摧毁一门大型激光加农炮，该加农炮将上下移动，间歇发射其巨大的激光束。最后阶段将有护盾保护 Boss 核心，偶尔会打开护盾让玩家根除 Boss 的心脏。当玩家试图避免被不可摧毁的炮塔击中时，所有这些都会发生。

# 基于代码构建系统

当制作一款游戏时，通常会自行构建每个组件，而不会考虑它将如何影响整个游戏。开发人员将构建一个基本框架，然后在功能出现时添加功能，通常使用特殊的条件语句使代码工作而不破坏游戏。这种方法最终会在软件中产生 bug，需要更多的时间和精力来修复每一个 bug。游戏规模越大，出现问题的可能性就越大。这可能是一次令人难以置信的沮丧经历。

在这一点上，将代码分解为单个系统可以真正节省时间和精力。我们可以将自包含的流程写入可以共享的脚本，而不是为每个对象反复重写代码元素。对于这个游戏，我们将分离出一些更基本的组件，例如重力和动画，进入它们自己的系统。

## 创造重力

我们要建造的第一个系统是处理重力的系统。虽然 GameMaker:Studio 有重力属性，但它增加了 platformer 游戏中不需要的复杂性。重力是一种累积作用于物体速度的力，这意味着物体下落的时间越长，移动的速度就越快。我们面临的问题是，将重力设为零只意味着它不会移动得更快。我们需要这个物体停下来。因此，我们将创造我们自己的重力系统，它不仅能使物体坠落，还能处理着陆问题。相反，我们将创造我们自己的重力系统，它不仅能使物体坠落，还能处理着陆问题。

我们将从引入**常数**开始。常量允许我们使用名称来表示永远不会更改的值。这样做的双重好处是使我们更容易阅读代码，并有助于提高与变量相比的性能：

1.  让我们开始创建一个名为`Chapter_03`的**新项目**。
2.  Open the **Resources** | **Define Constants** editor. In the **Name** column write `MAXGRAVITY` with a **Value** of `16`. At this speed we can be sure that a falling object will not move so fast that it will miss the bounding box of another object in the game. From now on, whenever we see `MAXGRAVITY` the computer will see `16`.

    ### 注

    用大写字母书写所有常量是惯例，但如果不遵循惯例，它不会被打破。

3.  Next we can create a new Script , `scr_Gravity`, and write the following code to create gravity:

    ```html
    if (place_free( x, y + vspeed + 1))
    {
        vspeed  += 1;
    } else {    
        move_contact_solid(direction, MAXGRAVITY);
        vspeed = 0;
    }
    ```

    首先，我们检查实例下方的区域是否以实例当前的移动速度没有任何可碰撞的对象。如果它是清楚的，那么我们知道我们在空中，重力应该被施加。我们通过将每一步的垂直速度增加少量来实现这一点。如果有一个可碰撞的物体，那么我们将要撞到地面，所以我们将实例移动到物体表面，移动方向是实例向上移动到我们的`MAXGRAVITY`，16 像素。此时，实例在地面上，因此我们将垂直速度设置为零。

4.  We now have gravity working, but it will pick up too much speed if we don't limit how fast an instance can fall. Add this code to the bottom of the script:

    ```html
    vspeed = min(vspeed, MAXGRAVITY);
    ```

    这里我们将`vspeed`值设置为当前`vspeed`和`MAXGRAVITY`之间的较低值。如果实例移动太快，此代码将使其减速到允许的最大速度。我们现在有一个简单的重力系统，游戏中的所有物体都可以使用。

## 构建动画系统

我们将创建的下一个系统用于动画，它将作为状态机实现。状态机将对象的所有条件分解为不同的状态。一个对象在任何时候只能处于一个阶段，因此可以更有效地包含和管理与其相关的代码。

为了更好地理解这个概念，可以考虑一扇门。门有几种独特的存在状态。有两种状态可能会让人想到，门可以打开，也可以关闭。还有另外两种状态，打开和关闭，如下图所示。如果门正在打开，它既没有打开也没有关闭，而是处于一种独特的动作状态。这使得状态机非常适合动画。几乎游戏中的每个交互对象都可能有一些动画或使用几个不同的图像。

![Building an animation system](img/4100_05_01.jpg)

由于玩家角色通常是不同动画中最健壮的对象，我们将首先分解的独特状态。我们的球员可以在空中也可以在地面，所以我们要确保分开这些控制。我们还希望玩家能够向多个方向射击并承受伤害。我们总共将有八个不同的州：

*   闲置的
    *   空转瞄准
    *   空转瞄准
*   跑
    *   瞄准
    *   瞄准
*   空气中
*   损坏

让我们首先将这些状态定义为常量：

1.  打开**资源****定义常量**编辑器，在**名称**栏中写入`IDLE`，其中**值**为`0`。
2.  Click on **Add** or just press *Enter* to add a new row and write `IDLEUP` with a value of `1`. Repeat this process for all the states with increasing numbers as can be seen in the following screenshot. Then click on **OK**.

    ![Building an animation system](img/4100_05_02.jpg)

3.  Create a new Script and name it `scr_Animation_Control`. We will start by using a `switch` statement to control the various states. We also want this script to be reusable, so we will want to use some generic variables to make the code more universal. Let's start by adding in the idle state with the following code:

    ```html
    switch (action)
    {
        case IDLE :
            sprite_index = myIdle;
            image_speed = 0.1;
        break;
    }
    ```

    这里我们将使用一个名为`action`的变量来切换状态。如果动作正好是`IDLE`，我们就改变精灵；在本例中，我们使用的是另一个变量`myIdle`，我们将在每个对象中定义该变量，这将允许我们重用该脚本。我们还设置了动画速率，这将允许我们对不同的动作有不同的播放速度。

4.  我们将需要将所有案例插入到这个脚本中，并使用类似的设置来更改精灵和设置图像播放速度。以下是各州的代码：

    ```html
        case IDLEUP :
            sprite_index = myIdleUp;
            image_speed = 0.1;
        break;
        case IDLEDOWN :
            sprite_index = myIdleDown;
            image_speed = 0.1;
        break;
        case RUN :
            sprite_index = myRun;
            image_speed = 0.5;
        break; 
        case RUNUP :
            sprite_index = myRunUp;
            image_speed = 0.5;
        break; 
        case RUNDOWN :
            sprite_index = myRunDown;
            image_speed = 0.5;
        break; 
        case INAIR :
            sprite_index = myInAir;
            image_speed = 0.5;
        break; 
        case DAMAGE :
            sprite_index = myDamage;
            image_speed = 0.5;
        break; 
    ```

5.  We have all the states we need, but what about dealing with the direction that the player is facing. It's a platformer so they will need to go right and left. For this we will just flip the image by scaling it inversely with the following code after the switch statement closing brace:

    ```html
    image_xscale = facing;
    ```

    我们再次利用一个变量`facing`，使脚本更加通用。我们现在已经完成了这个脚本，动画系统已经准备好实现了。

## 创建碰撞预测系统

我们将要建立的下一个系统用于处理世界碰撞。我们不想使用 GameMaker:Studio 的碰撞系统，因为它需要两个实例彼此相交。这对于子弹与玩家相撞非常有效，但如果玩家需要沉入地下才能知道何时停止，则效果较差。相反，我们希望在实例移动之前预测是否会发生碰撞：

1.  We will start with forecasting wall collision to the left and right of the instance. Create a new Script, `scr_Collision_Forecasting` and write the following code:

    ```html
    if (place_free(x - mySpeed, y))
    {
        canGoLeft = true;
    } else {
        canGoLeft = false;
        hspeed = 0;
    }

    if (place_free(x + mySpeed, y))
    {
        canGoRight = true;
    } else {
        canGoRight = false;
        hspeed = 0;
    }
    ```

    我们首先检查实例左侧的区域是否没有可碰撞的对象。我们正在查看的距离由一个变量`mySpeed`确定，该变量将允许该检查可调整到实例可能以的任何速度运行。如果区域被清除，我们将`canGoLeft`变量设置为`true`，否则区域被阻塞，我们停止实例的水平速度。然后，我们对右侧的碰撞重复此检查。

2.  Next we need to check for the ground collision. After the previous code we need to add:

    ```html
    if (!place_free(x, y+1))
    {
        isOnGround = true;
        vspeed = 0;
        action = IDLE;
    } else {
        isOnGround = false;
    }
    ```

    这里我们正在检查实例正下方是否存在可碰撞对象。如果发生碰撞，我们将变量`isOnGround`设置为`true`，停止垂直速度，然后将实例的状态更改为`IDLE`。像这样更改状态将保证实例从`INAIR`状态逃逸。

    此时，我们已经构建了大部分碰撞检测，但还没有涵盖所有边缘情况。我们目前只检查实例的左侧、右侧和下方，但不检查对角线。这里的问题是，所有条件都可能被证明为真，但当实例以一定角度移动时，可能会导致实例卡在可碰撞对象内。

3.  Rather than building conditional checks for all angles, we will instead allow the collision to happen and then pop it back into the proper position. Add this next code at the end of the script:

    ```html
    if (!place_free(x, y)) 
    { 
        x = xprevious;
        y = yprevious;
        move_contact_solid(direction, MAXGRAVITY);
        vspeed = 0;
    }
    ```

    这里我们检查实例当前是否与可碰撞对象相交。如果是这样，我们将 X 和 Y 坐标设置为上一步上的位置，然后沿运动方向将其捕捉到表面，并将垂直速度设置为零。这将以现实的方式清理边缘案例场景。整个脚本应如下所示：

    ```html
    if (place_free(x - mySpeed, y))
    {
        canGoLeft = true;
    } else {
        canGoLeft = false;
        hspeed = 0;
    }

    if place_free(x + mySpeed, y)
    {
        canGoRight = true;
    } else {
        canGoRight = false;
        hspeed = 0;
    }

    if (!place_free(x, y+1))
    {
        isOnGround = true;
        vspeed = 0;
        action = IDLE;
    } else {
        isOnGround = false;
    }

    if (!place_free(x, y)) 
    { 
        x = xprevious;
        y = yprevious;
        move_contact_solid(direction, MAXGRAVITY);
        vspeed = 0;
    }
    ```

## 检查键盘

当我们将系统分解为更多可用的脚本时，我们不妨将所有键盘控件放入一个脚本中。这将简化我们将来创建的代码，并允许我们轻松更改控件或提供替代控件。

创建一个新脚本，`scr_Keyboard_Input`并编写以下代码：

```html
keyLeft  = keyboard_check(vk_left);
keyRight  = keyboard_check(vk_right);
keyDown  = keyboard_check(vk_down);
keyUp  = keyboard_check(vk_up);
keyJump = keyboard_check(ord('X'));
keyShoot = keyboard_check(ord('Z'));
```

与实际的键名相比，我们的代码将更易于使用变量（如`keyJump`和`keyShoot`）来表示控件。为了使用键盘上的字母键，我们需要相关的 ASCII 码。我们可以使用`ord`功能，将字母转换成正确的数字，而不必查找每个键号。

### 注

使用`ord`功能时，请务必使用大写字母，否则可能会给出错误的数字！

我们现在有了这个游戏所需要的所有通用系统。下一步我们将实施它们。

# 打造玩家

我们正在构建的玩家角色是我们迄今为止创建的最复杂的对象。玩家不仅会跑和跳，控制本身也会略有不同，这取决于玩家是在地面上还是在空中。玩家需要知道他们面对的方向、播放的动画、是否可以射击武器以及射击角度。让我们从导入所有精灵开始构建：

1.  创建一个新的精灵`spr_Player_Idle`，并在`Chapter 5/Sprites/Player_Idle.gif`中加载选中了**移除背景**的精灵。
2.  将**原点**设置为**X**：`32`**Y**：`63`，使其水平放置在中心，垂直放置在精灵底部。
3.  点击**修改掩码**打开**掩码属性**编辑器，选择**边框****手册**。将值设置为**左**：`16`、**右**：`48`、**上**：`8`、**下**：`63`。
4.  对以下精灵重复此过程，包括相同的**原点**和**遮罩属性**：
    *   `spr_Player_IdleUp`
    *   `spr_Player_IdleDown`
    *   `spr_Player_Run`
    *   `spr_Player_RunUp`
    *   `spr_Player_RunDown`
    *   `spr_Player_InAir`
    *   `spr_Player_Damage`
5.  创建一个对象`obj_Player`，并将`spr_Player_Idle`指定为**精灵**。
6.  First we need to initialize all the variables the player character will need, starting with the ones necessary for animation. Create a new Script, `scr_Player_Create`, with the following code:

    ```html
    myIdle = spr_Player_Idle;
    myIdleUp = spr_Player_IdleUp;
    myIdleDown = spr_Player_IdleDown;
    myRun = spr_Player_Run;
    myRunUp = spr_Player_RunUp;
    myRunDown = spr_Player_RunDown;
    myInAir = spr_Player_InAir;
    myDamage = spr_Player_Damage;
    ```

    在这里，我们将确定用于各种动画状态的精灵。为了使用我们创建的动画系统，我们在这里使用的变量必须与我们在`scr_Animation_Control`中声明的变量相同。

7.  接下来，我们将为碰撞系统添加变量，但在此之前，我们应该为朝向方向再添加两个常量。打开**资源****定义常数**，增加`RIGHT`值`1`和`LEFT`值`-1`。这些数字将表示绘制图像的比例，负值反转精灵。
8.  At the end of `scr_Player_Create` add the rest of the variables we need:

    ```html
    mySpeed = 8;
    myAim = 0;
    facing = RIGHT;
    action = IDLE;
    isDamaged = false;
    canFire = true;
    ```

    在这里，我们有玩家速度的变量，玩家瞄准的方向，他们面对的方向，以及他们所处的状态。我们还增加了一些变量，比如玩家是否能够承受伤害，是否无懈可击，以及他们是否能够射击。我们现在已经初始化了所有变量。

9.  在`obj_Player`中，添加**创建**事件并应用`scr_Player_Create`脚本。
10.  We have a collision forecasting system ready to go, we just need to use it appropriately. Create a new Script, `scr_Player_BeginStep`, and use it to call the forecasting script and the keyboard checks:

    ```html
    scr_Collision_Forecasting();
    scr_Keyboard_Input();
    ```

    您创建的每个脚本实际上都是一个可执行函数。如图所示，您只需编写脚本的名称，并在末尾加上括号即可运行该代码。我们将经常使用这种方法。

11.  在`obj_Player`中添加**步骤****开始步骤**事件并应用`scr_Player_BeginStep`。**开始步骤**事件是要执行的每个步骤中的第一个事件。随后是**步骤**事件，**结束步骤**是实例在屏幕上绘制之前的最后一个事件。这使我们能够更好地控制代码的运行时间。
12.  Next we need to create the controls. As we mentioned earlier, there are actually two separate control systems, one for on the ground and one for in the air. We will start with the latter as it is the simplest. Create a new Script, name it `scr_Player_AirControls` with the following code:

    ```html
    scr_Gravity();

    if (keyLeft && canGoLeft) 
    {
        if (hspeed > -mySpeed) { hspeed -= 1; }
        facing = LEFT;
        myAim = 180;
    }
    if (keyRight && canGoRight) 
    {
        if (hspeed < mySpeed) { hspeed += 1; }
        facing = RIGHT;
        myAim = 0;
    }
    ```

    您应该注意的第一件事是，我们不再在代码中使用像`==`这样的运算符。这些变量都是布尔值，所以它们只能是真或假。书写`keyLeft`与书写`keyLeft == true`相同，但效率更高。

    既然玩家在空中，我们要做的第一件事就是施加重力。接下来是水平运动的控制。我们检查是否按下了相应的键，以及播放机是否能够朝上述方向移动。如果这些是真的，我们检查水平速度与最大速度。如果玩家能够提高速度，我们会稍微增加速度。这可以防止玩家在空中快速改变方向。我们通过设置朝向和瞄准方向来跟进。

13.  We can now move on to the much more complicated ground controls. Create a new Script and name it `scr_Player_GroundControls`. We will start by writing the idle state:

    ```html
    if (!keyLeft && !keyRight) 
    {
        if (hspeed >= 1) { hspeed -= 1; }
        if (hspeed <= -1) { hspeed += 1; }
    }
    ```

    我们首先检查左键和右键是否都没有被按下。如果没有按下按键，播放器正在移动，我们会检查它们的移动方向，然后相应地降低速度。这实际上意味着玩家将滑到停止状态。

14.  The player has come to a stop, but it is not yet idling. To do this we need to determine if the player is using the up or down keys as that will affect which direction the player is aiming. Insert this next code immediately after the last line of code, but inside the last brace:

    ```html
    if (keyUp) 
    { 
        action = IDLEUP; 
        myAim = 45;
    } else if (keyDown) {   
        action = IDLEDOWN; 
        myAim = 315;
    } else { 
        action = IDLE;
        if (facing == LEFT) { myAim = 180; }
        if (facing == RIGHT) { myAim = 0; }
    }
    ```

    我们首先检查是否按下了向上键，如果是，我们将动作更改为`IDLEUP`，并将瞄准设置为 45 度，以便玩家向上射击。如果这不是真的，我们检查向下键，并在适当的情况下更改动作和目标。最后，如果这两个键都没有按下，我们进入标准`IDLE`。然而，为了达到这个目的，我们需要看看球员首先面对的是哪条路。从现在起，玩家将正常空闲。

15.  Next we can add the left and right controls. After the very last brace, write the following code:

    ```html
    if (keyLeft && canGoLeft)
    {
        hspeed = -mySpeed;
        facing = LEFT;
        if (keyUp) 
        { 
            action = RUNUP; 
            myAim = 150; 
        } else if (keyDown) {
            action = RUNDOWN;
            myAim = 205; 
        } else { 
            action = RUN;
            myAim = 180;
        }
    }
    ```

    我们检查左键是否已按下，播放器是否可以向左移动。如果是这样，我们设置水平速度，并将朝向设置为向左。我们再次检查上下键当前是否按下，然后将动作和目标设置为正确的值。

16.  用相应的值对右键重复最后一步。玩家现在可以左右移动了。
17.  All we need now is to add in the jump. Immediately after the previous code add:

    ```html
    if (keyJump && isOnGround)
    {
        vspeed = -MAXGRAVITY;
        action = INAIR;
    }
    ```

    我们检查是否按下了跳跃键，以及球员是否在地面上。如果这是真的，我们将垂直速度向上设置为最大重力，并将动作设置为`INAIR`。

18.  地面控制现在已经完成；以下是`scr_Player_GroundControls`应该是什么样子：

    ```html
    if (!keyLeft && !keyRight)
    {
        if (hspeed >= 1) { hspeed -= 1; }
        if (hspeed <= -1) { hspeed += 1; }

        if (keyUp) 
        { 
            action = IDLEUP; 
            myAim = 45;
        } else if (keyDown) {   
            action = IDLEDOWN; 
            myAim = 315;
        } else { 
            action = IDLE;
            if (facing == LEFT) { myAim = 180; }
            if (facing == RIGHT) { myAim = 0; }
        }
    }
    if (keyLeft && canGoLeft)
    {
        hspeed = -mySpeed;
        facing = LEFT;
        if (keyUp) 
        { 
            action = RUNUP; 
            myAim = 150; 
        } else if (keyDown) { 
            action = RUNDOWN; 
            myAim = 205; 
        } else { 
            action = RUN; 
            myAim = 180; 
        }
    }
    if (keyRight && canGoRight)
    {
        hspeed = mySpeed;
        facing = RIGHT;
        if (keyUp) 
        { 
            action = RUNUP; 
            myAim = 30;
        } else if (keyDown) { 
            action = RUNDOWN; 
            myAim = 335;
        } else { 
            action = RUN; 
            myAim = 0;
        }
    }
    if (keyJump && isOnGround)
    {
        vspeed = -MAXGRAVITY;
        action = INAIR;
    }
    ```

19.  让我们进入玩家攻击。首先，我们需要构建子弹，因此创建一个新的精灵`spr_Bullet`，并在`Chapter 5/Sprites/Bullet.gif`中加载**移除背景**复选框。将**原点**居中，然后点击**确定**。
20.  创建一个新对象`obj_Bullet`，并将`spr_Bullet`应用为**精灵**。
21.  我们希望子弹总是在所有东西前面，所以将**深度**设置为`-2000`。
22.  We are now done with the Bullet and can now write the attack code. Create a new Script, `scr_Player_Attack`, and write the following:

    ```html
    if (keyShoot && canFire)  
    {
        bullet = instance_create(x + (8 * facing), y-32, obj_Bullet) 
        bullet.speed = 16;
        bullet.direction = myAim;
     bullet.image_angle = myAim;
        alarm[0] = 10;
        canFire = false;
    }
    ```

    我们首先检查是否按下了攻击键，以及是否允许玩家射击。如果是这样，我们从枪尖创建一个子弹实例，并将唯一 ID 捕获到一个变量中。此项目符号的水平位置使用 facing 变量将其向左或向右偏移。我们设置子弹的速度，然后设置方向和图像旋转到玩家瞄准的位置。然后，我们设置一个警报，用于重置`canFire`变量，我们将其更改为`false`。

23.  At this point we have several scripts for movement, attacking, and animation, but none of them have been applied. To do this we need one more script, `scr_Player_Step`, calling the other scripts as follows:

    ```html
    if (isOnGround)
    {
        scr_Player_GroundControls();
    } else {
        scr_Player_AirControls();
    }
    scr_Player_Attack();
    scr_Animation_Control();
    ```

    首先，我们通过查看玩家是否在地面上来确定需要使用哪些控件。然后，我们运行相应的控制脚本，然后是攻击脚本，最后是动画控制。

24.  在`obj_Player`中，添加**步骤****步骤**事件并应用`scr_Player_Step`。
25.  在我们测试之前，我们仍然需要重置警报。创建一个新脚本`scr_Player_Alarm0`，并将`canFire`设置为`true`。

    ```html
    canFire = true;
    ```

26.  Add an **Alarm** | **Alarm 0** event and apply this script.

    球员已经准备好接受测试。为确保正确设置播放机，它应如以下屏幕截图所示：

    ![Building the player](img/4100_05_03.jpg)

# 布置房间

我们有玩家现在我们需要一个世界来放置它。由于我们正在制作一个平台，我们将使用两种类型的构建块：地面对象和平台对象。场地对玩家来说将是不可通行的，并将用于外围。平台对象将允许玩家跳过并降落在平台上：

1.  创建一个新的精灵`spr_Ground`，并在`Chapter 5/Sprites/Ground.gif`中加载未选中的**移除背景**。点击**确定**。
2.  创建一个新对象`obj_Ground`，并将`spr_Ground`指定为**精灵**。
3.  勾选**固体**框。这是必要的，因为我们的碰撞代码正在查找实体对象。
4.  让我们来测试一下。创建一个新房间，在**设置**选项卡下，将名称更改为`BossArena`，并将**宽度**更改为`800`。我们需要一个大一点的房间来战斗。
5.  在房间边界周围添加实例`obj_Ground`。同时在房间地板附近添加一个`obj_Player`实例。
6.  运行游戏。在这一点上，玩家应该能够在房间里跑和跳，但不能穿过墙壁或地板。你也应该能够向不同的方向射击你的武器。还请注意，动画系统正在按预期工作，精灵将根据玩家的动作进行更改。
7.  现在来构建平台。创建一个新的精灵`spr_Platform`，并在`Chapter 5/Sprites/Platform.gif`中加载未选中的**移除背景**。点击**确定**。
8.  创建一个新对象`obj_Platform`，并将`spr_Platform`指定为**精灵**。
9.  We want the platform to be solid only when the player is above it. For this we will need to create a new Script, `scr_Platform_EndStep`, with the following code:

    ```html
    if (obj_Player.y < y) 
    {
        solid = true;
    } else {
        solid = false;
    }
    ```

    这里，我们将玩家的 Y 坐标与实例的 Y 坐标进行比较。如果玩家在上面，那么平台应该是坚固的。否则它不是实心的，玩家可以跳过它。

10.  在`obj_Platform`中，添加**步骤****结束步骤**事件并应用此脚本。我们在这一步结束时运行这段代码，因为我们只想在玩家实际移动之后，但在它进行另一次预测之前进行更改。
11.  Go back into the `BossArena` and add some platforms for the player to jump onto. The player can only jump around 128 pixels, so make sure the platforms are placed appropriately, such as can be seen below.

    ![Setting up the room](img/4100_05_04.jpg)

12.  运行游戏。玩家应该能够跳过平台并在顶部着陆。

我们已经成功开发了一系列平台游戏系统。它要求我们将常见元素（如动画系统和控件）分离成独特的脚本。如果我们停在这里，可能会觉得我们做了很多额外的工作，却一无所获。然而，当我们开始构建我们的老板之战时，我们将开始收获这一努力的回报。

# 打造老板大战

Boss 战斗是游戏中最令人愉快的体验之一。建立一个好的老板之战总是一个挑战，但背后的理论非常简单。要遵循的第一条规则是，老板应该包括三个增加难度的独特阶段。第二条规则是老板应该强调用户已经掌握的最新技能。第三条也是最后一条规则是，玩家应该总是有事情做。

我们的老板之战不是针对另一个角色，而是针对一个堡垒。第一阶段将由三门可伸缩的大炮组成，这些大炮将在整个房间内发射炮弹。必须摧毁所有三门大炮才能进入第二阶段。第二阶段将有一个强大的激光炮，可以上下移动，并发射一个房间宽的激光束，玩家需要避免。最后一步是摧毁由两个护盾保护的凸台核心。护罩将仅在短时间内打开。在整个老板大战中，无论球员在房间里的什么地方，都会有一把坚不可摧的枪向他们射击。在每一个进步阶段，这种枪的发射速度都会更快，使游戏更具挑战性。让我们开始打造老板吧！

## 打造坚不可摧的大炮

我们将以坚不可摧的大炮开始，因为它将是贯穿整个战斗的主要 boss 攻击。枪需要旋转，以便始终指向玩家。当它射击枪弹时，枪弹的实例将来自枪尖，并沿枪弹指向的方向移动：

1.  让我们从制造枪弹开始。创建一个新的精灵`spr_Gun_Bullet`，并在`Chapter 5/Sprites/Gun_Bullet.gif`中加载选中了**移除背景**的精灵。将**原点**居中，点击**确定**。
2.  创建一个新对象`obj_Gun_Bullet`，并将`spr_Gun_Bullet`指定为**精灵**。
3.  我们希望子弹总是出现在地面和平台的顶部。将**深度**设置为-`2000`。
4.  The Gun Bullet is going to damage the player on contact, as will all the other projectiles. Once again, let's build a single system that all weapons can use. Create a new Script, `scr_Damage`, with the following code:

    ```html
    if (obj_Player.action != DAMAGE)
    {
        health -= myDamage;
        with (obj_Player) 
        { 
            y -= 1;
            vspeed = -MAXGRAVITY;
            hspeed = 8 * -facing;
            action = DAMAGE;
            isDamaged = true; 
        }
    }
    ```

    这个脚本是专门为敌人的武器编写的。我们首先检查球员是否已经受伤，这样球员就不会受到重复的惩罚。然后，我们通过变量`myDamage`指示的值来减少整体健康度。通过使用这样的变量，我们可以让不同的武器应用不同的伤害。然后我们通过`with`语句直接影响玩家。我们想将播放器发射到空中，但首先我们需要将播放器从地面上升起一个像素，以确保地面碰撞代码不会将其击落。接下来，我们在它们面对的相反方向上应用垂直速度和水平速度，以产生推回效应。我们将玩家的动作设置为`DAMAGE`状态，并指示伤害已经发生。

5.  创建另一个新脚本`scr_Gun_Bullet_Create`，并初始化`myDamage`变量。然后将其应用于`obj_Gun_Bullet`中的**创建**事件。

    ```html
    myDamage = 5;
    ```

6.  接下来让我们创建一个碰撞脚本`scr_Gun_Bullet_Collision`，它调用伤害脚本并移除子弹。我们没有将实例的销毁放在`scr_Damage`中，因此我们可以选择无法销毁的武器，请使用以下脚本：

    ```html
    scr_Damage();
    instance_destroy();
    ```

7.  我们现在可以将**碰撞****obj_ 玩家**事件添加到`obj_Gun_Bullet`中，并附上此脚本。枪弹现在完成了。
8.  我们现在可以讨论枪本身了。首先创建两个新精灵，`spr_Gun_Idle`和`spr_Gun_Run`。将`Chapter 5/Sprites/Gun_Idle.gif`和`Chapter 5/Sprites/Gun_Run.gif`加载到其关联的精灵，并选中**移除背景**。
9.  枪精灵的枪管朝向右侧，因此我们需要将原点设置在左侧，使其正确旋转。将两个精灵上的**原点**设置为**X**：`0`和**Y**：`16`，然后单击**确定**。
10.  创建一个新对象`obj_Gun`，并将`spr_Gun_Idle`指定为**精灵**。
11.  我们希望确保枪始终保持在凸台顶部，因此将**深度**设置为`-1000`。
12.  We need to initialize some variables in a new Script, `scr_Gun_Create`, which will be added to `obj_Gun` as a **Create** event:

    ```html
    action = IDLE;
    facing = RIGHT;
    tipOfGun = sprite_width;
    canFire = false;
    delay = 90;
    alarm[0] = delay;

    myIdle = spr_Gun_Idle;
    myRun = spr_Gun_Run;
    ```

    我们将在这里使用动画系统，因此我们需要为动作和所需的面变量设置值。以下四个变量与枪的射击有关。首先是`tipOfGun`对于枪管末端的位置，`canFire`是触发器，`delay`是两次射击之间的停顿时间，报警器将发射枪弹。最后，我们需要应用两种动画状态。我们不需要添加所有其他变量，例如`myDamage`，除非对象使用该状态。

13.  Next we will have the Gun track the player and determine when to shoot. Create a new Script, `scr_Gun_Step`, which will be placed in a **Step** | **Step** event. Here's the code we need:

    ```html
    scr_Animation_Control();

    if (image_index > image_number-1)
    {
        action = IDLE;
    }

    if (canFire) 
    {
        action = RUN;
        alarm[1] = 5;
        canFire = false;
    }

    image_angle = point_direction(x, y, obj_Player.x, obj_Player.y);
    ```

    我们从运行动画脚本开始。我们希望枪只播放一次射击动画，因此我们将检查当前显示的图像与精灵的最后一张图像。使用`image_number`可以得到帧数，但我们需要减去 1，因为动画的帧数从零开始。如果是最后一帧，则枪进入`IDLE`状态。下一步，我们检查一下枪是否会开火。如果是，我们改变状态播放拍摄动画，设置第二个警报 5 帧，然后关闭`canFire`。最后，我们根据枪和玩家之间的角度旋转精灵来跟踪玩家。

14.  我们在这个物体上使用了两个警报。第一个警报启动射击动画，第二个警报创建枪弹。让我们从第一个警报开始，为**警报****警报 0**事件创建一个新脚本`scr_Gun_Alarm0`：

    ```html
    canFire = true;
    ```

15.  The second alarm has the code for firing the Gun Bullet. Create a new Script, `scr_Gun_Alarm1`, that will be added as an **Alarm** | **Alarm 1** event:

    ```html
    myX = x + lengthdir_x(tipOfGun, image_angle);
    myY = y + lengthdir_y(tipOfGun, image_angle); 
    bullet = instance_create(myX, myY, obj_Gun_Bullet);
    bullet.speed = 16;
    bullet.direction = image_angle;
    alarm[0] = delay;
    ```

    因为我们需要子弹离开枪管的末端，所以我们需要一些三角函数。我们可以使用正弦和余弦从圆的原点和径向距离计算 X 和 Y 值，但有一种更简单的方法。在这里，我们使用`lengthdir_x`和`lengthdir_y`为我们做数学运算。它所需要的只是径向距离和角度，然后我们可以将其添加到枪的局部坐标中。一旦我们有了这些变量，我们就可以在适当的位置创建子弹，设置它的速度和方向。最后我们重新设置了第一个警报，这样枪就会再次开火。

16.  We are ready to test the Gun. Open BossArena and place an instance of the Gun on the far right side of the room. Once we are done testing we will be removing the gun from the room, so exact placement doesn't matter at this time.

    ![Creating the indestructible Gun](img/4100_05_05.jpg)

17.  运行游戏。无论玩家在房间里的什么地方，枪都应该跟着他们，并且每三秒发射枪子弹。如果玩家被枪弹击中，他们将被发射到空中，并被击退，如前一个屏幕截图所示播放损坏动画。
18.  There is one issue, however, with the player's damage state; the player can still move and shoot. This isn't much of a deterrent to being shot, so let's fix this. Create a new Script, `scr_Player_Damage`, with the following code:

    ```html
    if (isOnGround)
    {
        isDamaged = false;
    } else {
        scr_Gravity();
    }
    ```

    我们检查玩家是否在地面上，因为这将停用伤害状态。如果球员在空中，我们施加重力，就是这样。

19.  Now we need to call this script. Reopen `scr_Player_Step` and add a conditional statement for whether the player is damaged or not. Here is the entire script with the new code in bold:

    ```html
    if (isDamaged)
    {
     scr_Player_Damage();
    } else {
        if (isOnGround)
        {
            scr_Player_GroundControls();
        } else {
            scr_Player_AirControls();
        }
        scr_Player_Attack(); 
    }
    scr_Animation_Control();
    ```

    我们检查玩家是否处于伤害模式，如果是，我们运行伤害脚本。否则，`else`语句中的所有控制系统将正常工作。无论损坏情况如何，始终调用动画脚本。

20.  运行游戏。现在，当玩家被击中时，影响是非常明显的。

## 建造第一阶段：大炮

第一个阶段武器是一门加农炮，为了保护自己而隐藏起来，只暴露在射击中。我们将有三门大炮堆叠在一起，让玩家不得不跳上平台。要摧毁大炮，玩家需要在大炮暴露的情况下射击每一门大炮：

1.  从炮弹开始，创建一个新的精灵`spr_Cannonball`，并将**移除背景**选中后加载`Chapter 5/Sprites/Cannonball.gif`。
2.  将**原点**设置为**X**：`12`、**Y**：`32`并点击**确定**。
3.  创建一个新对象`obj_Cannonball`，并将`spr_Cannonball`指定为**精灵**。
4.  将**深度**设置为`-900`，使其出现在大多数物体的前面。
5.  To use the damage system, we need to set the proper variables in the **Create** event with a new script, `scr_Cannonball_Create`:

    ```html
    myDamage = 10;
    hspeed = -24;
    ```

    此武器威力强大，造成 10 点伤害。我们还设置了水平速度，以便它在房间中快速移动。

6.  如果炮弹与玩家接触，我们不会摧毁它，所以我们需要做的就是将`scr_Damage`应用于**碰撞****obj_ 玩家**事件。炮弹现在准备射击。
7.  大炮需要五个精灵，`spr_Cannon_IdleDown`、`spr_Cannon_IdleUp`、`spr_Cannon_RunDown`、`spr_Cannon_RunUp`和`spr_Cannon_Damage`。从`Chapter 5/Sprites/`文件夹加载相关文件，无需选中**删除背景**。
8.  创建一个新对象`obj_Cannon`，并将`spr_Cannon_IdleDown`指定为**精灵**。
9.  将**深度**设置为`-1000`，使加农炮位于其余凸台部件的前面。
10.  As always, let's create a new Script, `scr_Cannon_Create`, to initialize all the variables in the **Create** event:

    ```html
    myHealth = 20;
    action = IDLEDOWN;
    facing = RIGHT;
    canFire = false;

    myIdleUp = spr_Cannon_IdleUp;
    myIdleDown = spr_Cannon_IdleDown;
    myRunUp = spr_Cannon_RunUp;
    myRunDown = spr_Cannon_RunDown;
    myDamage = spr_Cannon_Damage;
    ```

    加农炮在被摧毁之前会遭受几次打击，因此我们有一个`myHealth`变量来跟踪伤害。然后，我们面朝右侧设置动作状态，因为我们没有翻转精灵，并建立一个拍摄变量。然后我们就有了加农炮工作所需的所有动画状态。

11.  Next we can create a new Script, `scr_Cannon_Step`, for a **Step** | **Step** event with the functionality for switching states and firing the Cannonballs:

    ```html
    scr_Animation_Control();

    if (image_index > image_number-1)
    {
        if (action == RUNUP) { action = IDLEUP;}
        else if (action == RUNDOWN) { action = IDLEDOWN;} 
    }

    if (canFire) 
    {
        action = RUNUP;
        alarm[0] = 60;
        canFire = false;
    }

    if (myHealth <= 0)
    {
        instance_destroy();
    }
    ```

    与 Gun 类似，我们从调用动画系统脚本开始。然后检查加农炮是否在动画的最后一帧上。这里我们有两种不同的空闲状态，这取决于大炮是否暴露。我们检查处于哪个状态，并设置适当的空闲状态。接下来，我们检查加农炮是否应该发射，如果应该，我们暴露加农炮并设置警报，在两秒钟内制造炮弹。最后，我们做一个健康检查，如果加农炮失去生命，它将退出游戏。

12.  Create a new Script, `scr_Cannon_Alarm0`, and add it to an **Alarm** | **Alarm 0** event with the following code:

    ```html
    instance_create(x, y, obj_Cannonball);
    action = RUNDOWN;
    ```

    在这里，我们只需创建一个炮弹，然后设置动画以收回大炮。

13.  The last thing we need to do with the Cannon is have it take damage. Create a new Script, `scr_Cannon_Collision`, and apply it to a **Collision** | **obj_Bullet** event with the following code:

    ```html
    if (action == IDLEUP)
    {
        myHealth -= 10;
        action = DAMAGE;
        with (other) {instance_destroy();}
    }
    ```

    我们首先要确保只有在大炮暴露的情况下才会造成伤害。如果是的话，我们将获得它的 10 点生命值，更改为伤害动画，并移除子弹。大炮现在完成了。

14.  在尝试测试大炮之前，我们将开始构建 Boss。大炮不是独立运行的，而是由老板控制的。创建一个名为`obj_Boss`的新对象。没有要指定的精灵，因为 Boss 由其他对象组成。
15.  Create a new Script, `scr_Boss_Create`, to initialize variables in the **Create** event:

    ```html
    isPhase_01 = true;
    isPhase_02 = false;
    isPhase_03 = false;
    isBossDefeated = false;

    boss_X = 672;
    gun = instance_create(32, 32, obj_Gun);
    cannonA = instance_create(boss_X, 64, obj_Cannon);
    cannonB = instance_create(boss_X, 192, obj_Cannon);
    cannonC = instance_create(boss_X, 320, obj_Cannon); 
    ```

    我们首先确定三个阶段的变量，以及老板是否被击败。然后，我们使用位于房间左上角的坚不可摧的大炮和位于老板所在位置的炮塔，为老板的 X 位置创建一个变量。我们为每种武器建立变量，以便老板能够控制它们。

16.  我们希望大炮按顺序射击，而不是一起射击。为此，我们将使用时间线。创建新的时间线并将其命名为`tm_Boss_Phase01`。
17.  增加一个**力矩**并设置**表示力矩**到`180`。这将在战斗开始六秒钟后开始。
18.  Create a new Script, `scr_Phase01_180`, and fire the middle Cannon. Apply this script to the Time Line:

    ```html
    if (instance_exists(cannonB)) { cannonB.canFire = true;}
    ```

    由于玩家可以摧毁大炮，我们需要检查大炮是否仍然存在。如果是，我们将 Cannon 的`canFire`变量设置为 true，Cannon 代码将处理其余的。

19.  在`360`处增加另一**时刻**。
20.  Create a Script, `scr_Phase01_360`, and activate the other two Cannons:

    ```html
    if (instance_exists(cannonA)) { cannonA.canFire = true; }
    if (instance_exists(cannonC)) { cannonC.canFire = true; }
    ```

    我们需要分别检查两门大炮，这样，如果一门被摧毁，另一门仍然会开火。

21.  重新打开`scr_Boss_Create`并在最后一行代码

    ```html
    timeline_index = tm_Boss_Phase01;
    timeline_running = true;
    timeline_loop = true;
    ```

    后开始循环时间行
22.  重新打开`BossArena`并确保移除枪的实例（如果枪仍在房间中）。
23.  在地图右侧放置一个`obj_Boss`的实例，尽管实际位置并不重要。
24.  None of the parts of the Boss have the **Solid** attribute, which means the player can run through them. To fix that, create a barrier wall in front of the Boss with instances of `obj_Ground` as seen in the following screenshot:

    ![Constructing the first phase: The Cannons](img/4100_05_06.jpg)

25.  Run the game. At the start we should see three Cannons stacked on top of each other and the indestructible Gun. The Gun should aim at the player and shoot a Gun Bullet every few seconds. Six seconds into the game we should see the middle Cannon power up and shortly afterwards shoot a Cannonball. Six seconds after that, the upper and lower Cannons should do the same. If the player is hit by an enemy projectile they will be knocked back. The player's bullets will pass by the Cannons unless they have been exposed, in which case the Cannon will go into its damage state and the bullet disappears. If any Cannon is hit two separate times it will blink out of existence. The first phase is now complete and should look like the following screenshot:

    ![Constructing the first phase: The Cannons](img/4100_05_07.jpg)

## 建造第二阶段：巨型激光炮

一旦玩家摧毁所有大炮，第二阶段将开始。在这里，我们将有一个巨大的激光扫描，不断地上下移动。每隔几秒钟，它就会发射一束大激光束，激光束将穿透整个房间。玩家可以随时损坏激光炮，但它的生命值会更高：

1.  首先，我们将创建激光束。创建一个新的精灵`spr_LaserBeam`，加载`Chapter 5/Sprites/LaserBeam.gif`而不选中**删除背景**。精灵可能看起来很小，只有八个像素宽，但我们将在屏幕上拉伸这个精灵，这样它就可以在任何房间工作。
2.  我们需要原点位于右侧，以便它与激光扫描管正确对齐。将**原点**设置为**X**：`8`和**Y**：`32`。
3.  创建一个新对象`obj_LaserBeam`，应用`spr_LaserBeam`作为**精灵**，并将**深度**设置为`-600`。
4.  Create a new Script, `scr_LaserBeam_Create`, to initialize variables in a **Create** event:

    ```html
    myDamage = 20;
    myLaserCannon = 0; 
    image_xscale = room_width / 8;
    ```

    这种武器的伤害远高于其他武器，适合第二阶段。我们还有一个`myLaserCannon`变量，用于在激光扫描移动时保持激光束与激光扫描对齐。该值已设置为零，但这将成为生成该值的激光扫描的 ID，稍后我们将看到该 ID。最后，我们把雪碧伸展到房间的另一端。变量`image_xscale`是一个乘数，这就是为什么我们将房间宽度除以 8，精灵的宽度。

5.  Next we will use a **Step** | **End Step** event with a new Script, `scr_LaserBeam_EndStep`, to make the beam move with the LaserCannon.

    ```html
    x = myLaserCannon.x;
    y = myLaserCannon.y;
    ```

    我们用产生激光束的激光扫描仪移动 X 和 Y 坐标。我们将其放入**结束步骤**事件中，因为激光扫描将在**步骤**事件中移动，这将确保其始终处于正确位置。

6.  剩下的就是将`scr_Damage`添加到**碰撞****obj_ 玩家**事件中。激光束现在完成了。
7.  在激光扫描上，我们需要创建三个精灵：`spr_LaserCannon_Idle`、`spr_LaserCannon_Run`和`spr_LaserCannon_Damage`。从`Chapter 5/Sprites/`文件夹加载所有需要检查**删除背景**的相关文件。
8.  将三个精灵的**原点**设置为**X**：`16`和**Y**：`56`。这将有助于将激光束放置在我们想要的位置。
9.  创建一个新对象`obj_LaserCannon`，并将`spr_LaserCannon _Idle`指定为**精灵**。
10.  将**深度**设置为`-700`，使激光炮位于火炮和火炮后面，但在激光束前面。
11.  For initializing variables in the **Create** event, create a new Script, `scr_Laser_Create`, with the following code:

    ```html
    myHealth = 50;
    mySpeed = 2;
    myBuffer = 64;
    action = IDLE;
    facing = RIGHT;
    canFire = false;

    myIdle = spr_LaserCannon _Idle;
    myRun = spr_LaserCannon _Run;
    myDamage = spr_LaserCannon _Damage;
    ```

    我们首先为激光扫描的健康状况、当前状态、朝向以及它是否正在拍摄设置所有标准变量。然后，我们为激光扫描具有的三种状态设置所有动画系统变量。

12.  Next is building the functionality of the laser. Create a new Script, `scr_LaserCannon_Step`, and add it to a **Step** | **Step** event with the following code:

    ```html
    scr_Animation_Control();

    if (image_index > image_number-1)
    {
        action = IDLE;
    }

    if (canFire) 
    {
        action = RUN;
        alarm[0] = 5;
        canFire = false;
    }

    if (myHealth <= 0)
    {
        instance_destroy();
    }
    ```

    这看起来应该很熟悉了。我们首先运行动画系统脚本。然后，我们检查动画的最后一帧是否已播放，如果已播放，请将 LaserCannon 设置为其空闲状态。接下来，如果激光扫描仪要拍摄，我们将改变状态并设置短警报，以便在播放拍摄动画后创建激光束。最后，我们做一个健康检查，如果激光扫描不健康，就将其移除。

    我们还没有完成这个脚本。我们还需要加入这场运动。首次创建激光扫描时，它不会移动。我们不希望它在第二阶段开始之前开始移动。在这一点之后，我们希望激光扫描能够处理垂直运动。

13.  为了使激光炮上下移动，我们所需要做的就是在它通过一个端点时将其发送到相反的方向。在`scr_LaserCannon_Step`：

    ```html
    if (y < myBuffer)
    {
        vspeed = mySpeed;
    }
    if (y > room_height - myBuffer)
    {
        vspeed = -mySpeed;
    } 
    ```

    中的最后一行代码后立即添加此代码
14.  我们将让激光扫描仪移动整个房间的高度。如果 Y 坐标距顶部小于 64 像素，则向下发送。如果距离房间底部大于 64 像素，则向上发送。稍后我们将在 Boss 脚本中开始该运动。
15.  Let's get the LaserCannon shooting a Laser Beam! The Laser Beam will be created in an **Alarm** | **Alarm 0** event with a new Script, `scr_LaserCannon_Alarm0`, attached with the Laser Beam creation code:

    ```html
    beam = instance_create(x, y, obj_LaserBeam);
    beam.myLaserCannon = self.id;
    ```

    我们在激光炮顶端创建一个光束实例，然后将激光束的`myLaserCannon`变量设置为创建它的激光炮的唯一 ID。这样做的好处是，如果我们愿意，房间里可以有多个激光扫描仪。

16.  The last element we need to construct is the damage state. Create a new Script, `scr_LaserCannon_Collision`, and place it into a **Collision** | **obj_Bullet** event:

    ```html
    if (obj_Boss.isPhase_02)
    {
        myHealth -= 5;
        action = DAMAGE;
        with (other) { instance_destroy(); }
    }
    ```

    由于我们不希望玩家能够在第二阶段之前摧毁激光炮，所以我们检查 Boss 当前处于哪个阶段，以确定是否应该造成伤害。如果 Boss 处于第二阶段，我们将降低激光炮的生命值，将其更改为损坏状态并移除子弹。激光扫描现已完成，并准备在 Boss 中实施。

17.  我们需要做的第一件事情是添加一个 LaserCannon 实例。重新打开`scr_Boss_Create`并在时间线运行前插入此代码：

    ```html
    laser = instance_create(boss_X, 352, obj_LaserCannon);
    ```

18.  接下来，我们将通过创建一条新的时间线并将其命名为`tm_Boss_Phase02`，来构建 LaserCannon 的功能。
19.  要拍摄激光束，请添加一个**时刻**，并将**指示时刻**设置为`210`。
20.  创建一个新脚本`scr_Phase02_210`，并为其分配激活激光扫描的代码：

    ```html
    laser.canFire = true;
    ```

21.  我们希望完全控制激光扫描的持续时间，因此我们将使用时间线来移除激光束。在`270`处增加**力矩**。这将给我们一束持续两秒的激光。
22.  Create a new Script, `scr_Phase02_270`, and remove the Laser Beam.

    ```html
    with (laser.beam) { instance_destroy(); }
    ```

    当激光扫描机发射时，它会创建`beam`变量，我们现在可以使用该变量删除它。

23.  All that is left is to have the Boss change from the first phase to the second phase. For this we will need to add a **Step** | **Step** event to `obj_Boss` with a new Script, `scr_Boss_Step`, assigned with the following code:

    ```html
    if (!instance_exists(obj_Cannon) && !isPhase_02)
    {
        laser.vspeed = laser.mySpeed;
        timeline_index = tm_Boss_Phase02;
        timeline_position = 0;
        gun.delay = 45;
        isPhase_02 = true;
    }
    ```

    首先，我们要检查世界上是否还有剩余的加农炮，如果它们都被摧毁了，我们要检查第二阶段是否已经开始。在第二阶段开始时，我们将激光扫描设置为向下运动，将时间线切换到新阶段，并将时间线重置为开始。我们还将通过减少枪炮射击之间的延迟来增加挑战的难度。我们通过将`isPhase_02`更改为 true 来结束此代码，这样它只执行一次。

24.  Run the game. The gameplay starts out the same as before, but after the three Cannons have been destroyed, we should see the LaserCannon starts to move up and down and fire a Laser Beam every seven seconds. The LaserCannon can be hit at any time and will take several hits before being destroyed. The indestructible Gun should still function as before, but shoot twice as often. The second phase is now complete and should look like the following screenshot:

    ![Building the second phase: The giant LaserCannon](img/4100_05_08.jpg)

## 设置最后阶段：屏蔽凸台铁芯

在最后一个阶段，我们不打算再增加一件武器，而是创造一个由两个盾牌保护的可摧毁的 Boss 核心。护罩将每隔几秒钟打开一次，以露出凸台芯。我们还将把枪改为快速射击：

1.  我们将从 Boss 核心开始。我们需要创建两个新精灵，`spr_BossCore_Idle`和`spr_BossCore_Damage`。选中**移除背景**后，将`Chapter 5/Sprites/BossCore_Idle.gif`和`Chapter 5/Sprites/BossCore_Damage.gif`加载到相应的精灵中。
2.  将两个精灵的**原点**设置为**X**：`-32`和**Y**：`64`，以便将其正确定位在护盾后面。
3.  创建一个新对象`obj_BossCore`，并将`spr_BossCore_Idle`指定为**精灵**。
4.  Boss 核心是一个简单的对象，只需要一些动画状态和运行状况。创建一个新脚本`scr_BossCore_Create`，并按如下方式初始化所需的变量。记住将其分配给**创建**事件：

    ```html
    myHealth = 100;
    action = IDLE;
    facing = RIGHT;

    myIdle = spr_BossCore_Idle;
    myDamage = spr_BossCore_Damage;
    ```

5.  我们需要**步骤****步骤**事件来控制动画状态和处理健康状况，所以创建另一个新脚本`scr_BossCore_Step`，代码如下：

    ```html
    scr_Animation_Control();

    if (action == DAMAGE) 
    {
        if (image_index > image_number-1)
        {
            action = IDLE;
        }
    }

    if (myHealth <= 0)
    {
        instance_destroy();
    }
    ```

6.  All the Boss Core now needs is a **Collision** | **obj_Bullet** event to deal with damage. Create a new Script, `scr_BossCore_Collision`, and write the following code:

    ```html
    if (obj_Boss.isPhase_03 && action == IDLE)
    {
        myHealth -= 2;
        action = DAMAGE;
        with (other) { instance_destroy(); }
    }
    ```

    我们首先检查 Boss 是否处于最后阶段，以及 Boss 核心是否处于空闲状态。如果是，我们将降低生命值并切换到损坏动画。我们还要确保子弹被移除。Boss 核心现在已经完成，我们可以进入护盾。

7.  我们将有两个护盾，一个可以升起，另一个可以放下。让我们带上我们需要的两个精灵。创建两个新精灵，`spr_Shield_Upper`和`spr_Shield_Lower`。将`Chapter 5/Sprites/Shield_Upper.gif`和`Chapter 5/Sprites/Shield_Lower.gif`加载到相关精灵。记得勾选**删除背景**。
8.  将`spr_Shield_Upper`的**原点**设置为**X**：`0`和**Y**：`269`，使原点位于图像的底部。我们不需要更改`spr_Shield_Lower`的**来源**。
9.  创建两个新对象`obj_Shield_Upper`和`obj_Shield_Lower`，并分配适当的精灵。
10.  在两个护罩上，将**深度**设置为`-500`，使其位于凸台核心的前面，但位于凸台所有其他部件的后面。
11.  We will build the upper Shield first and we need to initialize some variables in a new Script, `scr_ShieldUpper_Create`, applied to a **Create** event in `obj_Shield_Upper`:

    ```html
    isShielding = true;
    openPosition = y-64;
    mySpeed = 2;
    ```

    第一个变量将激活屏蔽是向上还是向下。第二个变量设置提升护罩的高度值；在这种情况下，它将向上移动 64 像素。最后，我们为移动速度设置了一个变量。

12.  下护盾几乎完全相同，只是它朝相反的方向移动。再次创建一个新脚本`scr_ShieldLower_Create`，并将其应用于`obj_Shield_Lower`

    ```html
    isShielding = true;
    openPosition = y+64;
    mySpeed = 2;
    ```

    的**创建**事件
13.  Next we will add a **Step** | **Step** event to `obj_Shield_Upper`, with a new Script, `scr_ShieldUpper_Step`, attached with the following code to control the shield's movement:

    ```html
    if (isShielding && y < ystart) { y += mySpeed; }
    if (!isShielding && y > openPosition) { y -= mySpeed; } 
    ```

    我们首先要检查防护罩是否应该落下，以及它是否一直落下。如果不是一直向下，我们就把护盾向下移动一点。第二个`if`语句正好相反，检查防护罩是否应该向上，以及是否一直向上。如果没有，我们就把防护罩抬起来一点。

14.  再一次下护盾几乎完全相同。创建一个新脚本`scr_ShieldLower_Step`，附加到`obj_Shield_Lower`

    ```html
    if (isShielding && y > ystart) { y -= 2; }
    if (!isShielding && y < openPosition) { y += 2; }
    ```

    中的**步骤****步骤**事件
15.  The last element we need to deal with is a **Collision** | **obj_Bullet** event, which both the Shields can use. Create a new Script, `scr_Shield_Collision`, with the following code:

    ```html
    if (obj_Boss.isPhase_03)
    {
        with (other) { instance_destroy(); }
    }
    ```

    防护罩永远不会受到伤害，但它们应该只在最后阶段检测碰撞。

16.  Now that all the objects have been prepared, it is time to implement them into the Boss. Reopen `scr_Boss_Create` and insert the following code after the last weapon:

    ```html
    core = instance_create(boss_X, 272, obj_BossCore);
    shieldUpper = instance_create(boss_X, 272, obj_Shield_Upper);
    shieldLower = instance_create(boss_X, 272, obj_Shield_Lower);
    ```

    我们在同一个位置创建凸台核心和屏蔽。

17.  接下来，我们将创建一个时间表`tm_Boss_Phase03`，以处理盾牌和枪的功能。
18.  Add a **Moment** at `120`, and then create a new Script, `scr_Phase03_120`, with the following code:

    ```html
    shieldUpper.isShielding = false;
    shieldLower.isShielding = false; 
    gun.delay = 10;
    ```

    在这里，我们将打开防护罩并提高枪的射击速度。

19.  在`180`处添加**时刻**并创建一个新脚本`scr_Phase03_180`。我们在这里要做的就是关掉枪的报警器，以便在枪击中有一个短暂的喘息。这是通过将延迟设置为-1 来实现的。

    ```html
    gun.delay = -1;
    ```

20.  在`300`添加另一个**时刻**，并创建一个新脚本`scr_Phase03_300`。现在我们重新启动枪的警报。

    ```html
    gun.delay = 10;
    ```

21.  最后，我们在`360`添加了一个**时刻**和另一个新脚本`scr_Phase03_360`，在这个脚本中，我们降低盾牌并将枪返回到正常的射击速率：

    ```html
    shieldUpper.isShielding = true;
    shieldLower.isShielding = true; 
    gun.delay = 45;
    ```

22.  Now we need to add in the switch from the second phase to the final phase. Reopen `scr_Boss_Step` and add the following code at the end:

    ```html
    if (!instance_exists(obj_LaserCannon) && !isPhase_03)
    {
        timeline_index = tm_Boss_Phase03;
        timeline_position = 0;
        isPhase_03 = true;
    }
    ```

    我们检查激光炮是否被摧毁，我们是否应该处于最后阶段。如果是，我们需要做的就是切换`timeline`，将其设置为开始，并将其设置为最终阶段。

23.  All we need now is a win condition which we will add to the same script. At the end of `scr_Boss_Step` write the last conditional statement:

    ```html
    if (!instance_exists(obj_BossCore) && !isBossDefeated)
    {
        timeline_running = false;
        with (gun) { instance_destroy(); }
        isBossDefeated = true;
    }
    ```

    我们检查 Boss 核心是否被破坏，以及是否调用了 win 条件。如果老板被打败了，我们会停止时间表并宣布失败。

24.  Run the game. It will take some time, but the first two phases should be the same as before and once the LaserCannon has been destroyed, the final phase activates. The Shields should open and the Gun shoots a burst of bullets. There then should be a quiet moment where the player can attack the Boss Core. A few seconds later the Gun should start firing and the Shields will close. This will repeat until the player defeats the Boss. This phase should look like the following screenshot:

    ![Setting the final stage: The shielded Boss Core](img/4100_05_09.jpg)

# 收尾

我们在结束本章时，仍有一些未完成的元素，但您已经有能力自己完成这项工作。还有所有的声音，背景艺术和前端建设。不仅如此，你可能已经注意到玩家不能被杀死。让玩家战无不胜让我们更容易测试 boss 战，所以在加入后再试一次。老板之战相当困难，但也很容易改变。为什么不试着改变每个阶段的计时，或者试着调整损坏的数值呢。为了更进一步，你可以建立导致战斗的等级和敌人。玩得开心，它可能看起来像下面的截图！

![Winding it up](img/4100_05_10.jpg)

# 总结

恭喜你，你刚刚完成了一场史诗般的老板之战！本章开始时，我们深入研究了系统设计并创建了一些非常有用的脚本。我们建立了一个动画系统，游戏中的大多数对象都使用它。我们学习了如何预测碰撞并在玩家身上应用我们自己的自定义重力。我们甚至创造了平台，玩家可以跳过去并降落在上面。我们介绍了常数，它的好处是使代码更容易阅读，对计算机更有效。然后，我们继续构建一个三阶段的 boss 战斗，利用我们以前的所有知识以及我们的新系统。

在下一章中，我们将使用 GameMaker:Studio 的 Box2D 实现创建一个基于物理的游戏。这将使用完全不同的碰撞检测方法和物理系统。它还将允许我们拥有对世界做出反应的对象，而代码很少或没有！