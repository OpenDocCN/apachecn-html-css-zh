# 3

# 媒体查询-支持不同的视图

本章将详细介绍 CSS 媒体查询，希望提供充分理解其功能、语法和未来发展所需的一切。 在适当的地方，我们将使用媒体查询来调整我们的测试站点的基本布局，为更大的屏幕尺寸添加相关的样式。

最后一章以[https://rwd.education/](https://rwd.education/)网站的设计结束。 为了这一章，我写了一些初步的标记，并添加了一些相应的基本的“移动”样式。

如果你在网页浏览器中打开本章的`start`文件夹中的`index.html`文件，你会看到这种设计在具有超薄视图的设备上看起来是可以接受的，比如手机:

<figure class="mediaobject">![](../Images/B15480_03_01.png)</figure>

图 3.1:在较小的视图中，设计看起来很好

然而，当你扩大浏览器窗口时，它很快开始看起来有点伸展:

<figure class="mediaobject">![](../Images/B15480_03_02.png)</figure>

图 3.2:我们确实需要为更宽的视图改变样式

最初的风格是使用流体/比例的方法编写的。 这意味着宽度通常是用百分比而不是固定的像素大小来表示的——结果是，无论浏览器窗口是大是小，内容至少会增长或缩小以填满整个窗口。

然而，这仍然会给你留下一个问题，当你的宽度足够大时，你需要做一些更激烈的事情，而不仅仅是让东西更宽!

我们可以用媒体查询来解决这个问题。

媒体查询允许我们根据设备的功能定位特定的 CSS 样式。 例如，只需几行 CSS，我们就可以根据视口宽度、屏幕长宽比、方向(横向或纵向)等改变内容的显示方式。

在本章中，我们将:

*   了解如何使用 viewport`meta`标签在移动设备上进行媒体查询
*   了解为什么媒体查询对响应式网页设计至关重要
*   理解媒体查询语法
*   学习如何在链接中使用媒体查询，在`@import`语句中，以及在 CSS 文件中
*   了解我们可以测试哪些设备功能
*   考虑是否在一个块中或在任何合适的地方创建类似的媒体查询
*   考虑在媒体查询级别 4 中添加的最新功能，我们可以使用当今的媒体特性，如`pointer`、`hover`和`prefers-color-scheme`

回到*第一章*，*响应式网页设计要点*，我们在网页头部插入`meta`标签，使其在移动设备上工作。 那时，我承诺*第三章*将会准确地解释这个标签是什么，它做什么，以及为什么我们仍然拥有它。 是时候兑现承诺了。

# 视口元标签

当苹果在 2007 年发布 iPhone 时，他们引入了一个专有的`meta`标签，称为视口`meta`标签。 它的目的是提供一种方式，让网页与移动浏览器通信他们希望 web 浏览器如何呈现页面。

如果没有这个`meta`标签，iphone 将把网页渲染成一个 980px 宽的窗口，用户需要放大或缩小窗口。

有了这个`meta`标签，我们就可以按实际尺寸渲染一个网页，然后调整布局，以提供我们现在在手机上浏览互联网时所期望看到的那种网页。

在可预见的未来，任何你想要在小屏幕设备上做出响应和呈现的网页，仍然需要使用这个`meta`标签，因为 Android 和越来越多的其他平台也支持它。

正如您现在所知道的，视口`<meta>`标记被添加到 HTML 的`<head>`标记中。 它可以被设置为特定的宽度(例如，我们可以以像素为单位指定)或者作为缩放，例如，2.0(实际大小的两倍)。 下面是一个 viewport`meta`标签的例子，该标签将浏览器显示为实际大小的两倍(200%):

```html
<meta name="viewport" content="initial-scale=2.0,width=device-width" /> 
```

让我们分解前面的`<meta>`标签，了解发生了什么。 `name="viewport"`属性告诉浏览器这个标记正在处理视口。 `content="initial-scale=2.0`部分然后说,“两倍大小规模的内容”(即 0.5 的一半大小,3.0 的三倍大小,等等),而`width=device-width`部分告诉浏览器,页面的宽度应该等于`device-width`。 `<meta>`标签还可以用来控制用户可以放大或缩小页面的数量。 在这个例子中，用户可以选择大到设备宽度的三倍，小到设备宽度的一半:

```html
<meta name="viewport" content="width=device-width, maximum-scale=3, minimum-scale=0.5" /> 
```

你也可以禁止用户缩放:

```html
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" /> 
```

`user-scalable=no`是这里的相关部分。

然而，由于缩放是一个重要的可访问性需求，因此阻止缩放很少是合适的。 此外，许多浏览器也因此禁用了阻止缩放的功能。

是的，我们将缩放改为 1.0，这意味着移动浏览器将在其视口的 100%处呈现页面。 将其设置为设备的宽度意味着我们的页面应该以所有支持的移动浏览器的宽度的 100%呈现。 对于大多数响应式网页设计案例，这个`<meta>`标签将是合适的:

```html
<meta name="viewport" content="width=device-width,initial-scale=1.0" /> 
```

从响应式设计的角度来看，这应该是关于视口`meta`标签所需要知道的全部内容。 简而言之，确保您添加了一个，否则事情看起来和行为可能不像您预期的那样! 为了确保一切正常，请确保您在实际设备的某个点上进行测试。

注意到 viewport`meta`元素的普遍存在，W3C 试图将的相同功能引入 CSS。 前往[http://dev.w3.org/csswg/css-device-adapt/](http://dev.w3.org/csswg/css-device-adapt/)，阅读所有关于`@viewport`的声明。 其思想是，与其在标记的`<head>`部分中编写`<meta>`标记，不如在 CSS 中声明视口设置。 例如，CSS 中类似`@viewport { width: 320px; }`的内容将把浏览器宽度设置为 320 像素。 然而，浏览器支持不足。 在我写这篇文章时，当所有浏览器都理解 viewport`meta`标签时，将其添加到 CSS 中似乎没什么价值。

# 为什么媒体查询需要一个响应式网页设计

如果你去 W3C 规范CSS3 媒体查询模块(http://www.w3.org/TR/css3-mediaqueries/),你会发现这是他们的官方介绍媒体查询是什么:

> 媒体查询由媒体类型和零个或多个表达式组成，这些表达式用于检查特定媒体特性的条件。 在媒体查询中可以使用的媒体特性有“宽度”、“高度”和“颜色”。 通过使用媒体查询，可以在不改变内容本身的情况下针对特定范围的输出设备定制演示文稿。

当流体布局,创建百分比而不是固定宽度,可以携带一个设计相当距离(我们全额覆盖流体布局在下一章),鉴于屏幕尺寸我们需要覆盖的范围,有些时候我们需要修改布局更显著。 媒体查询使这成为可能——可以把它们看作 CSS 的基本条件逻辑。

## CSS 中的基本条件逻辑

真正的编程语言(T0)都具有某种能力，能够满足两种或更多可能情况中的一种(T1)。 这通常采用条件逻辑的形式，也称为“控制流”，以 if/else 语句为代表。

如果编程语言让你眼睛发痒，不要害怕; 这是一个非常简单的概念。 你可能每次去咖啡馆让朋友帮你点餐的时候都用条件逻辑，“如果他们有三层巧克力松饼，我就点一个; 否则，我就吃一块胡萝卜蛋糕。” 这是一个简单的条件语句，有两种可能的结果。

在编写本文时，CSS 并不能促进真正的条件逻辑或编程特性。 循环、函数、迭代和复杂数学仍然是 CSS 预处理器的唯一领域(我有没有提到一本关于 Sass 预处理器的书，叫做*Sass 和 Compass for Designers*?) 然而，媒体查询是一种机制，它允许我们根据是否满足某些基于媒体的条件来编写应用的基本条件逻辑样式。

# 媒体查询语法

那么 CSS 媒体查询是什么样子的，更重要的是，它是如何工作的?

以下是一个完整但简单的网页，没有内容，但一些基本的风格和媒体查询:

```html
<!DOCTYPE html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Media Query Test</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <style>
      body {
        background-color: grey;
      }
      @media screen and (min-width: 320px) {
        body {
          background-color: green;
        }
      }
      @media screen and (min-width: 550px) {
        body {
          background-color: yellow;
        }
      }
      @media screen and (min-width: 768px) {
        body {
          background-color: orange;
        }
      }
      @media screen and (min-width: 960px) {
        body {
          background-color: red;
        }
      }
    </style>
  </head>
  <body></body>
</html> 
```

复制并保存到一个新文件中，或者，如果您有该书的下载代码，您可以在`example_03-01`中找到它。

现在，在浏览器中打开该文件并调整窗口的大小。 页面的背景颜色将根据当前视口的大小而变化。

默认颜色首先定义，在媒体查询之外; 当任何媒体查询为 true 时，媒体查询内的样式将覆盖默认值。

如果你习惯了，媒体查询的基本语法是很简单的。 您使用`@media`at-rule 来传递媒体查询，然后用括号来编写媒体测试。 测试必须通过，才能应用花括号中的样式。

您可以在 html 中的链接中编写媒体查询—如果媒体查询通过，则加载特定的样式表。 您可以在 CSS`@import`at-rules 上编写媒体查询，以确定应该导入哪些样式表。 您还可以将媒体查询直接写入 CSS 文件，以确定根据哪些媒体查询解析为 true 来应用哪些规则。

让我们依次来看一下。

## 链接标签中的媒体查询

这里是什么媒体查询看起来像一个链接，你会发现在`<head>`部分的标记:

```html
<link rel="stylesheet" media="screen and (orientation: portrait)" href="portrait-screen.css" /> 
```

这个媒体查询是问“你是屏幕吗?你的方向是肖像吗?”

## 对@import at-rule 的媒体查询

下面是关于`@import`语句的相同规则:

```html
@import url("portrait-screen.css") screen and (orientation: portrait); 
```

您可以在那里看到所有相同的组件部分—要加载的文件，以及必须通过的测试。 不同的语法，相同的结果。

在 CSS 中使用`@import`at-rule 使得浏览器从网络请求相关文件，这可能会增加 HTTP 请求的数量。 这有时会对站点的加载速度产生不利影响。

## CSS 文件中的媒体查询

最后，这里是在 CSS 文件中写入的相同的媒体查询，或者在 HTML 中的`style`标记中:

```html
@media screen and (orientation: portrait) {
    /* styles here */
} 
```

## 反转媒体查询逻辑

通过将`not`添加到媒体查询的开头，可以反转任何媒体查询表达式的逻辑。 例如，下面的代码将否定我们之前例子中的结果，加载任何不是纵向屏幕的文件:

```html
<link rel="stylesheet" media="not screen and (orientation: portrait)" href="portrait-screen.css" /> 
```

虽然使用`not`关键字有时很有用，但我发现在需要样式时只考虑应用样式要简单得多。 这样，您就可以坚持编写最简洁、最简单的媒体查询形式。

## 结合媒体查询

将多个表达式串在一起也是可能的。 例如，让我们扩展前面的一个例子，并将文件限制为视口大于 800 像素的设备:

```html
<link rel="stylesheet" media="screen and (orientation: portrait) and (min-width: 800px)" href="800wide-portrait-screen.css" /> 
```

## 许多不同的媒体查询

此外，我们可以拥有一个媒体查询列表。 如果列出的任何查询为真，将加载该文件。 如果没有一个是真的，它就不会是真的。 下面是一个例子:

```html
<link rel="stylesheet" media="screen and (orientation: portrait) and (min-width: 800px), print" href="800wide-portrait-screen.css" /> 
```

这里有两点需要注意。 首先，逗号分隔每个媒体查询，有效地充当一个`or`命令。 其次，您会注意到在`print`之后，没有`and`结尾，也没有括号中的特征/值组合。 这是因为如果没有这些值，媒体查询将应用于所有媒体类型。 在我们的示例中，这些样式将适用于所有打印场景。

您应该知道，您可以使用任何 CSS 长度单位来指定媒体查询。 像素(`px`)是最常用的，但 ems(`em`)和 rems(`rem`)同样有效和适用。

## 日常媒体查询

在这一点上我可能要谨慎地重复一下，在大多数情况下，您实际上不需要指定`screen`。 以下是规范中的关键点:

> 为适用于所有媒体类型的媒体查询提供了一个简写语法; 关键字'all'可以省略(后跟'and')。 例如，如果媒体类型没有明确给出它是'all'。

因此，除非您希望将样式针对特定的媒体类型，否则只需去掉`screen and`部分。 这就是我们从现在开始在示例文件中编写媒体查询的方式。 例如:

```html
@media (min-width: 750px) {
    /* styles */
} 
```

## 媒体查询可以测试什么?

当构建响应式设计时，使用最多的媒体查询通常与设备的视口宽度(`width`)有关。 根据我自己的经验，我发现除了`resolution`和视口高度之外，几乎没有必要使用其他功能。 然而，为了以防万一，这里列出了媒体查询级别 3 可以测试的所有功能。 希望下面的文章能引起你的兴趣:

*   `width`:视口宽度。
*   `height`:视口高度。
*   `device-width`:渲染表面的宽度(对于我们来说，这通常是设备的屏幕宽度)。
*   `device-height`:渲染表面的高度(对于我们来说，这通常是设备的屏幕高度)。
*   `orientation`:该功能检查设备的方向是竖屏还是横屏。
*   `aspect-ratio`:基于视口宽度和高度的宽高比。 16:9 宽屏显示器可以写成`aspect-ratio: 16/9`。
*   `device-aspect-ratio`:此功能类似于`aspect-ratio`，但基于设备渲染表面的宽度和高度，而不是视口。
*   `color`:每个颜色分量的位数。 例如，`min-color: 16`将检查设备是否为 16 位颜色。
*   `color-index`:设备的颜色查找表(该表表示设备如何将一组颜色更改为另一组颜色)中的条目数。 值必须是数字，不能是负数。
*   `monochrome`:此功能测试单色帧缓冲区中每像素有多少位。 该值应该是一个数字(整数)，例如`monochrome: 2`，并且不能为负数。
*   `resolution`:此功能可用于测试屏幕或打印分辨率; 例如:`min-resolution: 300dpi`。 它还可以接受每厘米点的测量值; 例如`min-resolution: 118dpcm`。
*   `scan`:这可以是进步的，也可以是电视特有的交叉功能。 例如，一个 720p 的 HDTV (720p 的 p 部分表示“渐进的”)可以被`scan: progressive`靶向，而一个 1080i 的 HDTV (1080i 的 i 部分表示“交错的”)可以被`scan: interlace`靶向。
*   `grid`:该功能指示设备是基于网格还是基于位图。

除`scan`和`grid`外，所有前面的特性都可以用`min`或`max`作为前缀来创建范围。 例如，考虑以下代码片段:

```html
@import url("tiny.css") screen and (min-width:200px) and (max-width:360px); 
```

这里，将最小值(`min`)和最大值(`max`)应用于`width`以设置范围。 `tiny.css`文件只适用于最小视口宽度为 200 像素和最大视口宽度为 360 像素的屏幕设备。

**在 CSS 媒体查询级别 4 中已弃用的特性**

值得被注意的规范草案媒体查询四级不赞成使用一些功能([http://dev.w3.org/csswg/mediaqueries-4/ mf-deprecated](http://dev.w3.org/csswg/mediaqueries-4/#mf-deprecated)),尤其是`device-height`,`device-width`和`device-aspect-ratio`。 浏览器将继续支持这些查询，但建议不要编写任何使用它们的新样式表。

# 使用媒体查询来改变设计

如果你已经阅读了并且至少部分理解了我们到目前为止在本章中所讲的内容，你应该准备好开始认真地使用媒体查询。

我建议从本章代码的`start`文件夹中打开`index.html`文件和相关的`styles.css`文件。 然后添加一些媒体查询，以在某些视口宽度上改变页面的某些区域。 让我们一起做一些改变，然后你可以练习自己的一些。

让我们看看我们现在拥有的头部部分(视口大约 1200px 宽):

<figure class="mediaobject">![](../Images/B15480_03_03.png)</figure>

图 3.3:在更宽的屏幕上，我们的浏览器与设计不匹配

这是我们设计的相同部分:

<figure class="mediaobject">![](../Images/B15480_03_04.png)</figure>

图 3.4:设计要求在更宽的视口处有不同的布局

我们需要保持设计，因为它是为较小的视口，但修改它为较大的视口。 让我们从添加一个媒体查询，使导航链接和 logo 位于两边 1200px 以上:

```html
@media (min-width: 1200px) {
    .rwd-MastHead {
        flex-direction: row;
        justify-content: space-between;
        max-width: 1000px;
        margin: 0 auto;
    }
} 
```

如果这些风格现在没有任何意义，不要担心。 我们将在*第 4 章*、*流体布局、Flexbox 和响应图像*中介绍 Flexbox 布局。 重要的是要理解媒体查询本身。 我们说的是，“应用这个规则，但只在最小宽度 1200 像素。”

下面是该规则在浏览器中的效果:

<figure class="mediaobject">![](../Images/B15480_03_05.png)</figure>

图 3.5:我们的第一个媒体查询将导航链接指向右边

现在，眼尖的你可能意识到，尽管这个新规则，分散了我们的标志和导航链接，我们应用了一些样式，我们不再需要在这个尺寸。 下面的截图显示了主导航链接中不再需要的边距和填充:

<figure class="mediaobject">![](../Images/B15480_03_06.png)</figure>

图 3.6:有一些样式被应用，我们想要在这个视口重置

让我们编写另一个媒体查询来解决这个问题。 我们将在稍小的屏幕宽度做这个改变:

```html
@media (min-width: 1000px) {
    .rwd-Nav {
        margin: 0;
        padding: 0;
    }
} 
```

在这个例子中，我们说，“在 1000px 以上，让`.rwd-Nav`元素的边距和填充为零。” 注意，每次在媒体查询中，我们只修改需要更改的特定属性。

通过编写我们的“基础”样式，在任何媒体查询之外，我们实际的媒体查询只需要封装所需的差异。

这可能看起来有点简化，但前面的过程基本上是所有的工作与媒体查询。 编写没有媒体查询的基本样式，然后在更广的范围内工作，在需要时添加媒体查询和更改，以影响设计。

如果您有时间，我恳请您尝试为自己编写一些媒体查询，无论是使用这里的测试页面还是您自己想要使用的东西。 选择您想要更改的内容，选择一个视口宽度，并添加一个媒体查询来进行更改。

**在模拟器和模拟器上测试响应式设计**

虽然在真实设备上测试你的开发工作是不可替代的，但有针对 Android 的模拟器和针对 iOS 的模拟器(对于书呆子来说，模拟器只是模拟相关设备，而模拟器实际上是试图解释原始设备的代码)。 Windows、Linux 和 Mac 的 Android 模拟器可以通过从[https://developer.android.com/studio](https://developer.android.com/studio)安装 Android Studio 免费获得。 iOS 模拟器仅适用于 macOS 用户，并作为 Xcode 包的一部分(从 Mac App Store 免费)。

浏览器本身也在其开发工具中包含了用于模拟移动设备的不断改进的工具。 Firefox 和 Chrome 目前都有特定的设置来模拟不同的移动设备/视图。

# 高级媒体查询注意事项

下面的部分讨论了当您非常精通编写媒体查询时所关注的问题。 可以将这些主题视为微观优化。 如果你刚开始使用媒体查询，你当然不应该担心这些话题。 跳到媒体查询级别 4 部分代替!

好了，媒体查询超级极客，我们开始吧…

## 组织媒体查询

通常，对于浏览器来说，CSS 被认为是一种渲染阻塞资产。 浏览器需要获取并解析链接的 CSS 文件，然后才能完成页面的呈现。 这是显而易见的，因为浏览器需要知道应用什么样式来布局和绘制页面。

然而，现代浏览器已经足够智能，能够识别哪些样式表(在头部与媒体查询链接)需要立即分析，哪些可以推迟到初始页面呈现之后。 这样做的结果是，对于这些浏览器，与媒体查询链接的 CSS 文件(不适用于当前环境情况)可以“延迟”到初始页面加载后，提供一些性能优势。 在谷歌的开发者页面上有更多关于这个主题的:[https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css)。

但是，我要提请你特别注意这一部分:

> .．. 注意，“呈现阻塞”仅指浏览器是否必须在该资源上保留页面的初始呈现。 在这两种情况下，CSS 资产仍然由浏览器下载，尽管非阻塞资源的优先级较低。

重申一下，所有链接的文件仍然会被下载; 它们只是不一定需要浏览器来保存页面的呈现。

因此，一个现代浏览器加载一个响应式网页，其中有四个不同的样式表链接，使用不同的媒体查询(为不同的视口范围应用不同的样式)，将下载所有四个 CSS 文件，但可能在呈现页面之前只解析适用的一个。 在本章的示例代码中查看`example_03-03`，您可能会发现在[https://benfrain.com/playground/mq-downloads/](https://benfrain.com/playground/mq-downloads/)查看更方便。 如果你用一个苗条的视窗来查看这个页面，并且你对你的浏览器的开发工具足够熟练，你可以查看网络区域并检查所有的文件都被下载了，不管媒体查询是否真的被应用了。

## 分离媒体查询的实用性

除了偏好和/或代码划分之外，将不同的媒体查询样式分离到单独的文件中很少有明显的优势。 毕竟，使用单独的文件会增加呈现页面所需的 HTTP 请求的数量，这反过来又会使某些其他情况下的页面变慢。 在网络上没有什么是容易的! 因此，这实际上是一个评估站点的整体性能并在不同设备上测试每个场景的问题。

作为一种默认方法，除非项目有相当多的时间用于性能优化，否则这是我最不希望获得性能增益的地方之一。

几乎只有一次,我确信所有图片压缩,所有脚本连接和缩小,所有的资产都是 gzip,通过将所有静态内容缓存,所有剩余的 CSS 规则已被移除我会开始寻求媒体查询分解成单独的文件为潜在的性能收益。

## 嵌套媒体查询“内联”

除特殊情况外，我建议在现有的样式表中添加“正常”规则之外的媒体查询。 如果你愿意做同样的事情，这就导致了一个进一步的考虑:媒体查询应该在关联的选择器下面声明吗? 或者分割成一个单独的代码块在所有类似的媒体查询的结束? 很高兴你发问。

# 组合媒体查询或写他们在哪里适合?

我喜欢在原始的“正常”规则下编写媒体查询。 例如，假设我想要改变两个不同元素的宽度，这些元素被写在样式表的不同位置，这取决于视口宽度。 我通常会这样做:

```html
.thing {
    width: 50%;
}
@media (min-width: 30rem) {
    .thing {
        width: 75%;
    }
}
/* A few more styles would go between them */
.thing2 {
    width: 65%;
}
@media (min-width: 30rem) {
    .thing2 {
        width: 75%;
    }
} 
```

在这个例子中，我们有两个单独的媒体查询，为同一件事情编写测试:`@media (min-width: 30rem)`。 在这样的规则下复制媒体肯定过于冗长和浪费了吧? 难道我不应该提倡将所有类似的媒体查询组合成一个单独的块，像这样:

```html
.thing {
    width: 50%;
}
.thing2 {
    width: 65%;
}
@media (min-width: 30rem) {
    .thing {
        width: 75%;
    }
    .thing2 {
        width: 75%;
    }
}
/* A few more styles go after */ 
```

这当然是一种方法。 然而，从维护的角度来看，我发现这更困难。 没有“正确”的方法来做到这一点，但我的偏好是一次性为单个选择器定义一个规则，然后立即定义该规则的任何变体(如媒体查询中的更改)。 这样，我就不需要搜索单独的代码块来找到与特定选择器相关的声明。

使用 CSS 预处理程序，关联所有类似的规则会更加方便，因为规则的媒体查询“变体”可以直接嵌套在初始规则集中。 但这是另一本书的技巧。 好奇吗? 请看这里:[https://ecss.io/chapter8.html#h-H2_1](https://ecss.io/chapter8.html#h-H2_1)。

以冗长为理由反对前一种方法似乎是公平的。 当然，文件大小本身就应该足够的理由不写媒体查询以这种方式? 毕竟，没有人想要一个庞大的 CSS 文件来服务他们的用户。 然而，一个简单的事实是，gzip 压缩应该压缩服务器上所有可能的资产，它将差异减少到一个完全不重要的数量。

我在过去已经做过各种各样的测试，所以如果你想了解更多，请访问[http://benfrain.com/inline-or-combined-media-queries-in-sass-fight/](http://benfrain.com/inline-or-combined-media-queries-in-sass-fight/)。 底线是，我不相信你应该关心自己的文件大小，如果你宁愿写媒体查询直接在“标准”样式。

最后需要注意的一点是,如果你想要你的媒体作者查询后直接原规则但都一样媒体查询定义合并成一个,有很多构建工具(在撰写本文时繁重和吞咽都有相关的插件),方便。

这应该给你一切你需要开始挥舞媒体查询像一个专家。 然而，在我们继续之前，在媒体查询级别 4 中有许多媒体查询特性，我们今天就可以开始使用了。 让我们先睹为快!

# 媒体查询级别 4

在 W3C 规范经过批准过程,从**工作草案**(**WD),**候选人推荐**(****CR),【显示】提出建议**(**公关),最后到达之前,许多年以后,在 W3C 推荐【病人】**(**REC)。 因此，成熟度较高的模块通常比其他模块使用起来更安全。 例如，当我写这篇文章([http://www.w3.org/TR/css-nav-1/](http://www.w3.org/TR/css-nav-1/))时，CSS空间导航级别 1 正在进行中，在浏览器中不支持 WD 状态。 同时本章的主题，媒体查询级别 3，在每个现代浏览器中都实现了。**

如果您有一天的空闲时间，您可以在[http://www.w3.org/2005/10/Process-20051014/tr](http://www.w3.org/2005/10/Process-20051014/tr)上阅读有关标准批准过程的官方解释。

在编写的时候，虽然 CSS 媒体查询级别 4 享受着草案规范:[http://dev.w3.org/csswg/mediaqueries-4/](http://dev.w3.org/csswg/mediaqueries-4/)，但并不是它文档中的所有特性都享受着浏览器实现。 因此，在本节中，我们将集中讨论媒体查询级别 4 的特性，这些特性可以利用浏览器中已经实现的特性。

## 互动媒体特性

交互媒体查询与指向设备和悬停能力有关。 让我们看看这些能给我们带来什么。

### 指针媒体特性

以下是对`pointer`媒体特性的 W3C 介绍:

> 指针媒体特性用于查询关于鼠标等指向设备的存在和准确性。 如果一个设备有多个输入机制，指针媒体特性必须反映由用户代理确定的“主要”输入机制的特征。

`pointer`特性有三种可能的状态:`none`、`coarse`和`fine`。

指针设备`coarse`可能是触摸屏设备上的手指。 然而，它也可能是来自游戏主机的光标，但却无法像鼠标那样进行精细控制:

```html
@media (pointer: coarse) {
    /* styles for when coarse pointer is present */
} 
```

一个`fine`指针设备可能是鼠标，但也可能是一支手写笔或任何未来的细粒度指针机制:

```html
@media (pointer: fine) {
    /* styles for when fine pointer is present */
} 
```

浏览器根据“主”指向设备报告`pointer`的值是`fine`、`coarse`还是`none`。 因此，仅仅因为一个设备具有精细指针的能力，并不意味着它将是主要的指针设备。 想象一下，平板电脑的主指针是一个手指(粗糙)，但有一个附加的触控笔——一个精细的指向装置。

最安全的做法是假设用户使用的是触屏输入，并相应地调整用户界面元素的大小。 这样，即使他们使用鼠标，他们也可以轻松地使用界面。 但是，如果您假定鼠标输入，而不提供粗指针的功能，那么用户体验可能会很困难。

在这里阅读此功能的草稿:[https://www.w3.org/TR/mediaqueries-4/#pointer](https://www.w3.org/TR/mediaqueries-4/#pointer)。

### 悬浮媒体特性

正如您所想象的，`hover`媒体特性测试设备悬停在屏幕上元素上的能力。 如果用户可以使用多个输入(例如，触摸和鼠标)，则使用主要输入的特征。 下面是可能的值和示例代码。

对于没有悬停能力的用户，我们可以将样式的值设为`none`:

```html
@media (hover: none) {
    /* styles for when the user cannot hover */
} 
```

或者，像之前一样，我们可以选择将非悬停场景设为默认，然后只为那些利用它们的设备添加悬停样式:

```html
@media (hover) {
    /* styles for when user can hover */
} 
```

请注意还有`any-pointer`或`any-hover`媒体特性。 它们类似于前面的`hover`和`pointer`，但测试任何可能的输入设备的能力。

这样，如果你想应用样式，如果任何输入设备能够悬停，而不管该输入设备是否是主设备:

```html
@media (any-hover: hover) {
    /* styles if any input device is capable of hover*/
} 
```

如果你想根据任何附加的指针设备是否粗糙来以某种方式样式化一个元素，你可以像这样使用`any-pointer`:

```html
@media (any-pointer: coarse) {
    /* styles to be applied if any attached pointer is coarse */
} 
```

## 偏好颜色方案媒体功能

在过去的几年里，桌面电脑和移动电脑的流行操作系统都给用户提供了“暗模式”的选项。 作为补充，操作系统通过`prefers-color-scheme`媒体特性将此用户首选项暴露给浏览器。 这个媒体查询实际上是规范的级别 5，而不是级别 4。 然而，它在大多数常见浏览器中实现的情况很奇怪。

目前有三种可能的偏好:`light`、`dark`、`no-preference`。 为了演示这个特性的用法，我们可以修改页面的默认颜色，如下所示:

```html
body {
    background-color: #e4e4e4;
    color: #545454;
}
@media (prefers-color-scheme: dark) {
    body {
        background-color: #333;
        color: #ddd;
    }
} 
```

同样的我建议你写你的默认“移动”风格在样式表的根,我建议写在根也默认颜色和添加一个查询来满足另一个接口如果需要或期望。

您可以在这里阅读`prefers-color-scheme`媒体功能的草案规范:[https://drafts.csswg.org/mediaqueries-5/#prefers-color-scheme](https://drafts.csswg.org/mediaqueries-5/#prefers-color-scheme)。

# 总结

在本章中，我们学习了什么是媒体查询，为什么我们需要它们，以及如何在我们的 CSS 文件中包含它们。 我们还学习了如何使用 viewport`meta`标记使浏览器以我们想要的方式呈现页面。

不要担心试图记住媒体查询的语法。 只要理解了基本的原则，你就可以随时查询语法; 毕竟，所有开发者都是这么做的! 只要你明白你可以用媒体查询完成什么，我们这里的工作基本上完成了。

回到*第一章*，*响应式网页设计的要点*，我们注意到响应式网页设计的三个原则是媒体查询，灵活的布局和灵活的媒体。 我们已经有三章了，而且我们只涵盖了媒体查询! 我们要把它放到下一章。

在*第四章，**流体布局，Flexbox，和响应图像*中，我们将深入了解流体布局和图像。 在使用 Flexbox 布局页面元素之前，我们将介绍如何将固定宽度的设计转换为流体比例布局，以及详细介绍灵活的媒体和响应性图像。

这将是另一个充实的章节，所以让你自己舒服，我们在那里见!