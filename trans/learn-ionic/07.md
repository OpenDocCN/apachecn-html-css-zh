# 构建 Riderr 应用程序

凭借我们迄今为止获得的知识，我们将构建一个帮助用户预订乘车的应用程序。这款应用消耗了热门打车服务提供商优步([https://uber.com/](https://uber.com/))曝光的 API，并将其与一款 Ionic app 进行了整合。在此应用程序中，我们将致力于以下工作:

*   与优步 OAuth 2.0 集成
*   集成 REST APIs
*   与设备功能交互
*   使用谷歌应用编程接口
*   最后，预定一程

本章的主要目的是展示如何使用 REST APIs 以及设备功能(如地理定位和 InappBrowser)来构建真实世界的应用程序。

# 应用概述

我们将要构建的应用程序名为 Riderr。Riderr 帮助用户在两点之间预订出租车。这款应用使用优步([https://uber.com/](https://uber.com/))提供的 API 来预约乘车。在这个应用程序中，我们不会集成优步的所有 API。我们将实现几个显示用户信息和乘车信息的端点，以及几个帮助我们预订乘车、查看当前乘车和取消乘车的端点。

为了实现这一点，我们将使用优步的 OAuth 对用户进行身份验证，这样我们就可以显示用户的信息，并代表用户预订旅程。

以下是我们完成应用程序构建后，该应用程序的外观预览:

![](img/00094.jpeg)

Note: Neither the book publication company nor I take any responsibility for loss of money or account ban from Uber. Please read the API instructions clearly before using Uber Production APIs.

# uber apis

在这一节中，我们将讨论将要在 Riderr 应用程序中使用的各种 API。我们还将生成一个客户端标识、一个客户端密码和一个服务器令牌，我们将在发出请求时使用它们。

# 证明

访问优步应用编程接口有三种身份验证机制:

*   服务器令牌
*   单点登录
*   OAuth 2.0

为了让我们代表用户提出请求，访问用户的个人信息，并代表用户预订乘车，我们需要一个 OAuth 2.0 访问令牌。因此，我们将遵循 OAuth 2.0 机制。
如果你是 OAuth 2.0 机制的新手，可以看看[http://www . bubble code . net/en/2016/01/22/understanding-OAuth 2/](http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/)或者[https://www . digitalocean . com/community/tutories/an-introduction-to-OAuth-2](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2)。

# 在优步注册

在我们继续下一步之前，我们需要有一个优步帐户来登录并在优步注册一个新的应用程序。如果你没有账户，你可以使用优步应用程序很容易地创建一个。

创建优步账户后，导航至[https://developer.uber.com/dashboard/create](https://developer.uber.com/dashboard/create)，登录并填写表格，如下所示:

![](img/00095.jpeg)

然后点击创建。这将向优步注册一个新的应用程序，并将为此应用程序创建一个客户端标识、客户端密码和服务器令牌。接下来，单击同一页面上的“授权”选项卡(在这里我们可以找到客户端标识)。将重定向网址更新至`http://localhost/callback`。这一点非常重要。如果我们不这样做，优步不知道在认证后将用户发送到哪里。
使用客户端标识和客户端密码的组合，我们请求访问令牌。然后，使用这个访问令牌，我们将代表用户访问优步资源。
要继续，您需要对 OAuth 2.0 有一个相当好的理解，因为我们将在我们的应用程序中实现相同的东西。

# 应用程序接口

在这个应用程序中，我们将使用来自优步的以下 API:

*   `/authorize`:[https://developer . Uber . com/docs/riders/references/API/v2/authorize-get](https://developer.uber.com/docs/riders/references/api/v2/authorize-get)。该端点允许应用程序将用户重定向到授权页面。当我们开始使用该应用程序时，我们将更深入地研究这个端点。
*   `/token`:该端点使用`/authorize`端点返回的代码，请求访问令牌。然后，该令牌被用于发出进一步的请求。API Doc:[https://developer . Uber . com/docs/riders/references/API/v2/token-post](https://developer.uber.com/docs/riders/references/api/v2/token-post)。
*   `/me`:该端点返回用户信息，以访问令牌为输入。API Doc:[https://developer . Uber . com/docs/riders/references/API/v 1.2/me-get](https://developer.uber.com/docs/riders/references/api/v1.2/me-get)。
*   `/history`:该端点返回用户的优步乘车历史。此端点需要特殊权限(特权范围)。但是，对于我们的示例，由于这是一个开发应用程序，我们将使用具有完全访问范围的端点。但是如果你想对该应用进行生产部署，请参考[https://developer.uber.com/docs/riders/guides/scopes](https://developer.uber.com/docs/riders/guides/scopes)了解更多信息。API Doc:[https://developer . Uber . com/docs/riders/references/API/v 1.2/history-get](https://developer.uber.com/docs/riders/references/api/v1.2/history-get)。
*   `/payment-methods`:该端点返回用户可用的支付选项。此端点还需要特权范围。API Doc:[https://developer . Uber . com/docs/riders/references/API/v 1.2/付款方式-获取](https://developer.uber.com/docs/riders/references/api/v1.2/payment-methods-get)。
*   `/products`:该端点返回给定位置支持的产品列表。在我居住的地方——印度海得拉巴——优步提供优步普尔、优步 Go、优步 X 和优步 SUV。这些在城市中也因地而异。在这个城市的一些地方，我也能接触到优步·莫托。使用这个端点，我们将获取给定位置支持的产品。API Doc:[https://developer . Uber . com/docs/riders/references/API/v 1.2/products-get](https://developer.uber.com/docs/riders/references/api/v1.2/products-get)。
*   `/request/estimate`:在我们要求乘车之前，我们需要从优步得到一个票价估算。如果用户对票价估计没意见，我们将提出实际要求。该端点接受所需的信息，并以费用对象作为响应。API Doc:[https://developer . Uber . com/docs/riders/references/API/v 1.2/requests-estate-post](https://developer.uber.com/docs/riders/references/api/v1.2/requests-estimate-post)。
*   `/requests`:该端点接受票价 id、产品 id、出发地和目的地，并预订乘车。API Doc:[https://developer . Uber . com/docs/riders/references/API/v 1.2/requests-post](https://developer.uber.com/docs/riders/references/api/v1.2/requests-post)。
*   `/requests/current`:该端点将返回当前游乐设备的详细信息(如果有)。API Doc:[https://developer . Uber . com/docs/riders/references/API/v 1.2/requests-current-get](https://developer.uber.com/docs/riders/references/api/v1.2/requests-current-get)。
*   `/requests/current`:该端点将取消/删除当前乘坐。API Doc:[https://developer . Uber . com/docs/riders/references/API/v 1.2/requests-current-delete](https://developer.uber.com/docs/riders/references/api/v1.2/requests-current-delete)。

Note: You can refer to [https://developer.uber.com/docs/riders/introduction](https://developer.uber.com/docs/riders/introduction) for other available APIs.

# 构建 Riderr

现在我们已经了解了 API 的列表，我们将开始使用 ion 应用程序。

# 搭建应用程序

本章的下一步是搭建一个新的离子空白应用程序，并开始将其与优步应用程序接口集成。

创建一个名为`chapter7`的新文件夹，在`chapter7`文件夹中打开一个新的命令提示符/终端，并运行以下命令:

```html
ionic start -a "Riderr" -i app.example.riderr riderr blank --v2

```

这将是一个新的空白项目。

# 优步原料药服务

在本节中，我们将开始使用与优步应用编程接口接口的服务层。我们将在离子应用程序中实现上述端点。

应用搭建完成后，导航至`src`文件夹，创建一个名为`services`的新文件夹。在`services`文件夹中，创建一个名为`uber.service.ts`的文件。我们将在这里写下所有的优步积分逻辑。

在您喜欢的文本编辑器中打开`riderr`项目，导航至`riderr/src/services/uber.service.ts`。我们要做的第一件事是添加所需的导入。将以下内容添加到`uber.services.ts`文件的顶部:

```html
import { Injectable } from '@angular/core'; 
import { LoadingController } from 'ionic-angular'; 
import { Http, Headers, Response, RequestOptions } from '@angular/http'; 
import { InAppBrowser } from '@ionic-native/in-app-browser'; 
import { Storage } from '@ionic/storage'; 
import { Observable } from 'rxjs/Observable';

```

我们包括

*   `Injectable`:将当前类标记为提供者
*   `LoadingController`:进行网络请求时显示消息；`Http`、`Headers`、`Response`和`RequestOptions`处理`http`请求
*   `InAppBrowser`:实现 OAuth 2.0 不需要使用服务器获取访问令牌
*   `Storage`:用于存储访问令牌
*   `Observable`:为了更好地处理异步请求

接下来，我们将定义类和类级变量:

```html
@Injectable() 
export class UberAPI { 
  private client_secret: string = 'igVTjJAByDAVfKYgaNGX1MgvoWNmsuTI_OYJz7eq'; 
  private client_id: string = '9i2dK88Ovw0WvH3wmS-H0JA6ZF5Z2GP1'; 
  private redirect_uri: string = 'http://localhost/callback'; 
  private scopes: string = 'profile history places request'; 
  // we will be using the sandbox URL for our app 
  private UBERSANDBOXAPIURL = 'https://sandbox-api.uber.com/v1.2/'; 
  // private UBERAPIURL = 'https://api.uber.com/v1.2/'; 
  private TOKENKEY = 'token'; // name of the key in storage 
  private loader; // reference to the loader 
  private token; // copy of token in memory 
}

```

在前面的代码片段中，从您在优步注册的新应用程序中更新`client_secret`和`client_id`。请注意`scopes`变量。在这里，我们代表用户请求允许访问优步的特权内容。

Note: I will be deleting the preceding registered app once I am done with this example. So, please make sure you have your own `client_secret` and `client_id`.

接下来是构造函数:

```html
//snipp -> Inside the class 
    constructor(private http: Http, 
    private storage: Storage, 
    private loadingCtrl: LoadingController, 
    private inAppBrowser: InAppBrowser) { 
      // fetch the token on load 
      this.storage.get(this.TOKENKEY).then((token) => { 
        this.token = token; 
      }); 
    }

```

在`constructor`中，我们已经实例化了`Http`、`Storage`和`LoadingController`类，我们也正在获取存储在内存中的访问令牌，并将其保存在内存中以备将来使用。

对于我们向优步 API 发出的每一个请求(除了身份验证请求)，我们都需要将访问令牌作为报头的一部分发送。我们有以下方法可以帮助我们:

```html
// snipp 
  private createAuthorizationHeader(headers: Headers) { 
    headers.append('Authorization', 'Bearer ' + this.token); 
    headers.append('Accept-Language', 'en_US'); 
    headers.append('Content-Type', 'application/json'); 
  }

```

接下来，我们需要一个返回布尔值的方法，该值指示用户是否经过身份验证，并且我们有一个令牌向优步 API 发出请求:

```html
// snipp 
  isAuthenticated(): Observable<boolean> { 
    this.showLoader('Autenticating...'); 
    return new Observable<boolean>((observer) => { 
      this.storage.ready().then(() => { 
        this.storage.get(this.TOKENKEY).then((token) => { 
          observer.next(!!token); // !! -> converts truthy falsy to 
          boolean. 
          observer.complete(); 
          this.hideLoader(); 
        }); 
      }); 
    }); 
  }

```

此方法将在存储中查询令牌的存在。如果令牌存在，`observer`返回`true`，否则返回`false`。我们将在所有 API 的末尾实施`showLoader()`和`hideLoader()`。

如果用户通过身份验证，则用户已登录。这意味着我们需要有一个用户注销的选项。因为应用编程接口服务器是无状态的，所以它不维护任何要失效的会话信息。因此，通过从我们的存储中清除令牌，我们使客户端的会话无效:

```html
// snipp 
  logout(): Observable<boolean> { 
    return new Observable<boolean>((observer) => { 
      this.storage.ready().then(() => { 
        this.storage.set(this.TOKENKEY, undefined); 
        this.token = undefined; 
        observer.next(true); 
        observer.complete(); 
      }); 
    }); 
  }

```

现在，我们将编写第一个与优步应用编程接口交互的应用编程接口方法。这是身份验证方法:

```html
// snipp 
auth(): Observable<boolean> { 
    return new Observable<boolean>(observer => { 
      this.storage.ready().then(() => { 
        let browser = 
        this.inAppBrowser.create
        (`https://login.uber.com/oauth/v2/authorize?           
        client_id=${this.client_id}&
        response_type=code&scope=${this.scopes}
        &redirect_uri=${this.redirect_uri}`, '_blank',  
        'location=no,clearsessioncache=yes,clearcache=yes'); 
        browser.on('loadstart').subscribe((event) => { 
          let url = event.url; 

          // console.log(url); 
          // URLS that get fired 

          // 1\. https://login.uber.com/oauth/v2/authorize?
          client_id=9i2dK88Ovw0WvH3wmS-
          H0JA6ZF5Z2GP1&response_type=
          code&scope=profile%20history%20places%20request

          // 2\. https://auth.uber.com/login/? 
          next_url=https%3A%2F%2Flogin.uber.com
          %2Foauth%...520places%2520request
          &state=Pa2ONzlEGsB4M41VLKOosWTlj9snJqJREyCFrEhfjx0%3D 

          // 3\. https://login.uber.com/oauth/v2/authorize?
          client_id=9i2dK88Ovw0WvH3wmS-
          H0JA...ry%20places%20request&
          state=Pa2ONzlEGsB4M41VLKOosWTlj9snJqJREyCFrEhfjx0%3D 

          // 4\. http://localhost/callback?state=
          Pa2ONzlEGsB4M41VLKOosWTlj9snJqJREyCFrEhfjx0%3D&
          code=9Xu6ueaNhUN1uZVvqvKyaXPhMj8Bzb#_ 

          // we are interested in #4 
          if (url.indexOf(this.redirect_uri) === 0) { 
            browser.close(); 
            let resp = (url).split("?")[1]; 
            let responseParameters = resp.split("&"); 
            var parameterMap: any = {}; 

            for (var i = 0; i < responseParameters.length; i++) { 
              parameterMap[responseParameters[i].split("=")[0]] = 
              responseParameters[i].split("=")[1]; 
            } 

            // console.log('parameterMap', parameterMap); 
            /* 
              { 
                "state": 
                "W9Ytf2cicTMPMpMgwh9HfojKv7gQxxhrcOgwffqdrUM%3D", 
                "code": "HgSjzZHfF4GaG6x1vzS3D96kGtJFNB#_" 
              } 
            */ 

            let headers = new Headers({ 
              'Content-Type': "application/x-www-form-urlencoded" 
            }); 
            let options = new RequestOptions({ headers: headers }); 
            let data = 
            `client_secret=${this.client_secret}
            &client_id=${this.client_id}&grant_type=
            authorization_code&redirect_uri=
            ${this.redirect_uri}&code=${parameterMap.code}`; 

            return 
            this.http.post
            ('https://login.uber.com/oauth/v2/token', data, options) 
              .subscribe((data) => { 
                let respJson: any = data.json(); 
                // console.log('respJson', respJson); 
                /* 
                  { 
                    "last_authenticated": 0, 
                    "access_token": "snipp", 
                    "expires_in": 2592000, 
                    "token_type": "Bearer", 
                    "scope": "profile history places request", 
                    "refresh_token": "26pgA43ZvQkxEQi7qYjMASjfq6lg8F" 
                  } 
                */ 

                this.storage.set(this.TOKENKEY, respJson.access_token); 
                this.token = respJson.access_token; // load it up in 
                memory 
                observer.next(true); 
                observer.complete(); 
              }); 
          } 
        }); 
      }); 
    }); 
  }

```

这种方法发生了很多事情。我们正在使用 Ionic Native 的 InAppBrowser([https://ionicframework.com/docs/native/in-app-browser/](https://ionicframework.com/docs/native/in-app-browser/))插件将用户重定向到授权端点。授权端点(`https://login.uber.com/oauth/v2/authorize?client_id=${this.client_id}&response_type=code&scope=${this.scopes}&redirect_uri=${this.redirect_uri}`)获取客户端标识、范围和重定向网址。

`redirect_uri`是一个重要参数，因为优步应用编程接口会在认证后将应用重定向到该网址。在我们的应用程序中，我们通过`browser.on('loadstart')`监听网址更改事件。我们正在寻找一个以`http://localhost/callback`开头的网址。如果这个网址匹配，我们关闭浏览器，从网址中提取代码。

一旦我们有了代码，我们需要用同样的代码来交换访问令牌。这将是`auth()`的下一部分，通过传入`client_secret`、`client_id`、`redirect_uri`和`code`从`https://login.uber.com/oauth/v2/token`获取代币。收到访问令牌后，我们会将其保存到存储中。

Note: To find out more about storage, refer to [https://ionicframework.com/docs/storage/](https://ionicframework.com/docs/storage/) or the *Storage service* section in [*Chapter 4*](04.html#2BASE0-9757c8e51afd47e0a7a9ced32db749b8), *Ionic Decorators and Services*.

现在我们有了访问令牌，我们将请求优步 API 获取、发布和删除数据。

我们要实现的第一个 API 方法是获取用户的信息:

```html
// snipp 
  getMe(): Observable<Response> { 
    this.showLoader(); 
    let headers = new Headers(); 
    this.createAuthorizationHeader(headers); 
    return this.http.get(this.UBERSANDBOXAPIURL + 'me', { 
      headers: headers 
    }); 
  }

```

请注意，我是向优步沙盒应用编程接口网址而不是生产服务发出应用编程接口请求的。在你对你的实现充满信心之前，这总是一个好主意。优步沙盒应用编程接口和优步应用编程接口的实现非常相似，只是沙盒环境中的数据不是实时的，它遵循与优步应用编程接口相同的规则。在生产时，一定要记得更新 API 库。

接下来是历史应用编程接口:

```html
// snipp 
  getHistory(): Observable<Response> { 
    this.showLoader(); 
    let headers = new Headers(); 
    this.createAuthorizationHeader(headers); 
    return this.http.get(this.UBERSANDBOXAPIURL + 'history', { 
      headers: headers 
    }); 
  }

```

标头将被传递给每个需要访问令牌来处理请求的请求。

接下来是支付方法端点:

```html
// snipp 
  getPaymentMethods(): Observable<Response> { 
    this.showLoader(); 
    let headers = new Headers(); 
    this.createAuthorizationHeader(headers); 
    return this.http.get(this.UBERSANDBOXAPIURL + 'payment-methods', { 
      headers: headers 
    }); 
  }

```

前面三个端点将返回用户和用户乘坐信息。下一个端点将返回给定位置支持的产品列表:

```html
// snipp 
  getProducts(lat: Number, lon: Number): Observable<Response> { 
    this.showLoader(); 
    let headers = new Headers(); 
    this.createAuthorizationHeader(headers); 
    return this.http.get(this.UBERSANDBOXAPIURL + 'products?latitude=' 
    + lat + '&longitude=' + lon, { 
      headers: headers 
    }); 
  }

```

该方法将用于显示可用产品或游乐设备类型的列表。

在实际订票之前，我们需要先估算一下票价。我们将对此使用`requestRideEstimates()`方法:

```html
//snipp 
  requestRideEstimates(start_lat: Number, end_lat: Number, start_lon: Number, end_lon: Number): Observable<Response> { 
    this.showLoader(); 
    // before booking 
    let headers = new Headers(); 
    this.createAuthorizationHeader(headers); 
    return this.http.post(this.UBERSANDBOXAPIURL + 'requests/estimate', { 
      "start_latitude": start_lat, 
      "start_longitude": start_lon, 
      "end_latitude": end_lat, 
      "end_longitude": end_lon 
    }, { headers: headers }); 
  }

```

一旦我们得到票价估算并且用户接受，我们将使用`requestRide()`发起预订请求:

```html
// snipp 
  requestRide(product_id: String, fare_id: String, start_lat: Number, end_lat: Number, start_lon: Number, end_lon: Number): Observable<Response> { 
    this.showLoader(); 
    let headers = new Headers(); 
    this.createAuthorizationHeader(headers); 
    return this.http.post(this.UBERSANDBOXAPIURL + 'requests', { 
      "product_id": product_id, 
      "fare_id": fare_id, 
      "start_latitude": start_lat, 
      "start_longitude": start_lon, 
      "end_latitude": end_lat, 
      "end_longitude": end_lon 
    }, { headers: headers }); 
  }

```

此方法返回预订的状态。在沙盒环境中，不会预订任何旅程。如果您真的想预订实际的旅程，您可以更改应用编程接口网址并启动实际的预订。请记住，优步的司机会给你打电话让你开车。如果您取消乘坐，将收取适当的取消费用。

Note: Neither the book publication company nor I take any responsibility towards loss of money or account ban from Uber. Please read the API instructions clearly before using Uber Production APIs.

由于优步一次只允许从一个账户预订一次旅程，因此我们可以使用`getCurrentRides()`获得当前旅程:

```html
//snipp 
  getCurrentRides(lat: Number, lon: Number): Observable<Response> { 
    this.showLoader(); 
    let headers = new Headers(); 
    this.createAuthorizationHeader(headers); 
    return this.http.get(this.UBERSANDBOXAPIURL + 'requests/current', { 
      headers: headers 
    }); 
  }

```

最后，要取消乘车，我们将使用`cancelCurrentRide()`发出删除请求:

```html
// snipp 
  cancelCurrentRide(): Observable<Response> { 
    this.showLoader(); 
    let headers = new Headers(); 
    this.createAuthorizationHeader(headers); 
    return this.http.delete(this.UBERSANDBOXAPIURL + 
    'requests/current', { 
      headers: headers 
    }); 
  }

```

显示和隐藏处理加载器的两种实用方法如下:

```html
// snipp 
private showLoader(text?: string) { 
    this.loader = this.loadingCtrl.create({ 
      content: text || 'Loading...' 
    }); 
    this.loader.present(); 
  } 

  public hideLoader() { 
    this.loader.dismiss(); 
  }

```

至此，我们已经添加了所有需要的 API，我们将使用这些 API 与优步 API 进行交互。

# 综合

现在我们已经有了所需的 API 服务，我们将创建所需的视图来表示这些数据。

当我们搭建应用时，会为我们创建一个名为`home`的页面。但是，由于在我们的应用程序中，一切都从身份验证开始，我们将首先生成一个登录页面。然后我们将把它作为应用程序的第一页。要生成新页面，请运行以下命令:

```html
ionic generate page login

```

接下来，我们需要在`riderr/src/app/app.module.ts`中更新页面引用。如图所示更新`@NgModule`:

```html
import { NgModule, ErrorHandler } from '@angular/core'; 
import { IonicApp, IonicModule, IonicErrorHandler } from 'ionic-angular'; 
import { MyApp } from './app.component'; 
import { HomePage } from '../pages/home/home'; 
import { LoginPage } from '../pages/login/login'; 

import { UberAPI } from '../services/uber.service'; 
import { IonicStorageModule } from '@ionic/storage'; 

import { StatusBar } from '@ionic-native/status-bar'; 
import { SplashScreen } from '@ionic-native/splash-screen'; 

@NgModule({ 
  declarations: [ 
    MyApp, 
    HomePage 
    LoginPage 
  ], 
  imports: [ 
    IonicModule.forRoot(MyApp), 
    IonicStorageModule.forRoot() 
  ], 
  bootstrap: [IonicApp], 
  entryComponents: [ 
    MyApp, 
    HomePage, 
    LoginPage 
  ], 
  providers: [{ provide: ErrorHandler, useClass: IonicErrorHandler }, 
      UberAPI, 
    StatusBar, 
    SplashScreen, 
  ] 
}) 
export class AppModule { }

```

我们将继续生成并添加剩余的页面。

Note: As Ionic keeps evolving, class names, and structures of pages might change. But the gist of developing an app in Ionic will remain the same.

接下来，我们将更新`app.component.ts`以加载第一个登录页面。如图所示更新`riderr/src/app/app.component.ts`:

```html
import { Component } from '@angular/core'; 
import { Platform } from 'ionic-angular'; 
import { StatusBar } from '@ionic-native/status-bar'; 
import { SplashScreen } from '@ionic-native/splash-screen'; 

import { LoginPage } from '../pages/login/login'; 

@Component({ 
  templateUrl: 'app.html' 
}) 
export class MyApp { 
  rootPage = LoginPage; 

  constructor(platform: Platform, statusBar: StatusBar, splashScreen: SplashScreen) { 
    platform.ready().then(() => { 
      statusBar.styleDefault(); 
      splashScreen.hide(); 
    }); 
  }

```

现在我们将更新`LoginPage`组件。一、`login.html`页面。更新`riderr2/src/pages/login/login.html`如图所示:

```html
<ion-content padding text-center> 
  <img src="assets/icon/logo.png" alt="Riderr Logo"> 
  <h2>Welcome to The Riderr App</h2> 
  <h3>This app uses Uber APIs to help you book a cab</h3> 
  <br><br><br> 
    <button ion-button color="primary" full (click)="auth()">Login with Uber</button> 
</ion-content>

```

你可以在这里找到`logo.png`:[https://www.dropbox.com/s/8tdfgizjm24l3nx/logo.png?dl=0](https://www.dropbox.com/s/8tdfgizjm24l3nx/logo.png?dl=0)。下载后，将图像移动到`assets/icon`文件夹。

接下来，如图所示更新`riderr/src/pages/login/login.ts`:

```html
import { Component } from '@angular/core'; 
import { NavController } from 'ionic-angular'; 
import { UberAPI } from '../../services/uber.service'; 
import { HomePage } from '../home/home'; 

@Component({ 
  selector: 'page-login', 
  templateUrl: 'login.html' 
}) 
export class LoginPage { 

  constructor(private api: UberAPI, private navCtrl: NavController) { 
    // check if the user is already authenticated 
    this.api.isAuthenticated().subscribe((isAuth) => { 
      if (isAuth) { 
        this.navCtrl.setRoot(HomePage); 
      } 
      // else relax! 
    }); 
  } 

  auth() { 
    this.api.auth().subscribe((isAuthSuccess) => { 
      this.navCtrl.setRoot(HomePage); 
    }, function(e) { 
      // handle this in a user friendly way. 
      console.log('Fail!!', e); 
    }); 
  } 
}

```

在前面的代码中，我们包含了所需的依赖项。在构造器中，我们正在检查用户是否已经使用我们在`UberAPI`类中创建的`isAuthenticated()`进行了身份验证。如果用户点击“使用优步登录”按钮，我们调用`auth()`，这反过来调用`UberAPI`类的`auth()`。

如果用户成功通过认证，我们将用户重定向到`home page`。否则我们什么都不做。

假设用户已成功通过身份验证，用户将被重定向到主页。我们将使主页以侧面菜单为基础。侧面菜单将有链接导航到我们的应用程序中的各个页面。

我们将更新`riderr/src/pages/home/home.html`，如图所示:

```html
<ion-menu [content]="content" (ionClose)="ionClosed()" (ionOpen)="ionOpened()"> 
    <ion-header> 
        <ion-toolbar> 
            <ion-title>Menu</ion-title> 
        </ion-toolbar> 
    </ion-header> 
    <ion-content> 
        <ion-list> 
            <button ion-item menuClose 
            (click)="openPage(bookRidePage)"> 
                Book Ride 
            </button> 
            <button ion-item menuClose (click)="openPage(profilePage)"> 
                Profile 
            </button> 
            <button ion-item menuClose (click)="openPage(historyPage)"> 
                Rides 
            </button> 
            <button ion-item menuClose 
            (click)="openPage(paymentMethodsPage)"> 
                Payment Methods 
            </button> 
            <button ion-item menuClose (click)="logout()"> 
                Logout 
            </button> 
        </ion-list> 
    </ion-content> 
</ion-menu> 
<ion-nav #content [root]="rootPage" swipeBackEnabled="false"></ion-nav>

```

前面的代码是不言自明的。要了解更多关于菜单的信息，请参考[https://ionicframework.com/docs/api/components/menu/Menu/](https://ionicframework.com/docs/api/components/menu/Menu/)。

接下来，我们将更新`HomePage`类。`Update riderr2/src/pages/home/home.ts`如图所示:

```html
import { Component } from '@angular/core'; 
import { BookRidePage } from '../book-ride/book-ride'; 
import { ProfilePage } from '../profile/profile'; 
import { HistoryPage } from '../history/history'; 
import { PaymentMethodsPage } from '../payment-methods/payment-methods'; 
import { LoginPage } from '../login/login'; 
import { UberAPI } from '../../services/uber.service'; 
import { NavController, Events } from 'ionic-angular'; 
import { ViewChild } from '@angular/core'; 

@Component({ 
  selector: 'page-home', 
  templateUrl: 'home.html' 
}) 
export class HomePage { 

  private rootPage; 
  private bookRidePage; 
  private profilePage; 
  private historyPage; 
  private paymentMethodsPage; 

  @ViewChild(BookRidePage) bookRide : BookRidePage; 

  constructor(private uberApi: UberAPI, 
    private navCtrl: NavController, 
    public events: Events) { 
    this.rootPage = BookRidePage; 

    this.bookRidePage = BookRidePage; 
    this.profilePage = ProfilePage; 
    this.historyPage = HistoryPage; 
    this.paymentMethodsPage = PaymentMethodsPage; 
  } 

  // http://stackoverflow.com/a/38760731/1015046 
  ionOpened() { 
    this.events.publish('menu:opened', ''); 
  } 

  ionClosed() { 
    this.events.publish('menu:closed', ''); 
  } 

  ngAfterViewInit() { 
    this.uberApi.isAuthenticated().subscribe((isAuth) => { 
      if (!isAuth) { 
        this.navCtrl.setRoot(LoginPage); 
        return; 
      } 
    }); 
  } 

  openPage(p) { 
    this.rootPage = p; 
  } 

  logout(){ 
    this.uberApi.logout().subscribe(() => { 
      this.navCtrl.setRoot(LoginPage); 
    }); 
  } 
}

```

在这里，我们已经导入了必需的类。我们将在接下来的几个步骤中生成缺失的页面。一定要注意`@ViewChild()`装饰器。当我们与谷歌地图合作时，我们将经历这个过程以及`ionOpened()`和`ionClosed()`。

一旦视图被初始化，我们检查用户是否被验证。如果没有，我们将用户重定向到登录页面。`openPage()`将根页面设置为从菜单中选择的页面。`logout()`清理令牌，将用户重定向到登录页面。

现在我们将创建所需的页面。

首先是大部分动作发生的页面-`bookRide`页面。运行以下命令:

```html
ionic generate page bookRide

```

这将生成一个新页面。创建页面后，打开`riderr/src/app/app.module.ts`并将`BookRidePage`添加到`@NgModule()`的`declarations`和`entryComponents`属性中。

`BookRidePage`是整个 app 中最复杂的页面之一。首先，我们展示一个带有用户当前位置的谷歌地图。我们在用户的位置为其获取可用的产品并展示它们。

在我们继续之前，我需要提到一个奇怪的错误，它发生在使用谷歌地图和地图上的点击事件时，在一个离子应用程序中。

在谷歌地图上，我们显示了一个标记和一个带有用户当前位置的信息窗口。点击标记或信息窗口将重定向用户设置目的地位置，以预订旅程。为此，我们需要聆听地图上的点击事件。当在非谷歌地图组件上处理点击事件时，如辅助菜单、警报等，这种情况会导致问题。您可以在这里阅读更多关于该问题的信息:[https://github . com/drifty co/ion/issues/9942 # issuecomment-280941997](https://github.com/driftyco/ionic/issues/9942#issuecomment-280941997)。

因此，为了克服这个错误，只要有除谷歌地图组件之外的点击交互，我们就需要禁用谷歌地图上的点击监听器，一旦我们完成了，我们就需要重新启用它。

回到`riderr/src/pages/home/home.ts`中的`ionOpened()`和`ionClosed()`，每当菜单打开或关闭时，我们都会从它们触发自定义事件。这样，我们在菜单打开时禁用地图上的点击监听器，并在用户选择菜单项后启用点击监听器。在`ionOpened()`和`ionClosed()`中，我们只触发了事件。我们将在`riderr/src/pages/book-ride/book-ride.ts`中处理相同的内容。

既然我们意识到了这个问题，我们就可以继续前进了。我们将首先实现菜单和地图。如图所示更新`riderr/src/pages/book-ride/book-ride.html`:

```html
<ion-header> 
    <ion-navbar> 
        <button ion-button menuToggle> 
            <ion-icon name="menu"></ion-icon> 
        </button> 
        <ion-title>Riderr</ion-title> 
        <ion-buttons end> 
            <button *ngIf="isRideinProgress" ion-button color="danger" 
            (click)="cancelRide()"> 
                Cancel Ride 
            </button> 
        </ion-buttons> 
    </ion-navbar> 
</ion-header> 
<ion-content> 
    <div #map id="map"></div> 
    <div class="prods-wrapper"> 
        <div *ngIf="!isRideinProgress"> 
            <h3 *ngIf="!products">Fetching Products</h3> 
            <ion-grid *ngIf="products"> 
                <ion-row> 
                    <ion-col *ngFor="let p of products" [ngClass]="
                    {'selected' : p.isSelected}"> 
                        <div class="br" (click)="productClick(p)"> 
                            <h3>{{p.display_name.replace('uber', '')}}
                            </h3> 
                        </div> 
                    </ion-col> 
                </ion-row> 
            </ion-grid> 
        </div> 
        <div *ngIf="isRideinProgress"> 
            <h3 text-center>Ride In Progress</h3> 
            <p text-center>Ideally the ride information would be 
            displayed here.</p> 
        </div> 
    </div> 
</ion-content>

```

在标题中，我们有一个按钮来取消正在进行的乘坐。我们将在`BookRidePage`类中填充`isRideinProgress`属性，它管理这里显示的页面状态。`ion-grid`组件显示当前用户所在位置支持的产品列表。

还要注意我们添加了`<div #map id="map"></div>`。这将是地图出现的地方。

为了稍微清理一下用户界面，我们将增加一些样式。如图所示更新`riderr/src/pages/book-ride/book-ride.scss`:

```html
page-book-ride { 
    #map { 
        height: 88%; 
    } 
    .prods-wrapper { 
        height: 12%; 
    } 
    .br { 
        padding: 3px; 
        text-align: center; 
    } 
    ion-col.selected { 
        color: #eee; 
        background: #333; 
    } 
    ion-col { 
        background: #eee; 
        color: #333; 
        border: 1px solid #ccc; 
    } 
    ion-col:last-child .br { 
        border: none; 
    } 
}

```

接下来，我们要更新`BookRidePage`类。有相当多的方法，所以我将按照执行的顺序分部分分享它们。

在`riderr/src/pages/book-ride/book-ride.ts`中，我们将首先更新所需的导入:

```html
import { Component } from '@angular/core'; 
import { UberAPI } from '../../services/uber.service'; 
import { 
  Platform, 
  NavController, 
  AlertController, 
  ModalController, 
  Events 
} from 'ionic-angular'; 
import { Diagnostic } from '@ionic-native/diagnostic'; 
import { Geolocation } from '@ionic-native/geolocation'; 
import { 
  GoogleMaps, 
  GoogleMap, 
  GoogleMapsEvent, 
  LatLng, 
  CameraPosition, 
  MarkerOptions, 
  Marker 
} from '@ionic-native/google-maps';  
import { AutocompletePage } from '../auto-complete/auto-complete';

```

`@Component`装饰师将保持原样。

接下来，我们将声明一些类级变量:

```html
// snipp 
  private map: GoogleMap; 
  private products; 
  private fromGeo; 
  private toGeo; 
  private selectedProduct; 
  private isRideinProgress: boolean = false; 
  private currentRideInfo; 

```

然后定义构造函数:

```html
  // snipp 
constructor(private uberApi: UberAPI, 
    private platform: Platform, 
    private navCtrl: NavController, 
    private alertCtrl: AlertController, 
    private modalCtrl: ModalController, 
    private diagnostic: Diagnostic, 
    private geoLocation: Geolocation, 
    private googleMaps: GoogleMap, 
    public events: Events) { }

```

一旦视图被初始化，使用`ngAfterViewInit()`钩子，我们将开始获取用户的地理位置:

```html
// snipp 
ngAfterViewInit() { 
    //https://github.com/mapsplugin/cordova-plugin-googlemaps/issues/1140 
    this.platform.ready().then(() => { 
      this.requestPerms(); 

      //https://github.com/driftyco/ionic/issues/9942#issuecomment-
      280941997 
      this.events.subscribe('menu:opened', () => { 
        this.map.setClickable(false); 
      }); 
      this.events.subscribe('menu:closed', () => { 
        this.map.setClickable(true); 
      }); 
    }); 
  }

```

但是在我们获得地理位置之前，我们需要请求用户允许我们访问位置服务。

还要注意为`menu:opened`和`menu:closed`事件实现的侦听器。这就是我们如何禁用地图上的点击，并根据侧面菜单的状态重新启用它。继续我们的发展:

```html
// snipp 
private requestPerms() { 
    let that = this; 
    function success(statuses) { 
      for (var permission in statuses) { 
        switch (statuses[permission]) { 
          case that.diagnostic.permissionStatus.GRANTED: 
            // console.log("Permission granted to use " + permission); 
            that.fetCords(); 
            break; 
          case that.diagnostic.permissionStatus.NOT_REQUESTED: 
            console.log("Permission to use " + permission + " has not 
            been requested yet"); 
            break; 
          case that.diagnostic.permissionStatus.DENIED: 
            console.log("Permission denied to use " + permission + " - 
            ask again?"); 
            break; 
          case that.diagnostic.permissionStatus.DENIED_ALWAYS: 
            console.log("Permission permanently denied to use " + 
            permission + " - guess we won't be using it then!"); 
            break; 
        } 
      } 
    } 

    function error(e) { 
      console.log(e); 
    } 

    this.diagnostic.requestRuntimePermissions([ 
      that.diagnostic.permission.ACCESS_FINE_LOCATION, 
      that.diagnostic.permission.ACCESS_COARSE_LOCATION 
    ]).then(success).catch(error); 
  }

```

使用`@ionic-native` / `diagnostic`中的诊断插件，我们请求运行时权限。这将显示一个弹出窗口，询问用户该应用程序是否可以访问用户的地理位置。如果用户允许该应用，我们将在成功回拨中收到`Diagnostic.permissionStatus.GRANTED`状态。然后，我们将尝试获取用户的坐标。如果需要，其他情况可以很好地处理:

```html
// snipp 
  private isExecuted = false; 
  private fetCords() { 
    // this needs to be called only once 
    // since we are requesting 2 permission 
    // this will be called twice. 
    // hence the isExecuted 
    if (this.isExecuted) return; 
    this.isExecuted = true; 
    // maps api key : AzaSyCZhTJB1kFAP70RuwDts6uso9e3DCLdRWs 
    // ionic plugin add cordova-plugin-googlemaps --variable 
    API_KEY_FOR_ANDROID="AzaSyCZhTJB1kFAP70RuwDts6uso9e3DCLdRWs" 
    this.geoLocation.getCurrentPosition().then((resp) => { 
      // resp.coords.latitude 
      // resp.coords.longitude 
      // console.log(resp); 
      this.fromGeo = resp.coords; 
      // Get the products at this location 
      this.uberApi.getProducts(this.fromGeo.latitude, 
      this.fromGeo.longitude).subscribe((data) => { 
        this.uberApi.hideLoader(); 
        this.products = data.json().products; 
      }); 
      // Trip in progress? 
      this 
        .uberApi 
        .getCurrentRides(this.fromGeo.latitude, this.fromGeo.longitude) 
        .subscribe((crrRides) => { 
          this.currentRideInfo = crrRides.json(); 
          this.isRideinProgress = true; 
          this.uberApi.hideLoader(); 
          // check for existing rides before processing 
          this.loadMap(this.fromGeo.latitude, this.fromGeo.longitude); 
        }, (err) => { 
          if (err.status === 404) { 
            // no rides availble 
          } 
          this.isRideinProgress = false; 
          this.uberApi.hideLoader(); 
          // check for existing rides before processing 
          this.loadMap(this.fromGeo.latitude, this.fromGeo.longitude); 
        }); 
    }).catch((error) => { 
      console.log('Error getting location', error); 
    }); 
  }

```

`fetCords()`将使用地理定位离子原生插件获取用户坐标。一旦我们收到位置，我们将向 getProducts()发起请求，传递用户的纬度和经度。与此同时，我们使用优步应用编程接口上的 getCurrentRides()检查是否有任何乘坐正在进行中。

一旦响应到达，我们调用`loadMap()`绘制所需的地图。

完成代码演练后，我们将安装所有必需的科尔多瓦插件和离子原生模块:

```html
// snipp 
private loadMap(lat: number, lon: number) { 
    let element: HTMLElement = document.getElementById('map'); 
    element.innerHTML = ''; 
    this.map = undefined; 
    this.map = this.googleMaps.create(element); 
    let crrLoc: LatLng = new LatLng(lat, lon); 
    let position: CameraPosition = { 
      target: crrLoc, 
      zoom: 18, 
      tilt: 30 
    }; 

    this.map.one(GoogleMapsEvent.MAP_READY).then(() => { 
      // move the map's camera to position 
      this.map.moveCamera(position); // works on iOS and Android 

      let markerOptions: MarkerOptions = { 
        position: crrLoc, 
        draggable: true, 
        title: this.isRideinProgress ? 'Ride in Progess' : 'Select 
        Destination >', 
        infoClick: (() => { 
          if (!this.isRideinProgress) { 
            this.selectDestination(); 
          } 
        }), 
        markerClick: (() => { 
          if (!this.isRideinProgress) { 
            this.selectDestination(); 
          } 
        }) 
      }; 

      this.map.addMarker(markerOptions) 
        .then((marker: Marker) => { 
          marker.showInfoWindow(); 
        }); 

      // a rare bug 
      // loader doesn't hide 
      this.uberApi.hideLoader(); 
    });
}

```

`loadMap()`获取用户的地理位置，在该位置创建标记，并使用相机 API 平移到该点。标记有一个简单的信息文本，选择目的地>，当点击它时，会将用户带到一个屏幕上，输入目的地以预订旅程。

`infoClick()`和`markerClick()`只注册一个回调来执行`selectDestination()`没有正在进行的骑行:

```html
// snipp 
  private productClick(product) { 
    // console.log(product); 
    // set the active product in the UI 
    for (let i = 0; i < this.products.length; i++) { 
      if (this.products[i].product_id === product.product_id) { 
        this.products[i].isSelected = true; 
      } else { 
        this.products[i].isSelected = false; 
      } 
    } 

    this.selectedProduct = product; 
  }

```

要预订乘车，用户应该选择一种产品。`productClick()`通过根据用户从主页的选择将产品设置为所选产品来解决这个问题。

一旦选择了产品，并且用户的位置可用，我们就可以要求用户输入目的地位置，这样我们就可以检查票价估算:

```html
// snipp 
private selectDestination() { 
    if (this.isRideinProgress) { 
      this.map.setClickable(false); 
      let alert = this.alertCtrl.create({ 
        title: 'Only one ride!', 
        subTitle: 'You can book only one ride at a time.', 
        buttons: ['Ok'] 
      }); 
      alert.onDidDismiss(() => { 
        this.map.setClickable(true); 
      }); 
      alert.present(); 
    } else { 
      if (!this.selectedProduct) { 
        // since the alert has a button 
        // we need to first stop the map from  
        // listening. Then process the alert 
        // then renable 
        this.map.setClickable(false); 
        let alert = this.alertCtrl.create({ 
          title: 'Select Ride', 
          subTitle: 'Select a Ride type to continue (Pool or Go or X)', 
          buttons: ['Ok'] 
        }); 
        alert.onDidDismiss(() => { 
          this.map.setClickable(true); 
        }); 
        alert.present(); 
      } else { 
        this.map.setClickable(false); 
        let modal = this.modalCtrl.create(AutoCompletePage); 
        modal.onDidDismiss((data) => { 
          this.map.setClickable(true); 
          this.toGeo = data; 
          this 
            .uberApi 
            .requestRideEstimates(this.fromGeo.latitude, 
             this.toGeo.latitude, this.fromGeo.longitude, 
             this.toGeo.longitude) 
            .subscribe((data) => { 
              this.uberApi.hideLoader(); 
              this.processRideFares(data.json()); 
            }); 

        }); 
        modal.present(); 
      } 
    } 
  }

```

`selectDestination()`负责目的地选择以及获得乘车估计。`selectDestination()`内的第一个条件是确保用户只有一次骑行。第二个 if 条件检查是否至少有一个`selectedProduct`。如果一切都好，我们调用`AutoCompletePage`作为模式，用户使用谷歌位置服务搜索一个地方。一旦使用该服务选择了一个地点，我们就获取目的地的地理位置。然后将所需信息传递给`requestRideEstimates()`获取估计值。

一旦完成`BookRidePage`，我们将与`AutoCompletePage`合作。当我们从`requestRideEstimates()`获得票价时，我们将向用户呈现相同的内容:

```html
// snipp 
private processRideFares(fareInfo: any) { 
    // ask the user if the fare is okay,  
    // if yes, book the cab 
    // else, do nothing 
    console.log('fareInfo', fareInfo); 
    this.map.setClickable(false); 
    let confirm = this.alertCtrl.create({ 
      title: 'Book Ride?', 
      message: 'The fare for this ride would be ' 
      + fareInfo.fare.value 
      + ' ' + fareInfo.fare.currency_code + '.\n And it will take         
      approximately ' + 
      (fareInfo.trip.duration_estimate / 60) + ' mins.', 
      buttons: [ 
        { 
          text: 'No', 
          handler: () => { 
            this.map.setClickable(true); 
          } 
        }, 
        { 
          text: 'Yes', 
          handler: () => { 
            this.map.setClickable(true); 
            this 
              .uberApi 
              .requestRide(this.selectedProduct.product_id, 
               fareInfo.fare.fare_id, this.fromGeo.latitude, 
                this.toGeo.latitude, this.fromGeo.longitude, 
                this.toGeo.longitude) 
              .subscribe((rideInfo) => { 
                this.uberApi.hideLoader(); 
                // console.log('rideInfo', rideInfo.json()); 
                // Since we are making requests to the sandbox url 
                // the request will always be in processing. 
                // Once the request has been submitted, we need to  
                // keep polling the getCurrentRides() API 
                // to get the ride information 
                // WE ARE NOT GOING TO DO THAT! 
                this.isRideinProgress = true; 
                this.currentRideInfo = rideInfo.json(); 
              }); 
          } 
        } 
      ] 
    }); 
    confirm.present(); 
  }

```

`processRideFares()`以票价信息为输入，将票价呈现给用户。如果用户对票价和时间估计没问题，我们会向优步提出使用`requestRide()`预订乘车的请求。

最后，如果用户想取消当前乘坐，我们提供`cancelRide()`:

```html
// snipp 
  private cancelRide() { 
    this 
      .uberApi 
      .cancelCurrentRide() 
      .subscribe((cancelInfo) => { 
        this.uberApi.hideLoader(); 
        this.isRideinProgress = false; 
        this.currentRideInfo = undefined; 
      }); 
  }

```

这将是对`cancelCurrentRide()`的呼唤。

现在我们已经完成了`BookRidePage`所需的逻辑，我们将创建`AutoCompletePage`。运行以下命令:

```html
ionic generate page autoComplete

```

一旦完成，我们需要将`AutoCompletePage`添加到`riderr/src/app/app.module.ts`:

```html
import { AutoCompletePage } from '../pages/auto-complete/auto-complete';

```

将`AutoCompletePage`引用添加到`@NgModule()`的`declarations`和`entryComponents`属性中。

`AutoCompletePage`类将包含与谷歌位置服务一起搜索位置所需的逻辑。首先，我们将与`auto-complete.html`合作。打开`riderr/src/pages/auto-complete/auto-complete.html`，如图所示进行更新:

```html
<ion-header> 
    <ion-toolbar> 
        <ion-title>Enter address</ion-title> 
        <ion-searchbar id="q" [(ngModel)]="autocomplete.query" [showCancelButton]="true" (ionInput)="updateSearch()" (ionCancel)="dismiss()"></ion-searchbar> 
    </ion-toolbar> 
</ion-header> 
<ion-content> 
    <ion-list> 
        <!-- (click) is buggy at times, hmmm? --> 
        <ion-item *ngFor="let item of autocompleteItems" tappable (click)="chooseItem(item)"> 
            {{ item.description }} 
        </ion-item> 
    </ion-list> 
</ion-content>

```

我们有一个搜索栏和一个`ion-list`来显示搜索结果。接下来，我们将研究`auto-complete.ts`。打开`riderr/src/pages/auto-complete/auto-complete.ts`，如图所示进行更新:

```html
import { Component, NgZone } from '@angular/core'; 
import { ViewController } from 'ionic-angular'; 

@Component({ 
  templateUrl: 'auto-complete.html' 
}) 

// http://stackoverflow.com/a/40854384/1015046 
export class AutocompletePage { 
  autocompleteItems; 
  autocomplete; 
  ctr: HTMLElement = document.getElementById("q"); 
  service = new google.maps.places.AutocompleteService(); 
  geocoder = new google.maps.Geocoder(); 

  constructor(public viewCtrl: ViewController, private zone: NgZone) { 
    this.autocompleteItems = []; 
    this.autocomplete = { 
      query: '' 
    }; 
  } 

  dismiss() { 
    this.viewCtrl.dismiss(); 
  } 

  chooseItem(item: any) { 
    // we need the lat long 
    // so we will make use of the  
    // geocoder service 
    this.geocoder.geocode({ 
      'placeId': item.place_id 
    }, (responses) => { 
      // send the place name 
      // & latlng back 
      this.viewCtrl.dismiss({ 
        description: item.description, 
        latitude: responses[0].geometry.location.lat(), 
        longitude: responses[0].geometry.location.lng() 
      }); 
    }); 
  } 

  updateSearch() { 
    if (this.autocomplete.query == '') { 
      this.autocompleteItems = []; 
      return; 
    } 
    let that = this; 
    this.service.getPlacePredictions({ 
      input: that.autocomplete.query, 
      componentRestrictions: { 
        country: 'IN' 
      } 
    }, (predictions, status) => { 
      that.autocompleteItems = []; 
      that.zone.run(function() { 
        predictions = predictions || []; 
        predictions.forEach(function(prediction) { 
          that.autocompleteItems.push(prediction); 
        }); 
      }); 
    }); 
  } 
}

```

这里，我们使用`google.maps.places.AutocompleteService`来获取用户搜索时的预测。

需要注意的非常重要的一点是，places 和 Geocoder 服务不能作为一个离子原生插件使用。因此，我们将使用谷歌地图 JavaScript 库来访问位置和地理编码器服务。为此，我们将安装打字机，然后是谷歌地图。我们将在最后安装这个。

一旦用户找到地点，他们将点击位置，这将触发`chooseItem()`。在`chooseItem()`里面，我们会取`place_id`取所选位置的地理坐标，传回到`BookRidePage`类`selectDestination()`里面的`modal.onDidDismiss()`。然后流程继续，就像我们在`BookRidePage`课上看到的那样。

现在，我们将实现`profile`、`history`和`paymentMethods`端点。要生成所需的页面，请运行以下命令:

```html
ionic generate page profile 
ionic generate page history 
ionic generate page paymentMethods

```

接下来，我们将同样添加到`riderr/src/app/app.module.ts`。`app.module.ts`的最终版本如下:

```html
import { NgModule, ErrorHandler } from '@angular/core'; 
import { IonicApp, IonicModule, IonicErrorHandler } from 'ionic-angular'; 
import { MyApp } from './app.component'; 
import { HomePage } from '../pages/home/home'; 
import { LoginPage } from '../pages/login/login'; 
import { BookRidePage } from '../pages/book-ride/book-ride'; 
import { AutocompletePage } from '../pages/auto-complete/auto-complete'; 
import { ProfilePage } from '../pages/profile/profile'; 
import { HistoryPage } from '../pages/history/history'; 
import { PaymentMethodsPage } from '../pages/payment-methods/payment-methods'; 

import { UberAPI } from '../services/uber.service'; 
import { Storage } from '@ionic/storage'; 

import { StatusBar } from '@ionic-native/status-bar'; 
import { SplashScreen } from '@ionic-native/splash-screen'; 
import { Diagnostic } from '@ionic-native/diagnostic'; 

// export function provideStorage() { 
//   return new Storage();  
// } 

@NgModule({ 
  declarations: [ 
    MyApp, 
    HomePage, 
    LoginPage, 
    BookRidePage, 
    AutocompletePage, 
    ProfilePage, 
    HistoryPage, 
    PaymentMethodsPage 
  ], 
  imports: [ 
    IonicModule.forRoot(MyApp) 
  ], 
  bootstrap: [IonicApp], 
  entryComponents: [ 
    MyApp, 
    HomePage, 
    LoginPage, 
    BookRidePage, 
    AutocompletePage, 
    ProfilePage, 
    HistoryPage, 
    PaymentMethodsPage 
  ], 
  providers: [{ provide: ErrorHandler, useClass: IonicErrorHandler }, 
    UberAPI, 
    // {provide: Storage, useFactory: provideStorage}, 
    Storage, 
    StatusBar, 
    SplashScreen, 
    Diagnostic 
  ] 
}) 
export class AppModule { }

```

现在我们要更新我们搭建的三个页面。这些页面中的几乎所有内容都是不言自明的。

`riderr/src/pages/profile/profile.html`中的 HTML 将如下所示:

```html
<ion-header> 
    <ion-navbar>s 
        <button ion-button menuToggle> 
            <ion-icon name="menu"></ion-icon> 
        </button> 
        <ion-title>Riderr</ion-title> 
    </ion-navbar> 
</ion-header> 
<ion-content padding> 
    <h2 text-center>Your Profile</h2> 
    <hr> 
    <ion-list *ngIf="profile"> 
        <ion-item> 
            <ion-avatar item-left> 
                <img src="{{profile.picture}}"> 
            </ion-avatar> 
            <h2>{{profile.first_name}} {{profile.last_name}}</h2> 
            <h3>{{profile.email}}</h3> 
            <p>{{profile.promo_code}}</p> 
        </ion-item> 
    </ion-list> 
</ion-content>

```

所需的逻辑将在`riderr/src/pages/profile/profile.ts`中，如下代码所示:

```html
import { Component } from '@angular/core'; 
import { UberAPI } from '../../services/uber.service'; 

@Component({ 
  selector: 'page-profile', 
  templateUrl: 'profile.html' 
}) 
export class ProfilePage { 
  private profile; 
  constructor(private uberApi: UberAPI) { } 

  ngAfterViewInit() { 
    this.uberApi.getMe().subscribe((data) => { 
      // console.log(data.json()); 
      this.profile = data.json(); 
      // need a clean way to fix this! 
      this.uberApi.hideLoader(); 
    }, (err) => { 
      console.log(err); 
      this.uberApi.hideLoader(); 
    }); 
  } 
}

```

接下来，我们将与`HistoryPage`一起工作。`riderr/src/pages/history/history.html`的 HTML 如下:

```html
<ion-header> 
    <ion-navbar> 
        <button ion-button menuToggle> 
            <ion-icon name="menu"></ion-icon> 
        </button> 
        <ion-title>Riderr</ion-title> 
    </ion-navbar> 
</ion-header> 
<ion-content padding> 
    <h2 text-center>Your Ride History</h2> 
    <hr> 
    <h3 text-center *ngIf="total">Showing last {{count}} of {{total}} rides</h3> 
    <ion-list> 
        <ion-item *ngFor="let h of history"> 
            <h2>{{ h.start_city.display_name }}</h2> 
            <h3>Completed at {{ h.end_time | date: 'hh:mm a'}}</h3> 
            <p>Distance : {{ h.distance }} Miles</p> 
        </ion-item> 
    </ion-list> 
</ion-content>

```

相关的逻辑将在`riderr/src/pages/history/history.ts`中，如图所示:

```html
import { Component } from '@angular/core'; 
import { UberAPI } from '../../services/uber.service'; 

@Component({ 
  selector: 'page-history', 
  templateUrl: 'history.html' 
}) 
export class HistoryPage { 
  history: Array<any>; 
  total: Number; 
  count: Number; 

  constructor(private uberApi: UberAPI) { } 

  ngAfterViewInit() { 
    this.uberApi.getHistory().subscribe((data) => { 
      // console.log(data.json()); 
      let d = data.json(); 
      this.history = d.history; 
      this.total = d.count; 
      this.count = d.history.length; 

      // need a clean way to fix this! 
      this.uberApi.hideLoader(); 
    }, (err) => { 
      console.log(err); 
      this.uberApi.hideLoader(); 
    }); 
  } 
}

```

最后，我们将实施支付方式。相同的 HTML 将在`riderr/src/pages/payment-methods/payment-methods.html`中，如以下代码所示:

```html
<ion-header> 
    <ion-navbar> 
        <button ion-button menuToggle> 
            <ion-icon name="menu"></ion-icon> 
        </button> 
        <ion-title>Riderr</ion-title> 
    </ion-navbar> 
</ion-header> 
<ion-content padding> 
    <h2 text-center>Your Payment Methods</h2> 
    <hr> 
    <ion-list *ngIf="payment_methods"> 
        <ion-item *ngFor="let pm of payment_methods"> 
            <h2>{{ pm.type }}</h2> 
            <h3>{{ pm.description }}</h3> 
        </ion-item> 
    </ion-list> 
</ion-content>

```

`riderr/src/pages/payment-methods/payment-methods.ts`中所需的逻辑如下:

```html
import { Component } from '@angular/core'; 
import { UberAPI } from '../../services/uber.service'; 

@Component({ 
  selector: 'page-payment-methods', 
  templateUrl: 'payment-methods.html' 
}) 
export class PaymentMethodsPage { 
  payment_methods; 

  constructor(private uberApi: UberAPI) { } 

  ngAfterViewInit() { 
    this.uberApi.getPaymentMethods().subscribe((data) => { 
      // console.log(data.json()); 
      this.payment_methods = data.json().payment_methods; 
      // need a clean way to fix this! 
      this.uberApi.hideLoader(); 
    }, (err) => { 
      console.log(err); 
      this.uberApi.hideLoader(); 
    }); 
  } 
}

```

这样，我们就完成了所需的代码。接下来，我们将安装所需的插件和库。

# 正在安装依赖项

运行以下命令来安装此应用程序所需的科尔多瓦插件:

```html
ionic plugin add cordova.plugins.diagnostic 
ionic plugin add cordova-plugin-geolocation 
ionic plugin add cordova-plugin-inappbrowser 
ionic plugin add cordova-sqlite-storage 
ionic plugin add cordova-custom-config

```

以及它们的离子原生模块:

```html
npm install --save @ionic-native/google-maps 
npm install --save @ionic-native/Geolocation 
npm install --save @ionic-native/diagnostic 
npm install --save @ionic-native/in-app-browser 
npm install --save @ionic/storage

```

接下来，我们将为谷歌地图安装科尔多瓦插件。但是在安装之前，我们需要获得一个 API 密钥。使用[https://developers . Google . com/Maps/documentation/android-API/registration](https://developers.google.com/maps/documentation/android-api/signup)上的“获取密钥”按钮，为 Android 应用程序启用 Google Maps API 并获取密钥。转到 iOS 的以下页面:[https://developers . Google . com/maps/documentation/iOS-SDK/get-API-key](https://developers.google.com/maps/documentation/ios-sdk/get-api-key)。

获得应用编程接口密钥后，运行以下命令:

```html
ionic plugin add cordova-plugin-googlemaps --variable API_KEY_FOR_ANDROID=" AIzaSyCZhTJB1kFAP70RuwDtt6uso9e3DCLdRWs" --variable API_KEY_FOR_IOS="AIzaSyCZhTJB1kFAP70RuwDtt6uso9e3DCLdRWs"

```

注意:请用您的按键更新前面的命令。

接下来，为了使用谷歌地图位置服务，我们需要获得一个通过 JavaScript 访问地图服务的应用编程接口密钥。导航到[https://developers . Google . com/maps/documentation/JavaScript/get-API-key](https://developers.google.com/maps/documentation/javascript/get-api-key)获取 JavaScript 的密钥。然后打开`riderr/src/index.html`，在文档的表头部分添加以下引用:

```html
<script src="http://maps.google.com/maps/api/js?v=3&libraries=places&key=AIzaSyDmFpX80vy5p0YTuXGAgVJzWTkZfDqPl_s"></script>

```

接下来，为了让 TypeScript 编译器不抱怨在`riderr/src/pages/auto-complete/auto-complete.ts`中使用变量`google`，我们需要添加所需的类型。运行以下命令:

```html
npm install typings --global

```

接下来，我们运行以下命令:

```html
typings install dt~google.maps --global --save

```

打开`riderr/tsconfig.json`，将`"typings/*.d.ts"`添加到`"include"`数组，如下图所示:

```html
{ 
  "compilerOptions": { 
    "allowSyntheticDefaultImports": true, 
    "declaration": false, 
    "emitDecoratorMetadata": true, 
    "experimentalDecorators": true, 
    "lib": [ 
      "dom", 
      "es2015" 
    ], 
    "module": "es2015", 
    "moduleResolution": "node", 
    "sourceMap": true, 
    "target": "es5" 
  }, 
  "include": [ 
    "src/**/*.ts", 
    "typings/*.d.ts" 
  ], 
  "exclude": [ 
    "node_modules" 
  ], 
  "compileOnSave": false, 
  "atom": { 
    "rewriteTsconfig": false 
  } 
}

```

更多信息请参考*如何安装谷歌地图打字:[http://stackoverflow.com/a/40854384/1015046](http://stackoverflow.com/a/40854384/1015046)。*

最后，我们需要申请互联网接入和网络访问许可。打开`riderr/config.xml`并更新`<platform name="android"></ platform>`，如图所示:

```html
<platform name="android"> 
        <allow-intent href="market:*" /> 
        <config-file target="AndroidManifest.xml" parent="/*"> 
            <uses-permission android:name="android.permission.INTERNET" 
            /> 
            <uses-permission 
            android:name="android.permission.ACCESS_FINE_LOCATION" /> 
            <uses-permission 
            android:name="android.permission.ACCESS_COARSE_LOCATION" /> 
        </config-file> 
    </platform>

```

然后将`xmlns:android=http://schemas.android.com/apk/res/android`添加到页面顶部的 widget 标签中，如图所示:

```html
<widget id="app.example.riderr" version="0.0.1"  xmlns:cdv="http://cordova.apache.org/ns/1.0" xmlns:android="http://schemas.android.com/apk/res/android">

```

这就结束了*安装依赖项*部分。

# 测试应用程序

让我们继续测试这个应用程序。首先，我们需要添加所需的平台。运行`ionic platform add android`或`ionic platform add ios`。

为了测试这个应用，我们需要一个模拟器或者一个实际的设备。

一旦设置好设备/仿真器，我们可以运行命令`ionic run android`或`ionic run ios`。

流程如下:

首先，用户启动应用程序。将显示登录屏幕，如下所示:

![](img/00096.jpeg)

一旦用户点击使用优步登录，我们会将用户重定向到优步身份验证屏幕，用户将使用他们的优步帐户登录:

![](img/00097.jpeg)

身份验证成功后，同意屏幕将显示应用程序请求的权限列表:

![](img/00098.jpeg)

一旦用户允许应用程序访问数据，我们会将用户重定向到主页。

在主页上，我们提供了用于访问用户位置的同意弹出窗口:

![](img/00099.jpeg)

一旦获得批准，我们就可以获得用户的地理位置，并使用该位置获得产品。

以下是完全加载的主屏幕截图:

![](img/00100.jpeg)

菜单如下:

![](img/00101.jpeg)

从这里，用户可以查看他们的个人资料:

![](img/00102.gif)

他们可以查看自己的乘车历史:

![](img/00103.gif)

他们还可以查看自己的支付方式:

![](img/00104.gif)

在用户选择目的地之前，他们需要挑选产品:

![](img/00105.jpeg)

一旦他们选择了产品，他们就可以选择目的地:

![](img/00106.jpeg)

现在，我们制作票价详细信息并显示相同的内容:

![](img/00107.jpeg)

如果用户同意，我们将预订游乐设备并显示游乐设备信息:

![](img/00108.jpeg)

请注意应用程序右上角的取消乘坐按钮。这将取消当前乘坐。

再次提醒一下，我们正在调用沙盒应用编程接口网址。如果您想申请实际乘坐，请在`riderr/src/services/uber.service.ts`将`UBERSANDBOXAPIURL`更新为`UBERAPIURL`。

使用优步(生产)应用编程接口，当我们请求搭车时，我们会收到一个处理响应。我们可以继续轮询几次来获取当前的乘车信息。如果您提出实际的乘车请求，这就是响应的样子:

```html
{ 
    "status": "accepted", 
    "product_id": "18ba4578-b11b-49a6-a992-a132f540b027", 
    "destination": { 
        "latitude": 17.445949, 
        "eta": 34, 
        "longitude": 78.350058 
    }, 
    "driver": { 
        "phone_number": "+910000000000", 
        "rating": 4.6, 
        "picture_url": 
        "https:\/\/d1w2poirtb3as9.cloudfront.net\
        /605de11c25139a1de469.jpeg", 
        "name": "John Doe", 
        "sms_number": null 
    }, 
    "pickup": { 
        "latitude": 17.4908514, 
        "eta": 13, 
        "longitude": 78.3375952 
    }, 
    "request_id": "1beaae05-8d43-4711-951c-25dd5293c2f9", 
    "location": { 
        "latitude": 17.4875583, 
        "bearing": 338, 
        "longitude": 78.33165 
    }, 
    "vehicle": { 
        "make": "Maruti Suzuki", 
        "picture_url": null, 
        "model": "Swift Dzire", 
        "license_plate": "XXXXXXXX" 
    }, 
    "shared": false 
}

```

您可以相应地构建您的界面。

# 摘要

在这一章中，我们已经完成了用离子构建一个应用程序，并使用离子原生将它与优步应用编程接口以及设备功能集成在一起。我们还使用了谷歌位置服务作为原始的 JavaScript 库，并使用打字员将其与我们的离子应用程序集成在一起。

在下一章中，我们将研究将离子 1 应用迁移到离子 2。这将适用于你从离子 1 移动到离子 3。