# 二、CSS 的规模化问题

在最后一章中，我们讨论了产生 ECSS 方法的场景。一个庞大的 CSS 代码库，开发人员发现很难推理，使用起来很麻烦，并且到处都是注释不良和冗余的代码。然而，没有 CSS 代码库是这样开始的。

在大多数项目中，CSS 从一些简单的规则开始。一开始，你必须做一些相当愚蠢的事情来使 CSS 的维护成为问题。

然而，随着项目的增长，CSS 也在增长。需求变得更加复杂。越来越多的作者参与到写作风格中。边缘案例和浏览器变通办法需要被创作和考虑在内。事情很容易变得难以驾驭。

让我们考虑一下对一个不起眼的小部件日益增长的需求:

*   *当 widget 在侧边栏的时候，我们可以缩小字体大小吗？*
*   *当我们在主页上时，小部件可以有不同的背景颜色吗？*
*   *我们可以在更大的视窗中垂直堆叠小部件内部的东西吗？*
*   *当 widget 在产品页面侧边栏时，字体颜色需要改变*

不久之后，我们需要为一个键选择器编写大量的覆盖。让我们考虑一下我们可能需要的选择器:

```html
.widget{
    /* Base Styles */
}

aside#sidebar .widget {
    /* Sidebar specific */
}

body.home-page aside#sidebar .widget {
    /* Home page sidebar specific */
}

@media (min-width: 600px) {
    .widget {
        /* Base Styles 600px and above */
    }

    aside#sidebar .widget {
        /* Sidebar specific 600px and above */
    }

    body.home-page aside#sidebar .widget {
        /* Home page sidebar specific 600px and above */
   }    
}

body.product-page .widget {
    /* Product page specific */
}

body.product-page aside#sidebar .widget {
    /* Product page sidebar specific */
}
```

如果这是我们想要扩展的 CSS，就会有一些基本的创作问题。现在让我们考虑这些规则中一些更明显的问题。

### 注

术语*键选择器*用于描述任何 CSS 规则中最右边的选择器。这是您试图影响更改的选择器。

# 特异性

当试图扩展 CSS 时，第一个主要问题是特异性的问题。通常，特异性是一件有用的事情。它允许我们在 CSS 中引入某种形式的逻辑。比其他样式更具体的样式会在浏览器中应用。我们上面的例子演示了这一点:不同的规则将在不同的事件中应用(例如，当在侧边栏中时，我们想要覆盖默认的样式)。

现在，CSS 选择器可以由 ID、类、属性和类型选择器以及它们的任意组合组成。有了响应性的设计，您也可以将媒体查询加入其中。

然而，并非所有的选择器都是平等的。W3C 在这里描述了如何计算特异性:[http://www.w3.org/TR/css3-selectors/#specificity](http://www.w3.org/TR/css3-selectors/#specificity)。以下是最相关的部分:

> *一个选择器的专一性计算如下:统计选择器中 ID 选择器的个数(= a)统计选择器中类选择器、属性选择器和伪类的个数(= b)统计选择器中类型选择器和伪元素的个数(= c)忽略否定伪类内部的通用选择器与其他一样统计，但否定本身不算伪类。将三个数字 a-b-c 串联起来(在基数较大的数字系统中)就有了特异性。*

这里缺少了一个重要的东西，那就是风格属性。其他地方的信息告诉我们:

> *样式属性中的声明适用于该属性所属的元素。在级联中，这些声明被认为具有作者起源和比任何选择器更高的特异性。*

因此，在元素的样式属性中应用的样式将比 CSS 文件中的等效规则更具体。

无论如何，这里最大的收获是，ID 选择器比基于类的选择器更加具体。这使得覆盖任何包含基于标识的选择器更加困难。例如，侧边栏中有一个小部件，这将不起作用:

```html
.widget {
   /* Widget in the sidebar */
}

aside#sidebar .widget {
    /* Widget in an aside element with the ID of sidebar */
}

.class-on-sidebar .widget {
    /* Why doesn't this work */
}
```

在这种情况下，我们将在侧边栏元素(具有侧边栏标识的侧边元素)上应用一个 HTML 类(`class-on-sidebar`)，然后在 CSS 中选择它，低于基于标识的选择器。然而，该规则仍然不会适用。

从 W3C 规范中了解我们所知道的特性，我们可以计算出这些规则的特性。

让我们算一下数字。从左到右，下面选择器后面的数字涉及:内联样式的数量、ID 选择器的数量、类选择器的数量，最后是类型选择器的数量。

<colgroup class="calibre12"><col class="calibre13"> <col class="calibre13"> <col class="calibre13"> <col class="calibre13"> <col class="calibre13"></colgroup> 
| **选择器** | **直列** | **ID** | **级** | **型** |
| `.widget` | Zero | Zero | one | Zero |
| `aside#sidebar .widget` | Zero | one | one | one |
| `.class-on-sidebar .widget` | Zero | Zero | Two | Zero |

所以你可以在这里看到，中间选择器比最后一个有更大的特异性。糟糕。

对于单个或更小的文件来说，这没什么大不了的。我们只是创建一个更具体的规则。但是，如果您的代码库的 CSS 被分割成许多更小的部分 CSS 文件，找到一个阻止您的重写工作的规则可能会成为不必要的负担。现在，这个问题不是特定于 ID 选择器的。样式表中权重不等的选择器更成问题。把它想象成一个重量级拳击手和一个轻量级拳击手的对决。这不是一场公平的比赛。在所使用的选择器之间创造一个公平的竞争环境比实际使用的选择器更重要。

这种选择者的不匹配是特异性问题的关键。一旦你有了一个包含数百条规则的 CSS 代码库，任何不必要的特性都开始成为快速开发的主要障碍。

因此，总而言之，在不断增长的 CSS 代码库中，特定性是我们需要解决的一个问题。

# 绑定到选择器的标记结构

在创作 CSS 进行缩放时要避免的另一种做法是使用类型选择器；与特定标记相关的选择器。例如:

```html
aside#sidebar ul > li a {
    /* Styles */
}
```

在这种情况下，我们需要在一个`li`中有一个`a`标签，它是一个`sidebar` - phew 的`aside`元素中的一个`ul`的直接子元素！

如果我们想将这些风格应用到其他地方会发生什么？或者任何其他标记结构？

我们只是不必要地将我们的规则与特定的标记结构联系起来。这样做通常很有诱惑力，因为将一个类添加到像`a`或`span`标签这样(看似)琐碎的东西中似乎很可笑。然而，我希望一旦你读到这本书的结尾，你会被说服避免这种做法。

我们希望 CSS 尽可能与结构松散耦合。这样，如果我们需要引入一个覆盖(一个特定实例的更具体的选择器)，我们可以尽可能模糊地完成工作。再一次，习惯于只引入所需数量的特性的想法。

# 级联

通常，*级联样式表*的级联部分是有用的。即使特定性在所使用的选择器之间非常相等，级联也允许 CSS 中更低层次的等价规则应用于更高层次的现有规则。

然而，在一个大的代码库中，级联呈现出一种不受欢迎的诱惑；开发人员只需在现有 CSS 的底部编写更多的新代码，就可以走修改现有 CSS 的捷径。

这种诱惑既真实又容易认同。这可能很诱人，原因有很多。例如，更熟悉需要对 CSS 进行更改的其他语言的作者可能缺乏对 CSS 代码库的信心或深入了解，无法自信地删除或修改现有代码。因此，他们选择了最安全的选项，并使用一组更具体的规则来覆盖现有的规则。当时，这似乎是负责任的做法——只需根据需要添加一两个规则。

然而，以这种方式依赖级联的问题是，随着时间和迭代，CSS 代码会因为许多冗余规则而变得臃肿。这个 CSS 的消费者(用户)下载的 CSS 充满了他们的浏览器根本不需要的 cruft，并且这个代码的维护者每次需要理解他们的代码库时都有更多的代码要筛选。

# 总结

在这一点上，我们已经对一些问题进行了高层次的观察，这些问题是 CSS 代码库难以大规模处理的症状。诸如过于特定的选择器、与特定标记结构相关联的选择器、依赖级联的诱惑以及随之而来的 CSS 膨胀等问题。

在下一章中，我们将看看试图驯服大型 CSS 代码库的公认智慧和方法，并考虑它们存在的任何缺点。